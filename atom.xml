<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Violet`Blog</title>
  <icon>https://www.gravatar.com/avatar/a1fb76727a9930bc7ef25541851ee785</icon>
  <subtitle>生活明朗 万物可爱</subtitle>
  <link href="https://qwq3.top/atom.xml" rel="self"/>
  
  <link href="https://qwq3.top/"/>
  <updated>2021-11-18T04:02:22.746Z</updated>
  <id>https://qwq3.top/</id>
  
  <author>
    <name>Violet</name>
    <email>2268025923@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue3 源码解析</title>
    <link href="https://qwq3.top/posts/24d6.html"/>
    <id>https://qwq3.top/posts/24d6.html</id>
    <published>2021-10-15T18:10:12.000Z</published>
    <updated>2021-11-18T04:02:22.746Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>vue 源码解析</p></blockquote><h3 id="真实的-DOM-渲染"><a href="#真实的-DOM-渲染" class="headerlink" title="真实的 DOM 渲染"></a>真实的 DOM 渲染</h3><p>我们传统的前端开发中，我们是编写自己的 HTML，最终被渲染到浏览器上的，那么它是什么样的过程呢？</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20211007092421040.png"></p><h3 id="虚拟-DOM-的优势"><a href="#虚拟-DOM-的优势" class="headerlink" title="虚拟 DOM 的优势"></a>虚拟 DOM 的优势</h3><p><strong>目前框架都会引入虚拟 DOM 来对真实的 DOM 进行抽象，这样做有很多的好处：</strong></p><p>首先是可以对真实的元素节点进行抽象，抽象成 VNode（虚拟节点），这样方便后续对其进行各种操作：</p><ul><li>因为对于直接操作 DOM 来说是有很多的限制的，比如 diff、clone 等等，但是使用 JavaScript 编程语言来操作这些，就变得非常的简单；</li><li>我们可以使用 JavaScript 来表达非常多的逻辑，而对于 DOM 本身来说是非常不方便的；</li></ul><p>其次是方便实现跨平台，包括你可以将 VNode 节点渲染成任意你想要的节点</p><ul><li>如渲染在 canvas、WebGL、SSR、Native（iOS、Android）上；</li><li>并且 Vue 允许你开发属于自己的渲染器（renderer），在其他的平台上渲染；</li></ul><h3 id="虚拟-DOM-的渲染过程"><a href="#虚拟-DOM-的渲染过程" class="headerlink" title="虚拟 DOM 的渲染过程"></a>虚拟 DOM 的渲染过程</h3><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20211007092642018.png"></p><h3 id="三大核心系统"><a href="#三大核心系统" class="headerlink" title="三大核心系统"></a>三大核心系统</h3><p>事实上 Vue 的源码包含三大核心：</p><ul><li>Compiler 模块：编译模板系统；</li><li>Runtime 模块：也可以称之为 Renderer 模块，真正渲染的模块；</li><li>Reactivity 模块：响应式系统；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110070931633.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110070931546.png"></p><h3 id="三大系统协同工作"><a href="#三大系统协同工作" class="headerlink" title="三大系统协同工作"></a>三大系统协同工作</h3><p>三个系统之间如何协同工作呢：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110070932170.png" alt="image-20211007093225376"></p><h3 id="实现-Mini-Vue"><a href="#实现-Mini-Vue" class="headerlink" title="实现 Mini-Vue"></a>实现 Mini-Vue</h3><p>这里我们实现一个简洁版的 Mini-Vue 框架，该 Vue 包括三个模块：</p><ul><li>渲染系统模块；</li><li>可响应式系统模块；</li><li>应用程序入口模块；</li></ul><h3 id="渲染系统实现"><a href="#渲染系统实现" class="headerlink" title="渲染系统实现"></a>渲染系统实现</h3><p><strong>渲染系统</strong>，该模块主要包含三个功能：</p><ol><li>功能一：h 函数，用于返回一个 VNode 对象；</li><li>功能二：mount 函数，用于将 VNode 挂载到 DOM 上；</li><li>功能三：patch 函数，用于对两个 VNode 进行对比，决定如何处理新的 VNode；</li></ol><h3 id="h-函数-–-生成-VNode"><a href="#h-函数-–-生成-VNode" class="headerlink" title="h 函数 – 生成 VNode"></a>h 函数 – 生成 VNode</h3><p>h 函数的实现：</p><p>直接返回一个 VNode 对象即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110070933363.png" alt="image-20211007093333678"></p><h3 id="Mount-函数-–-挂载-VNode"><a href="#Mount-函数-–-挂载-VNode" class="headerlink" title="Mount 函数 – 挂载 VNode"></a>Mount 函数 – 挂载 VNode</h3><p><strong>mount 函数的实现：</strong></p><p>第一步：根据 tag，创建 HTML 元素，并且存储到 vnode 的 el 中；</p><p>第二步：处理 props 属性</p><ul><li>如果以 on 开头，那么监听事件；</li><li>普通属性直接通过 setAttribute 添加即可；</li></ul><p>第三步：处理子节点</p><ul><li>如果是字符串节点，那么直接设置 textContent；</li><li>如果是数组节点，那么遍历调用 mount 函数；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110070934732.png" alt="image-20211007093434818"></p><h3 id="Patch-函数-–-对比两个-VNode"><a href="#Patch-函数-–-对比两个-VNode" class="headerlink" title="Patch 函数 – 对比两个 VNode"></a>Patch 函数 – 对比两个 VNode</h3><p>patch 函数的实现，分为两种情况</p><ol><li><p>n1 和 n2 是不同类型的节点：</p><ul><li>找到 n1 的 el 父节点，删除原来的 n1 节点的 el；</li><li>挂载 n2 节点到 n1 的 el 父节点上；</li></ul></li><li><p>n1 和 n2 节点是相同的节点：</p><blockquote><p>处理 props 的情况</p></blockquote><p>先将新节点的 props 全部挂载到 el 上；</p><p>判断旧节点的 props 是否不需要在新节点上，如果不需要，那么删除对应的属性；</p><blockquote><p>处理 children 的情况</p></blockquote><p>如果新节点是一个字符串类型，那么直接调用 el.textContent = newChildren；</p><p>如果新节点不同一个字符串类型：</p><ul><li>旧节点是一个字符串类型<br>将 el 的 textContent 设置为空字符串；<br>旧节点是一个字符串类型，那么直接遍历新节点，挂载到 el 上；</li><li>旧节点也是一个数组类型<br>取出数组的最小长度；<br>遍历所有的节点，新节点和旧节点进行 path 操作；<br>如果新节点的 length 更长，那么剩余的新节点进行挂载操作；<br>如果旧节点的 length 更长，那么剩余的旧节点进行卸载操作；</li></ul></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110070939630.png"></p><h3 id="依赖收集系统"><a href="#依赖收集系统" class="headerlink" title="依赖收集系统"></a>依赖收集系统</h3><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110070939663.png"></p><h3 id="响应式系统-Vue2-实现"><a href="#响应式系统-Vue2-实现" class="headerlink" title="响应式系统 Vue2 实现"></a>响应式系统 Vue2 实现</h3><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110070940199.png"></p><h3 id="响应式系统-Vue3-实现"><a href="#响应式系统-Vue3-实现" class="headerlink" title="响应式系统 Vue3 实现"></a>响应式系统 Vue3 实现</h3><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110070940837.png" alt="image-20211007094029945"></p><h3 id="为什么-Vue3-选择-Proxy-呢？"><a href="#为什么-Vue3-选择-Proxy-呢？" class="headerlink" title="为什么 Vue3 选择 Proxy 呢？"></a>为什么 Vue3 选择 Proxy 呢？</h3><p>Object.definedProperty 是劫持对象的属性时，如果新增元素：</p><ul><li>那么 Vue2 需要再次 调用 definedProperty，而 Proxy 劫持的是整个对象，不需要做特殊处理；</li></ul><p>修改对象的不同：</p><ul><li>使用 defineProperty 时，我们修改原来的 obj 对象就可以触发拦截；</li><li>而使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截；</li></ul><p>Proxy 能观察的类型比 defineProperty 更丰富</p><ul><li>has：in 操作符的捕获器；</li><li>deleteProperty：delete 操作符的捕捉器；</li><li>等等其他操作；</li></ul><p>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化；</p><p>缺点：Proxy 不兼容 IE，也没有 polyfill, defineProperty 能支持到 IE9</p><h3 id="框架外层-API-设计"><a href="#框架外层-API-设计" class="headerlink" title="框架外层 API 设计"></a>框架外层 API 设计</h3><p>这样我们就知道了，从框架的层面来说，我们需要</p><p>有两部分内容：</p><ul><li>createApp 用于创建一个 app 对象；</li><li>该 app 对象有一个 mount 方法，可以将根组件挂载到某一个 dom 元素上；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110070942246.png"></p><h3 id="源码阅读之-createApp"><a href="#源码阅读之-createApp" class="headerlink" title="源码阅读之 createApp"></a>源码阅读之 createApp</h3><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110070942441.png" alt="image-20211007094241406"></p><h3 id="源码阅读之挂载根组件"><a href="#源码阅读之挂载根组件" class="headerlink" title="源码阅读之挂载根组件"></a>源码阅读之挂载根组件</h3><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110070943061.png"></p><h3 id="组件化的初始化"><a href="#组件化的初始化" class="headerlink" title="组件化的初始化"></a>组件化的初始化</h3><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110070955027.png"></p><h3 id="Compile-过程"><a href="#Compile-过程" class="headerlink" title="Compile 过程"></a>Compile 过程</h3><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110070956287.png"></p><h3 id="Block-Tree-分析"><a href="#Block-Tree-分析" class="headerlink" title="Block Tree 分析"></a>Block Tree 分析</h3><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110070956407.png"></p><h3 id="生命周期回调"><a href="#生命周期回调" class="headerlink" title="生命周期回调"></a>生命周期回调</h3><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110071001048.png"></p><h3 id="template-中数据的使用顺序"><a href="#template-中数据的使用顺序" class="headerlink" title="template 中数据的使用顺序"></a>template 中数据的使用顺序</h3><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110071001046.png"></p>]]></content>
    
    
    <summary type="html">源码解析,vue2与vue3响应式对比</summary>
    
    
    
    
    <category term="Vue3" scheme="https://qwq3.top/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue3 Composition API</title>
    <link href="https://qwq3.top/posts/3d9.html"/>
    <id>https://qwq3.top/posts/3d9.html</id>
    <published>2021-10-09T11:10:12.000Z</published>
    <updated>2021-11-18T04:02:22.746Z</updated>
    
    <content type="html"><![CDATA[<p>前言</p><blockquote><p><strong>Composition API</strong></p></blockquote><h3 id="认识-Mixin"><a href="#认识-Mixin" class="headerlink" title="认识 Mixin"></a>认识 Mixin</h3><p>目前我们是使用组件化的方式在开发整个 Vue 的应用程序，但是<strong>组件和组件之间有时候会存在相同的代码逻辑</strong>，我们希望对<strong>相同的代码逻辑进行抽取</strong></p><blockquote><p>在 Vue2 和 Vue3 中都支持的一种方式就是<strong>使用 Mixin 来完成</strong>：</p></blockquote><p>Mixin 提供了一种非常灵活的方式，来<code>分发Vue组件中的可复用功能</code>；</p><p>一个 Mixin 对象可以包含<code>任何组件选项</code>；</p><p>当组件使用 Mixin 对象时，所有<code>Mixin对象的选项将被 混合 进入该组件本身的选项</code>中；</p><h4 id="Mixin-的基本使用"><a href="#Mixin-的基本使用" class="headerlink" title="Mixin 的基本使用"></a>Mixin 的基本使用</h4><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061118545.png"></p><h4 id="Mixin-的合并规则"><a href="#Mixin-的合并规则" class="headerlink" title="Mixin 的合并规则"></a>Mixin 的合并规则</h4><p><strong>如果 Mixin 对象中的选项和组件对象中的选项发生了冲突，那么 Vue 会如何操作呢？</strong></p><p>这里<code>分成不同的情况</code>来进行处理；</p><p><strong>情况一：如果是 data 函数的返回值对象</strong></p><p>返回值对象默认情况下会<code>进行合并</code>；</p><p>如果 data 返回值对象的属性发生了冲突，那么会<code>保留组件自身的数据</code>；</p><p><strong>情况二：如何生命周期钩子函数</strong></p><p>生命周期的钩子函数<code>会被合并到数组</code>中，都会被调用；</p><p><strong>情况三：值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。</strong></p><p>比如都有<code>methods选项</code>，并且都定义了方法，那么<code>它们都会生效</code>；</p><p>但是如果<code>对象的key相同</code>，那么<code>会取组件对象的键值对</code>；</p><h4 id="全局混入-Mixin"><a href="#全局混入-Mixin" class="headerlink" title="全局混入 Mixin"></a>全局混入 Mixin</h4><p><strong>如果组件中的某些选项，是所有的组件都需要拥有的，那么这个时候我们可以使用</strong><code>全局的mixin</code><strong>：</strong></p><ul><li>全局的 Mixin 可以使用 应用 app 的方法 mixin 来完成注册；</li><li>一旦注册，那么全局混入的选项将会影响每一个组件；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061120673.png"></p><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p>另外一个类似于 Mixin 的方式是<strong>通过 extends 属性</strong>：</p><p>允许声明扩展另外一个组件，<code>类似于Mixins</code>；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061435049.png"></p><p>在开发中<strong>extends 用的非常少</strong>，在 Vue2 中比较<strong>推荐大家使用 Mixin</strong>，而在 Vue3 中<strong>推荐使用 Composition API</strong>。</p><h3 id="Options-API-的弊端"><a href="#Options-API-的弊端" class="headerlink" title="Options API 的弊端"></a>Options API 的弊端</h3><blockquote><p>在 Vue2 中，我们<strong>编写组件的方式是 Options API</strong>：</p></blockquote><p>Options API 的一大特点就是在<code>对应的属性</code>中编写<code>对应的功能模块</code>；</p><p>比如<code>data定义数据</code>、<code>methods中定义方法</code>、<code>computed中定义计算属性</code>、<code>watch中监听属性改变</code>，也包括<code>生命周期钩子</code>；</p><blockquote><p><strong>但是这种代码有一个很大的弊端：</strong></p></blockquote><p>当我们<code>实现某一个功能</code>时，这个功能<code>对应的代码逻辑</code>会被<code>拆分到各个属性</code>中；</p><p>当我们<code>组件变得更大</code>、<code>更复杂</code>时，<code>逻辑关注点的列表</code>就会增长，那么<code>同一个功能的逻辑就会被拆分的很分散</code>；</p><p>尤其对于那些一开始<code>没有编写这些组件的人</code>来说，这个组件的代码是<code>难以阅读和理解的</code>（阅读组件的其他人）；</p><blockquote><p><strong>下面我们来看一个非常大的组件，其中的逻辑功能按照颜色进行了划分：</strong></p></blockquote><p>这种<code>碎片化的代码</code>使用<code>理解和维护这个复杂的组件</code>变得异常困难，并且<code>隐藏了潜在的逻辑问题</code>；</p><p>并且当我们<code>处理单个逻辑关注点</code>时，需要不断的<code>跳到相应的代码块</code>中；</p><h3 id="大组件的逻辑分散"><a href="#大组件的逻辑分散" class="headerlink" title="大组件的逻辑分散"></a>大组件的逻辑分散</h3><p>如果我们能将<code>同一个逻辑关注点相关的代码</code>收集<code>在一起</code>会更好。</p><p><strong>这就是 Composition API 想要做的事情，以及可以帮助我们完成的事情。</strong></p><p>也有人把 Vue CompositionAPI 简称为<strong>VCA</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061438782.png"></p><h3 id="认识-Composition-API"><a href="#认识-Composition-API" class="headerlink" title="认识 Composition API"></a>认识 Composition API</h3><blockquote><p>那么既然知道 Composition API 想要帮助我们做什么事情，接下来看一下<strong>到底是怎么做</strong>呢？</p></blockquote><p>为了开始使用 Composition API，我们需要有一个可以实际使用它<code>（编写代码）的地方</code>；</p><p>在 Vue 组件中，这个位置就是 <code>setup 函数</code>；</p><blockquote><p><strong>setup 其实就是组件的另外一个选项：</strong></p></blockquote><p>只不过这个选项强大到我们可以<code>用它来替代之前所编写的大部分其他选项</code>；</p><p>比如<code>methods</code>、<code>computed</code>、<code>watch</code>、<code>data</code>、<code>生命周期</code>等等；</p><p><strong>接下来我们一起学习这个函数的使用：</strong></p><p>函数的参数</p><p>函数的返回值</p><h3 id="setup-函数的参数"><a href="#setup-函数的参数" class="headerlink" title="setup 函数的参数"></a>setup 函数的参数</h3><p>我们先来研究一个 setup 函数的参数，它主要<strong>有两个参数</strong>：</p><ol><li>第一个参数：<code>props</code></li><li>第二个参数：<code>context</code></li></ol><p>props 非常好理解，它其实就是<strong>父组件传递过来的属性</strong>会被<strong>放到 props 对象</strong>中，我们在<strong>setup 中如果需要使用</strong>，那么就可以直接<strong>通过 props 参数获取：</strong></p><ul><li>对于<code>定义props的类型</code>，我们还是<code>和之前的规则是一样的，在props选项中定义</code>；</li><li>并且<code>在template中</code>依然是可以<code>正常去使用props中的属性</code>，比如 message；</li><li>如果我们<code>在setup函数中想要使用props</code>，那么<code>不可以通过 this 去获取</code>（后面我会讲到为什么）；</li><li>因为 props 有直接<code>作为参数传递到setup函数</code>中，所以我们可以<code>直接通过参数</code>来使用即可；</li></ul><p>另外一个参数是 context，我们也称之为是一个<strong>SetupContext</strong>，它里面<strong>包含三个属性</strong>：</p><ul><li><code>attrs</code>：所有的非 prop 的 attribute；</li><li><code>slots</code>：父组件传递过来的插槽（这个在以渲染函数返回时会有作用，后面会讲到）；</li><li><code>emit</code>：当我们组件内部需要发出事件时会用到 emit（因为我们不能访问 this，所以不可以通过 this.$emit 发出事件）；</li></ul><h3 id="setup-函数的返回值"><a href="#setup-函数的返回值" class="headerlink" title="setup 函数的返回值"></a><strong>setup 函数的返回值</strong></h3><blockquote><p>setup 既然是一个函数，那么它也可以有<strong>返回值</strong>，<strong>它的返回值用来做什么呢？</strong></p></blockquote><p>setup 的返回值可以在<code>模板template中被使用</code>；</p><p>也就是说我们可以<code>通过setup的返回值来替代data选项</code>；</p><blockquote><p>甚至是我们可以<strong>返回一个执行函数</strong>来<strong>代替在 methods 中定义的方法</strong></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061442198.png"></p><p>但是，如果我们将 counter 在 increment 或者 decrement 进行操作时，<strong>是否可以实现界面的响应式呢？</strong></p><p>答案是<code>不可以</code>；</p><p>这是因为对于一个<code>定义的变量</code>来说，默认情况下，<code>Vue并不会跟踪它的变化，来引起界面的响应式操作</code>；</p><h4 id="setup-不可以使用-this"><a href="#setup-不可以使用-this" class="headerlink" title="setup 不可以使用 this"></a>setup 不可以使用 this</h4><p><strong>官方关于 this 有这样一段描述</strong></p><ul><li>表达的含义是<code>this并没有指向当前组件实例</code>；</li><li>并且<code>在setup被调用之前，data、computed、methods</code>等都没有被解析；</li><li>所以<code>无法在setup中获取this</code>；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061444447.png"></p><h3 id="Reactive-API"><a href="#Reactive-API" class="headerlink" title="Reactive API"></a>Reactive API</h3><p>如果想为在 setup 中定义的数据提供响应式的特性，那么我们可以<strong>使用 reactive 的函数</strong>：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061445468.png"></p><p><strong>那么这是什么原因呢？为什么就可以变成响应式的呢？</strong></p><ul><li>这是因为当我们<code>使用reactive函数处理我们的数据之后</code>，数据<code>再次被使用</code>时就会<code>进行依赖收集</code>；</li><li>当<code>数据发生改变</code>时，所有收集到的依赖都是<code>进行对应的响应式操作</code>（比如更新界面）；</li><li>事实上，我们编写的<code>data选项</code>，也是在内部<code>交给了reactive函数</code>将其编程响应式对象的；</li></ul><h3 id="Ref-API"><a href="#Ref-API" class="headerlink" title="Ref API"></a>Ref API</h3><p>reactive API 对<strong>传入的类型是有限制的</strong>，它要求我们必须传入的是<strong>一个对象或者数组类型</strong>：</p><p>如果我们传入一个<code>基本数据类型（String、Number、Boolean）会报一个警告</code>；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061446995.png" alt="image-20211006144638237"></p><p>这个时候 Vue3 给我们提供了<strong>另外一个 API：ref API</strong></p><ul><li>ref 会返回一个<code>可变的响应式对象</code>，该对象作为一个 <strong>响应式的引用</strong> 维护着它<code>内部的值</code>，这就是<code>ref名称的来源</code>；</li><li>它内部的值是<code>在ref的 value 属性</code>中被维护的；</li></ul><p><strong>这里有两个注意事项：</strong></p><ul><li>在<code>模板中引入ref的值</code>时，Vue 会<code>自动帮助我们进行解包</code>操作，所以我们并<code>不需要在模板中通过 ref.value </code>的方式来使用；</li><li>但是在<code> setup 函数内部</code>，它依然是一个 <code>ref引用</code>， 所以对其进行操作时，我们依然需要<code>使用 ref.value的方式</code>；</li></ul><h4 id="Ref-自动解包"><a href="#Ref-自动解包" class="headerlink" title="Ref 自动解包"></a>Ref 自动解包</h4><ul><li><strong>模板中的解包是浅层的解包</strong>，如果我们的代码是下面的方式：</li><li>如果我们<strong>将 ref 放到一个 reactive 的属性</strong>当中，那么<strong>在模板中使用时，它会自动解包</strong>：</li></ul><p><img src= "/img/loading.gif" data-lazy-src="C:\Users\Violet\AppData\Roaming\Typora\typora-user-images\image-20211006144905705.png" alt="image-20211006144905705"></p><h3 id="认识-readonly"><a href="#认识-readonly" class="headerlink" title="认识 readonly"></a><strong>认识 readonly</strong></h3><p>我们通过<strong>reactive 或者 ref 可以获取到一个响应式的对象</strong>，但是某些情况下，我们<strong>传入给其他地方（组件）</strong>的这个响应式对象希望<strong>在另外一个地方（组件）被使用</strong>，但是<strong>不能被修改</strong>，这个时候<strong>如何防止这种情况的出现</strong>呢？</p><ul><li>Vue3 为我们提供了<code>readonly的方法</code>；</li><li><code>readonly会返回原生对象的只读代理</code>（也就是它依然是一个 Proxy，这是一个<code>proxy的set方法被劫持</code>，并且不能对其进行修改）；</li></ul><p><strong>在开发中常见的 readonly 方法会传入三个类型的参数：</strong></p><p>类型一：<code>普通对象</code>；</p><p>类型二：<code>reactive返回的对象</code>；</p><p>类型三：<code>ref的对象</code>；</p><h4 id="readonly-的使用"><a href="#readonly-的使用" class="headerlink" title="readonly 的使用"></a>readonly 的使用</h4><p><strong>在 readonly 的使用过程中，有如下规则：</strong></p><ul><li>readonly 返回的对象都是不允许修改的；</li><li>但是经过 readonly 处理的原来的对象是允许被修改的；<ol><li>比如 const info = readonly(obj)，info 对象是不允许被修改的；</li><li>当 obj 被修改时，readonly 返回的 info 对象也会被修改；</li><li>但是我们不能去修改 readonly 返回的对象 info；</li></ol></li><li>其实本质上就是 readonly 返回的对象的 setter 方法被劫持了而已；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061453070.png" alt="image-20211006145326912"></p><h4 id="readonly-的应用"><a href="#readonly-的应用" class="headerlink" title="readonly 的应用"></a>readonly 的应用</h4><p><strong>那么这个 readonly 有什么用呢？</strong></p><p>在我们传递给其他组件数据时，往往希望其他组件使用我们传递的内容，但是不允许它们修改时，就可以使用</p><p>readonly 了；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061454948.png" alt="image-20211006145427675"></p><h3 id="Reactive-判断的-API"><a href="#Reactive-判断的-API" class="headerlink" title="Reactive 判断的 API"></a>Reactive 判断的 API</h3><p><strong>isProxy</strong></p><ul><li>检查对象<code>是否是由 reactive 或 readonly创建的 proxy</code>。</li></ul><p><strong>isReactive</strong></p><ul><li>检查对象<code>是否是由 reactive创建的响应式代理</code>：</li><li>如果<code>该代理是 readonly 建的</code>，但<code>包裹了由 reactive 创建的另一个代理</code>，它也会返回 true；</li></ul><p><strong>isRedonly</strong></p><ul><li>检查对象<code>是否是由 readonly 创建的只读代理</code>。</li></ul><p><strong>toRaw</strong></p><ul><li>返回 <code>reactive 或 readonly 代理的原始对象</code>（<strong>不</strong>建议保留对原始对象的持久引用。请谨慎使用）。</li></ul><p><strong>shallowReactive</strong></p><ul><li>创建一个响应式代理，它跟踪其自身 property 的响应性，但<code>不执行嵌套对象的深层响应式转换 </code>(深层还是原生对象)。</li></ul><p><strong>shallowReadonly</strong></p><ul><li>创建一个 proxy，使其自身的 property 为只读，但<code>不执行嵌套对象的深度只读转换</code>（深层还是可读、可写的）。</li></ul><h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h3><p>如果我们使用<strong>ES6 的解构语法</strong>，对<strong>reactive 返回的对象进行解构获取值</strong>，那么之后无论是<strong>修改结构后的变量</strong>，还是<strong>修改 reactive 返回的 state 对象</strong>，**<code>数据都不再是响应式</code>**的</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061457107.png" alt="image-20211006145700279"></p><p>那么有没有办法<strong>让我们解构出来的属性是响应式</strong>的呢？</p><ul><li>Vue 为我们提供了一个<code>toRefs的函数</code>，可以将<code>reactive返回的对象中的属性都转成ref</code>；</li><li>那么我们再次进行结构出来的 <code>name 和 age 本身都是 ref的</code>；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061458050.png" alt="image-20211006145816978"></p><p>这种做法相当于已经在<code>state.name和ref.value</code>之间建立了 <code>连接</code>，<code>任何一个修改都会引起另外一个变化</code>；</p><h3 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h3><p>如果我们只希望转换一个<strong>reactive 对象中的属性为 ref</strong>, 那么可以<strong>使用 toRef 的方法</strong>：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061459121.png" alt="image-20211006145906301"></p><h3 id="ref-其他的-API"><a href="#ref-其他的-API" class="headerlink" title="ref 其他的 API"></a>ref 其他的 API</h3><p><strong>unref</strong></p><p>如果我们想要<strong>获取一个 ref 引用中的 value</strong>，那么也可以<strong>通过 unref 方法</strong>：</p><ul><li><code>如果参数是一个 ref</code>，则<code>返回内部值</code>，<code>否则返回参数本身</code>；</li><li>这是 <code>val = isRef(val) ? val.value : val</code> 的语法糖函数；</li></ul><p><strong>isRef</strong></p><ul><li>判断值<code>是否是一个ref对象</code>。</li></ul><p><strong>shallowRef</strong></p><ul><li>创建一个<code>浅层的ref对象</code>；</li></ul><p><strong>triggerRef</strong></p><ul><li><code>手动触发和 shallowRef 相关联的副作用</code>：</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061500984.png" alt="image-20211006150028043"></p><h3 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h3><p>创建一个<strong>自定义的 ref</strong>，并<strong>对其依赖项跟踪和更新触发</strong>进行<strong>显示控制</strong>：</p><p>它需要一个<code>工厂函数</code>，该<code>函数接受 track 和 trigger 函数</code>作为参数</p><p>并且应该返回一个带有 get 和 set 的对象；</p><p><strong>这里我们使用一个的案例：</strong></p><p>对<code>双向绑定的属性进行debounce(节流)</code>的操作；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061501691.png" alt="image-20211006150157885"></p><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><blockquote><p>在前面我们讲解过计算属性 computed：当我们的某些属性是依赖其他状态时，我们可以使用计算属性来处理</p></blockquote><ul><li>在前面的 Options API 中，我们是使用 computed 选项来完成的；</li><li>在 Composition API 中，我们可以在 setup 函数中使用 computed 方法来编写一个计算属性；</li></ul><blockquote><p>如何使用 computed 呢？</p></blockquote><p>方式一：接收一个 getter 函数，并为 getter 函数返回的值，返回一个不变的 ref 对象；</p><p>方式二：接收一个具有 get 和 set 的对象，返回一个可变的（可读写）ref 对象；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061509109.png" alt="image-20211006150956467"></p><h3 id="侦听数据的变化"><a href="#侦听数据的变化" class="headerlink" title="侦听数据的变化"></a>侦听数据的变化</h3><p>在前面的 Options API 中，我们可以通过 watch 选项来侦听 data 或者 props 的数据变化，当数据变化时执行某一些操作。</p><p>在 Composition API 中，我们可以使用 watchEffect 和 watch 来完成响应式数据的侦听；</p><ul><li>watchEffect 用于自动收集响应式数据的依赖；</li><li>watch 需要手动指定侦听的数据源；</li></ul><h4 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h4><p>当侦听到某些响应式数据变化时，我们希望执行某些操作，这个时候可以使用 watchEffect</p><p>我们来看一个案例：</p><ul><li><p>首先，watchEffect 传入的函数会被立即执行一次，并且在执行的过程中会收集依赖；</p></li><li><p>其次，只有收集的依赖发生变化时，watchEffect 传入的函数才会再次执行；</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061510331.png" alt="image-20211006151053559"></p><h4 id="watchEffect-的停止侦听"><a href="#watchEffect-的停止侦听" class="headerlink" title="watchEffect 的停止侦听"></a>watchEffect 的停止侦听</h4><p>如果在发生某些情况下，我们希望停止侦听，这个时候我们可以获取 watchEffect 的返回值函数，调用该函数即可。</p><p>比如在上面的案例中，我们 age 达到 20 的时候就停止侦听：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061511543.png" alt="image-20211006151114671"></p><h4 id="watchEffect-清除副作用"><a href="#watchEffect-清除副作用" class="headerlink" title="watchEffect 清除副作用"></a>watchEffect 清除副作用</h4><p>什么是清除副作用呢？</p><ul><li>比如在开发中我们需要在侦听函数中执行网络请求，但是在网络请求还没有达到的时候，我们停止了侦听器，或者侦听器侦听函数被再次执行了。</li><li>那么上一次的网络请求应该被取消掉，这个时候我们就可以清除上一次的副作用；</li></ul><p>在我们给 watchEffect 传入的函数被回调时，其实可以获取到一个参数：onInvalidate</p><ul><li>当<strong>副作用即将重新执行</strong> 或者 <strong>侦听器被停止</strong> 时会执行该函数传入的回调函数；</li><li>我们可以在传入的回调函数中，执行一些清楚工作；</li></ul><h3 id="setup-中使用-ref"><a href="#setup-中使用-ref" class="headerlink" title="setup 中使用 ref"></a>setup 中使用 ref</h3><p>在讲解 watchEffect 执行时机之前，我们先补充一个知识：在 setup 中如何使用 ref 或者元素或者组件？</p><p>其实非常简单，我们只需要定义一个 ref 对象，绑定到元素或者组件的 ref 属性上即可；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061516859.png" alt="image-20211006151657237"></p><h3 id="watchEffect-的执行时机"><a href="#watchEffect-的执行时机" class="headerlink" title="watchEffect 的执行时机"></a>watchEffect 的执行时机</h3><p>默认情况下，组件的更新会在副作用函数执行之前：</p><p>如果我们希望在副作用函数中获取到元素，是否可行呢？</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061517105.png" alt="image-20211006151729172"></p><p>我们会发现打印结果打印了两次：</p><p>这是因为 setup 函数在执行时就会立即执行传入的副作用函数，这个时候 DOM 并没有挂载，所以打印为 null；</p><p>而当 DOM 挂载时，会给 title 的 ref 对象赋值新的值，副作用函数会再次执行，打印出来对应的元素；</p><h4 id="调整-watchEffect-的执行时机"><a href="#调整-watchEffect-的执行时机" class="headerlink" title="调整 watchEffect 的执行时机"></a>调整 watchEffect 的执行时机</h4><p>如果我们希望在第一次的时候就打印出来对应的元素呢？</p><ul><li>这个时候我们需要改变副作用函数的执行时机；</li><li>它的默认值是 pre，它会在元素 挂载 或者 更新 之前执行；</li><li>所以我们会先打印出来一个空的，当依赖的 title 发生改变时，就会再次执行一次，打印出元素；</li></ul><p>我们可以设置副作用函数的执行时机：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061518929.png" alt="image-20211006151828284"></p><p>flush 选项还接受 sync，这将强制效果始终同步触发。然而，这是低效的，应该很少需要。</p><h3 id="Watch-的使用"><a href="#Watch-的使用" class="headerlink" title="Watch 的使用"></a>Watch 的使用</h3><p>watch 的 API 完全等同于组件 watch 选项的 Property：</p><ul><li>watch 需要侦听特定的数据源，并在回调函数中执行副作用；</li><li>默认情况下它是惰性的，只有当被侦听的源发生变化时才会执行回调；</li></ul><p>与 watchEffect 的比较，watch 允许我们：</p><ul><li>懒执行副作用（第一次不会直接执行）；</li><li>更具体的说明当哪些状态发生变化时，触发侦听器的执行；</li><li>访问侦听状态变化前后的值；</li></ul><h3 id="侦听单个数据源"><a href="#侦听单个数据源" class="headerlink" title="侦听单个数据源"></a>侦听单个数据源</h3><p>watch 侦听函数的数据源有两种类型：</p><ul><li>一个 getter 函数：但是该 getter 函数必须引用可响应式的对象（比如 reactive 或者 ref）；</li><li>直接写入一个可响应式的对象，reactive 或者 ref（比较常用的是 ref）；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061519472.png" alt="image-20211006151956720"></p><h3 id="侦听多个数据源"><a href="#侦听多个数据源" class="headerlink" title="侦听多个数据源"></a>侦听多个数据源</h3><p>侦听器还可以使用数组同时侦听多个源：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061520775.png" alt="image-20211006152018808"></p><h3 id="侦听响应式对象"><a href="#侦听响应式对象" class="headerlink" title="侦听响应式对象"></a>侦听响应式对象</h3><p>如果我们希望侦听一个数组或者对象，那么可以使用一个 getter 函数，并且对可响应对象进行解构：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061520273.png" alt="image-20211006152035615"></p><h3 id="watch-的选项"><a href="#watch-的选项" class="headerlink" title="watch 的选项"></a>watch 的选项</h3><p>如果我们希望侦听一个深层的侦听，那么依然需要设置 deep 为 true：</p><p>也可以传入 imediate 立即执行；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061520755.png" alt="image-20211006152057903"></p><h3 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h3><p>我们前面说过 setup 可以用来替代 data 、 methods 、 computed 、watch 等等这些选项，也可以替代 生命周期钩子。</p><p>那么 setup 中如何使用生命周期函数呢？</p><p>可以使用直接导入的 onX 函数注册生命周期钩子；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061521694.png" alt="image-20211006152128969"></p><h3 id="Provide-函数"><a href="#Provide-函数" class="headerlink" title="Provide 函数"></a>Provide 函数</h3><p>事实上我们之前还学习过 Provide 和 Inject，Composition API 也可以替代之前的 Provide 和 Inject 的选项。</p><blockquote><p>我们可以通过 provide 来提供数据：</p></blockquote><p>可以通过 provide 方法来定义每个 Property；</p><p>provide 可以传入两个参数：</p><ol><li>name：提供的属性名称；</li><li>value：提供的属性值；</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061522575.png" alt="image-20211006152218782"></p><h3 id="Inject-函数"><a href="#Inject-函数" class="headerlink" title="Inject 函数"></a>Inject 函数</h3><p>在 后代组件 中可以通过 inject 来注入需要的属性和对应的值：</p><p>可以通过 inject 来注入需要的内容；</p><p>inject 可以传入两个参数：</p><ol><li>要 inject 的 property 的 name；</li><li>默认值；</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061522613.png" alt="image-20211006152247417"></p><h3 id="数据的响应式"><a href="#数据的响应式" class="headerlink" title="数据的响应式"></a>数据的响应式</h3><p>为了增加 provide 值和 inject 值之间的响应性，我们可以在 provide 值时使用 ref 和 reactive。</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061523035.png" alt="image-20211006152303410"></p><h3 id="修改响应式-Property"><a href="#修改响应式-Property" class="headerlink" title="修改响应式 Property"></a>修改响应式 Property</h3><p>如果我们需要修改可响应的数据，那么最好是在数据提供的位置来修改：</p><p>我们可以将修改方法进行共享，在后代组件中进行调用；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061523964.png" alt="image-20211006152325422"></p><h3 id="useCounter"><a href="#useCounter" class="headerlink" title="useCounter"></a>useCounter</h3><p>我们先来对之前的 counter 逻辑进行抽取：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061523513.png" alt="image-20211006152338919"></p><h3 id="useTitle"><a href="#useTitle" class="headerlink" title="useTitle"></a>useTitle</h3><p>我们编写一个修改 title 的 Hook：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061524526.png" alt="image-20211006152359904"></p><h3 id="useScrollPosition"><a href="#useScrollPosition" class="headerlink" title="useScrollPosition"></a>useScrollPosition</h3><p>我们来完成一个监听界面滚动位置的 Hook：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061524718.png" alt="image-20211006152415998"></p><h3 id="useMousePosition"><a href="#useMousePosition" class="headerlink" title="useMousePosition"></a>useMousePosition</h3><p>我们来完成一个监听鼠标位置的 Hook：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061524023.png" alt="image-20211006152430201"></p><h3 id="认识-h-函数"><a href="#认识-h-函数" class="headerlink" title="认识 h 函数"></a>认识 h 函数</h3><p>Vue 推荐在绝大数情况下<strong>使用模板</strong>来创建你的 HTML，然后一些特殊的场景，你真的需要<strong>JavaScript 的完全编程的</strong></p><p><strong>能力</strong>，这个时候你可以使用 <strong>渲染函数</strong> ，它<strong>比模板更接近编译器</strong>；</p><ul><li>前面我们讲解过<code>VNode和VDOM</code>的改变：</li><li>Vue 在生成真实的 DOM 之前，会将<code>我们的节点转换成VNode</code>，而 VNode 组合在一起形成<code>一颗树结构</code>，就是<code>虚拟DOM（VDOM）</code>；</li><li>事实上，我们之前编写的 template 中的 HTML 最终也是<code>使用</code>**<code>渲染函数</code>**生成<code>对应的VNode</code>；</li><li>那么，如果你想充分的利用 JavaScript 的编程能力，我们可以自己来<code>编写 createVNode 函数</code>，生成<code>对应的VNode</code>；</li></ul><p>那么我们应该怎么来做呢？<strong>使用 h()函数：</strong></p><ul><li><code>h() 函数</code>是一个用于<code>创建 vnode 的一个函数</code>；</li><li>其实更准备的命名是 <code>createVNode() 函数</code>，但是为了简便在 Vue 将之<code>简化为 h() 函数</code></li></ul><h4 id="h-函数-如何使用呢？"><a href="#h-函数-如何使用呢？" class="headerlink" title="h()函数 如何使用呢？"></a>h()函数 如何使用呢？</h4><p><strong>h()函数 如何使用呢？它接受三个参数：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061527717.png" alt="image-20211006152720195"></p><p><strong>注意事项：</strong></p><ul><li>如果<code>没有props</code>，那么通常可以<code>将children作为第二个参数传入</code>；</li><li>如果会产生歧义，可以<code>将null作为第二个参数传入</code>，将<code>children作为第三个参数传入</code>；</li></ul><h4 id="h-函数的基本使用"><a href="#h-函数的基本使用" class="headerlink" title="h 函数的基本使用"></a>h 函数的基本使用</h4><ul><li><code>render函数选项</code>中；</li><li><code>setup函数选项</code>中（setup 本身需要是一个函数类型，函数再返回 h 函数创建的 VNode）；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061528150.png" alt="image-20211006152845988"></p><h4 id="h-函数计数器案例"><a href="#h-函数计数器案例" class="headerlink" title="h 函数计数器案例"></a>h 函数计数器案例</h4><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061529480.png" alt="image-20211006152918729"></p><h4 id="函数组件和插槽的使用"><a href="#函数组件和插槽的使用" class="headerlink" title="函数组件和插槽的使用"></a>函数组件和插槽的使用</h4><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061529760.png" alt="image-20211006152935011"></p><h3 id="jsx-的-babel-配置"><a href="#jsx-的-babel-配置" class="headerlink" title="jsx 的 babel 配置"></a>jsx 的 babel 配置</h3><p>如果我们希望<strong>在项目中使用 jsx</strong>，那么我们<strong>需要添加对 jsx 的支持</strong>：</p><ul><li>jsx 我们通常会<code>通过Babel来进行转换</code>（React 编写的 jsx 就是通过 babel 转换的）；</li><li>对于 Vue 来说，我们只需要在<code>Babel中配置对应的插件</code>即可；</li></ul><p>安装<strong>Babel 支持 Vue 的 jsx 插件</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @vue/babel-plugin-jsx -D</span><br></pre></td></tr></table></figure><p>在<strong>babel.config.js 配置文件</strong>中配置插件</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061530220.png" alt="image-20211006153039447"></p><h3 id="jsx-计数器案例"><a href="#jsx-计数器案例" class="headerlink" title="jsx 计数器案例"></a>jsx 计数器案例</h3><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061530161.png" alt="image-20211006153052565"></p><h3 id="jsx-组件的使用"><a href="#jsx-组件的使用" class="headerlink" title="jsx 组件的使用"></a>jsx 组件的使用</h3><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061531658.png" alt="image-20211006153106062"></p><h3 id="认识自定义指令"><a href="#认识自定义指令" class="headerlink" title="认识自定义指令"></a>认识自定义指令</h3><p>在 Vue 的模板语法中我们学习过各种各样的指令：v-show、v-for、v-model 等等，除了使用这些指令之外，<strong>Vue 也允许我们来自定义自己的指令。</strong></p><ul><li>注意：在 Vue 中，<code>代码的复用和抽象主要还是通过组件</code>；</li><li>通常在某些情况下，你需要<code>对DOM元素进行底层操作</code>，这个时候就会用到<code>自定义指令</code>；</li></ul><p><strong>自定义指令分为两种：</strong></p><ul><li><code>自定义局部指令</code>：组件中通过 <code>directives 选项</code>，只能在当前组件中使用</li><li><code>自定义全局指令</code>：app 的 <code>directive 方法</code>，可以在任意组件中被使用；</li></ul><p><strong>比如我们来做一个非常简单的案例：当某个元素挂载完成后可以自定获取焦点</strong></p><ul><li>实现方式一：如果我们使用<code>默认的实现方式</code>；</li><li>实现方式二：自定义一个 <code>v-focus 的局部指令</code>；</li><li>实现方式三：自定义一个 <code>v-focus 的全局指令</code>；</li></ul><h4 id="实现方式一：聚焦的默认实现"><a href="#实现方式一：聚焦的默认实现" class="headerlink" title="实现方式一：聚焦的默认实现"></a>实现方式一：聚焦的默认实现</h4><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061533898.png" alt="image-20211006153319021"></p><h4 id="实现方式二：局部自定义指令"><a href="#实现方式二：局部自定义指令" class="headerlink" title="实现方式二：局部自定义指令"></a>实现方式二：局部自定义指令</h4><p>实现方式二：自定义一个 <code>v-focus 的局部指令</code></p><ul><li>这个自定义指令实现非常简单，我们只需要在<code>组件选项</code>中使用 <code>directives</code> 即可；</li><li>它是一个对象，在对象中编写我们<code>自定义指令的名称</code>（注意：这里不需要加 v-）；</li><li>自定义指令有一个生命周期，是<code>在组件挂载后调用的 mounted</code>，我们可以在其中完成操作；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061534341.png" alt="image-20211006153419612"></p><h4 id="实现方式三：自定义全局指令"><a href="#实现方式三：自定义全局指令" class="headerlink" title="实现方式三：自定义全局指令"></a>实现方式三：自定义全局指令</h4><p>自定义一个<strong>全局的 v-focus 指令</strong>可以让我们在任何地方直接使用</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061534850.png" alt="image-20211006153447249"></p><h4 id="指令的生命周期"><a href="#指令的生命周期" class="headerlink" title="指令的生命周期"></a>指令的生命周期</h4><p><strong>一个指令定义的对象，Vue 提供了如下的几个钩子函数：</strong></p><p><code>created</code>：在绑定元素的 attribute 或事件监听器被应用之前调用；</p><p><code>beforeMount</code>：当指令第一次绑定到元素并且在挂载父组件之前调用；</p><p><code>mounted</code>：在绑定元素的父组件被挂载后调用；</p><p><code>beforeUpdate</code>：在更新包含组件的 VNode 之前调用；</p><p><code>updated</code>：在包含组件的 VNode <strong>及其子组件的 VNode</strong> 更新后调用；</p><p><code>beforeUnmount</code>：在卸载绑定元素的父组件之前调用；</p><p><code>unmounted</code>：当指令与元素解除绑定且父组件已卸载时，只调用一次；</p><h4 id="指令的参数和修饰符"><a href="#指令的参数和修饰符" class="headerlink" title="指令的参数和修饰符"></a>指令的参数和修饰符</h4><p>如果我们指令需要<strong>接受一些参数或者修饰符</strong>应该如何操作呢？</p><ul><li>info 是参数的名称；</li><li>aaa-bbb 是修饰符的名称；</li><li>后面是传入的具体的值；</li></ul><p>在我们的生命周期中，我们可以<strong>通过 bindings 获取到对应的内容</strong>：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061536286.png" alt="image-20211006153627447"></p><h4 id="自定义指令练习"><a href="#自定义指令练习" class="headerlink" title="自定义指令练习"></a>自定义指令练习</h4><p><strong>自定义指令案例：时间戳的显示需求：</strong></p><ul><li>在开发中，大多数情况下从<code>服务器</code>获取到的都是<code>时间戳</code>；</li><li>我们需要<code>将时间戳转换成具体格式化的时间</code>来展示；</li><li>在 Vue2 中我们可以<code>通过过滤器</code>来完成；</li><li>在 Vue3 中我们可以通过 <code>计算属性（computed）</code> 或者 <code>自定义一个方法（methods）</code> 来完成；</li><li>其实我们还可以通过一个<code>自定义的指令</code>来完成；</li></ul><p>我们来实现一个可以自动对<strong>时间格式化的指令 v-format-time</strong>：</p><p>这里我封装了一个函数，在首页中我们只需要<code>调用这个函数</code>并且<code>传入app</code>即可；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061538727.png" alt="image-20211006153859018"></p><h3 id="认识-Teleport"><a href="#认识-Teleport" class="headerlink" title="认识 Teleport"></a>认识 Teleport</h3><p>在组件化开发中，我们<strong>封装一个组件 A</strong>，在<strong>另外一个组件 B 中使用</strong>：</p><ul><li>那么<code>组件A中template的元素</code>，会<code>被挂载到组件B中template</code>的某个位置；</li><li>最终我们的应用程序会形成<strong>一颗 DOM 树结构</strong>；</li></ul><p>但是某些情况下，我们希望<strong>组件不是挂载在这个组件树上</strong>的，可能是<strong>移动到 Vue app 之外的其他位置</strong>：</p><ul><li>比如<code>移动到body元素</code>上，或者我们<code>有其他的div#app之外的元素</code>上；</li><li>这个时候我们就可以<code>通过teleport来完成</code>；</li></ul><p><strong>Teleport 是什么呢？</strong></p><p>它是一个<code>Vue提供的内置组件</code>，类似于 react 的 Portals；</p><p>teleport 翻译过来是心灵传输、远距离运输的意思；</p><p>它有两个属性：</p><ol><li><code>to</code>：指定将其中的内容移动到的目标元素，可以使用选择器；</li><li><code>disabled</code>：是否禁用 teleport 的功能；</li></ol><p><strong>我们来看下面代码的效果：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061541143.png" alt="image-20211006154116044"></p><h4 id="和组件结合使用"><a href="#和组件结合使用" class="headerlink" title="和组件结合使用"></a>和组件结合使用</h4><p>当然，<strong>teleport 也可以和组件结合一起来使用：</strong></p><p>我们可以在 teleport 中使用组件，并且也可以给他传入一些数据；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061541745.png" alt="image-20211006154137836"></p><h4 id="多个-teleport"><a href="#多个-teleport" class="headerlink" title="多个 teleport"></a>多个 teleport</h4><p>如果我们将<strong>多个 teleport 应用</strong>到<strong>同一个目标上（to 的值相同）</strong>，那么这些<strong>目标会进行合并</strong>：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061542491.png" alt="image-20211006154219753"></p><p>实现效果如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061542797.png" alt="image-20211006154231137"></p><h3 id="认识-Vue-插件"><a href="#认识-Vue-插件" class="headerlink" title="认识 Vue 插件"></a>认识 Vue 插件</h3><p>通常我们<strong>向 Vue 全局添加一些功能</strong>时，会采用<strong>插件的模式，它有两种编写方式</strong>：</p><p><code>对象类型</code>：一个<code>对象</code>，但是必须包含一个<code> install 的函数</code>，该<code>函数会在安装插件时</code>执行；</p><p><code>函数类型</code>：一个<code>function</code>，这个函数会在<code>安装插件时自动执行</code>；</p><p>插件可以<strong>完成的功能没有限制</strong>，比如下面的几种都是可以的：</p><ul><li><code>添加全局方法或者 property</code>，通过把它们添加到 <code>config.globalProperties</code> 上实现；</li><li><code>添加全局资源</code>：<code>指令/过滤器/过渡</code>等；</li><li>通过<code>全局 mixin</code> 来添加<code>一些组件选项</code>；</li><li><code>一个库</code>，<code>提供自己的 API</code>，同时<code>提供上面提到的一个或多个功能</code>；</li></ul><p><strong>插件的编写方式</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061544274.png" alt="image-20211006154413346"></p>]]></content>
    
    
    <summary type="html">Composition API学习</summary>
    
    
    
    
    <category term="Vue3" scheme="https://qwq3.top/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue3动画</title>
    <link href="https://qwq3.top/posts/d64d.html"/>
    <id>https://qwq3.top/posts/d64d.html</id>
    <published>2021-10-05T14:11:32.000Z</published>
    <updated>2021-11-18T04:02:22.746Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><ul><li>认识动画</li><li>认识 animate.css</li><li>认识 gsap 库</li><li>JavaScript 钩子</li><li>gsap 库的使用</li><li>认识列表的过渡</li></ul></blockquote><h3 id="认识动画"><a href="#认识动画" class="headerlink" title="认识动画"></a>认识动画</h3><blockquote><p>在开发中，我们想要给一个组件的<strong>显示和消失添加某种过渡动画</strong>，可以很好的<strong>增加用户体验</strong>：</p></blockquote><p>React 框架本身并<code>没有提供任何动画相关的API</code>，所以在 React 中使用过渡动画我们需要使用一个<code>第三方库react-transition-group</code></p><p>Vue 中为我们提供<code>一些内置组件和对应的API</code>来完成动画，利用它们我们可以<code>方便的实现过渡动画效果</code>；</p><p>如果我们希望给<code>单元素或者组件实现过渡动画</code>，可以<code>使用 transition 内置组件</code>来完成动画；</p><h4 id="Vue-的-transition-动画"><a href="#Vue-的-transition-动画" class="headerlink" title="Vue 的 transition 动画"></a>Vue 的 transition 动画</h4><p>Vue <strong>提供了 transition 的封装组件</strong>，在下列情形中，可以给任何元素和组件添加进入/离开过渡：</p><p><code>条件渲染</code> (使用 v-if)条件展示 (使用 v-show)</p><p><code>动态组件</code></p><p><code>组件根节点</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061404897.png" alt="image-20211006140429364"></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061404838.png" alt="image-20211006140436248"></p><h4 id="Transition-组件的原理"><a href="#Transition-组件的原理" class="headerlink" title="Transition 组件的原理"></a>Transition 组件的原理</h4><p><strong>我们会发现，Vue 自动给 h2 元素添加了动画，这是什么原因呢</strong></p><p><strong>当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理：</strong></p><ol><li>自动嗅探<code>目标元素是否应用了CSS过渡或者动画</code>，如果有，那么<code>在恰当的时机添加/删除 CSS类名</code>；</li><li>如果 transition 组件提供了<code>JavaScript钩子函数</code>，这些钩子函数将在恰当的时机被调用</li><li>如果<code>没有找到JavaScript钩子并且也没有检测到CSS过渡/动画，DOM插入、删除操作将会立即执行</code></li></ol><p><strong>那么都会添加或者删除哪些 class 呢</strong></p><h4 id="过渡动画-class"><a href="#过渡动画-class" class="headerlink" title="过渡动画 class"></a>过渡动画 class</h4><blockquote><p><strong>我们会发现很多个 class，事实上 Vue 就是帮助我们在这些 class 之间来回切换完成的动画：</strong></p></blockquote><p><code>v-enter-from：</code>定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</p><p><code>v-enter-active：</code>定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</p><p><code>v-enter-to：</code>定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter-from 被移除)，在过渡/</p><p>动画完成之后移除。</p><p><code>v-leave-from：</code>定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</p><p><code>v-leave-active：</code>定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</p><p><code>v-leave-to：</code>离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave-from 被删除)，在过渡/</p><p>动画完成之后移除。</p><h4 id="class-添加的时机和命名规则"><a href="#class-添加的时机和命名规则" class="headerlink" title="class 添加的时机和命名规则"></a>class 添加的时机和命名规则</h4><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061407891.png" alt="image-20211006140735574"></p><p><strong>class 的 name 命名规则如下</strong></p><p>如果我们使用的是一个没有 name 的 transition，那么所有的 class 是以 v- 作为默认前缀；</p><p>如果我们添加了一个 name 属性，比如 &lt;transtion name=”anzhiyu”&gt;，那么所有的 class 会以 anzhiyu- 开头；</p><h4 id="过渡-css-动画"><a href="#过渡-css-动画" class="headerlink" title="过渡 css 动画"></a>过渡 css 动画</h4><p>前面我们是<strong>通过 transition 来实现的动画效果</strong>，另外我们也<strong>可以通过 animation 来实现</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061408800.png" alt="image-20211006140834950"></p><h4 id="同时设置过渡和动画"><a href="#同时设置过渡和动画" class="headerlink" title="同时设置过渡和动画"></a>同时设置过渡和动画</h4><p>Vue 为了<strong>知道过渡的完成</strong>，内部是<strong>在监听 transitionend 或 animationend</strong>，到底使用哪一个取决于元素应用的</p><p>CSS 规则：如果我们<code>只是使用了其中的一个</code>，那么<code>Vue能自动识别类型并设置监听</code>；</p><p><strong>但是如果我们同时使用了过渡和动画呢？</strong></p><p>并且在这个情况下可能<code>某一个动画执行结束时</code>，<code>另外一个动画还没有结束</code>；</p><p>在这种情况下，我们可以设置 type 属性为 animation 或者 transition 来明确的告知 Vue 监听的类型；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061410224.png" alt="image-20211006141010377"></p><h4 id="显示的指定动画时间"><a href="#显示的指定动画时间" class="headerlink" title="显示的指定动画时间"></a>显示的指定动画时间</h4><p>我们也可以显示的来<strong>指定过渡的时间</strong>，通过 <strong>duration 属性</strong>。</p><p><strong>duration 可以设置两种类型的值：</strong></p><p><code>number</code>类型：同时设置进入和离开的过渡时间；</p><p><code>object</code>类型：分别设置进入和离开的过渡时间；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061410361.png" alt="image-20211006141048311"></p><h4 id="过渡的模式-mode"><a href="#过渡的模式-mode" class="headerlink" title="过渡的模式 mode"></a>过渡的模式 mode</h4><p><strong>我们来看当前的动画在两个元素之间切换的时候存在的问题：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061411094.png" alt="image-20211006141107407"></p><p>我们会发现 Hello World 和 你好啊，李银河是<strong>同时存在</strong>的：</p><ul><li>这是因为默认情况下<code>进入和离开</code>动画是同时发生的；</li><li>如果确实我们希望达到这个的效果，那么是没有问题；</li></ul><p>但是如果我们<strong>不希望同时执行进入和离开动画</strong>，那么我们需要设置 transition 的<strong>过渡模式</strong>：</p><ul><li>in-out: 新元素先进行过渡，完成之后当前元素过渡离开；</li><li>out-in: 当前元素先进行过渡，完成之后新元素过渡进入；</li></ul><h4 id="动态组件的切换"><a href="#动态组件的切换" class="headerlink" title="动态组件的切换"></a>动态组件的切换</h4><p>上面的示例同样适用于我们的<strong>动态组件</strong>：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061412680.png" alt="image-20211006141212952"></p><h4 id="appear-初次渲染"><a href="#appear-初次渲染" class="headerlink" title="appear 初次渲染"></a>appear 初次渲染</h4><p>默认情况下，<strong>首次渲染的时候是没有动画的</strong>，如果我们<strong>希望给他添加上去动画，那么就可以增加另外一个属性</strong></p><p><strong>appear</strong>：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061412342.png" alt="image-20211006141249665"></p><h4 id="自定义过渡-class"><a href="#自定义过渡-class" class="headerlink" title="自定义过渡 class"></a>自定义过渡 class</h4><p><strong>我们可以通过以下 attribute 来自定义过渡类名：</strong></p><ul><li>enter-from-class</li><li>enter-active-class</li><li>enter-to-class</li><li>leave-from-class</li><li>leave-active-class</li><li>leave-to-class</li></ul><p>他们的优先级高于普通的类名，这对于 <strong>Vue 的过渡系统和其他第三方 CSS 动画库</strong>，如 <a href="https://animate.style/">Animate.css</a>. 结合使用十分有用</p><h3 id="认识-animate-css"><a href="#认识-animate-css" class="headerlink" title="认识 animate.css"></a>认识 animate.css</h3><p>如果我们手动一个个来编写这些动画，那么效率是比较低的，所以在开发中我们可能会引用一些<strong>第三方库的动画库，比如 animate.css</strong>。</p><blockquote><p><strong>什么是 animate.css 呢？</strong></p></blockquote><p><strong>Animate.css</strong> is a library of ready-to-use, cross-browser animations for use in your web projects. Great for emphasis, home pages, sliders, and attention-guiding hints.</p><p><strong>Animate.css</strong>是一个已经<code>准备好的</code>、<code>跨平台的动画</code>库为我们的 web 项目，对于强调、主页、滑动、注意力引导非常有用；</p><blockquote><p><strong>如何使用 Animate 库呢？</strong></p></blockquote><p>第一步：需要<code>安装animate.css</code>库；</p><p>第二步：导入<code>animate.css库</code>的样式；</p><p>第三步：使用<code>animation动画或者animate提供的类</code>；</p><h4 id="animate-css-库的使用"><a href="#animate-css-库的使用" class="headerlink" title="animate.css 库的使用"></a>animate.css 库的使用</h4><p><strong>安装 animate.css：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install animate.css</span><br></pre></td></tr></table></figure><p><strong>在 main.js 中导入 animate.css：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;animate.css&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>接下来在使用的时候我们有两种用法：</strong></p><p>用法一：直接使用<code>animate库中定义的 keyframes 动画</code>；</p><p>用法二：直接使用<code>animate库提供给我们的类</code>；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061417186.png" alt="image-20211006141756412"></p><h3 id="认识-gsap-库"><a href="#认识-gsap-库" class="headerlink" title="认识 gsap 库"></a>认识 gsap 库</h3><p>某些情况下我们希望通过<strong>JavaScript 来实现一些动画的效果</strong>，这个时候我们可以选择使用<strong>gsap 库</strong>来完成。</p><blockquote><p><strong>什么是 gsap 呢？</strong></p></blockquote><p>GSAP 是 The GreenSock Animation Platform（GreenSock 动画平台）的缩写；</p><p>它可以通过<code>JavaScript为CSS属性、SVG、Canvas</code>等设置动画，并且是浏览器兼容的；</p><p><strong>这个库应该如何使用呢？</strong></p><p>第一步：需要<code>安装gsap</code>库；</p><p>第二步：导入<code>gsap库</code>；</p><p>第三步：使用<code>对应的api</code>即可；</p><p><strong>我们可以先安装一下 gsap 库：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gsap</span><br></pre></td></tr></table></figure><h3 id="JavaScript-钩子"><a href="#JavaScript-钩子" class="headerlink" title="JavaScript 钩子"></a>JavaScript 钩子</h3><p>在使用动画之前，我们先来看一下<strong>transition 组件给我们提供的 JavaScript 钩子</strong>，这些钩子可以帮助我们监听动画执行到什么阶段了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061419057.png" alt="image-20211006141928328"></p><p>当我们使用 JavaScript 来执行过渡动画时，需要<code>进行 done 回调</code>，否则它们将会被同步调用，过渡会立即完成</p><p>添加 <strong>:css=”false”<strong>，也会让 Vue 会</strong>跳过 CSS 的检测</strong>，除了性能略高之外，这可以避免过渡过程中 CSS 规则的影响。</p><h3 id="gsap-库的使用"><a href="#gsap-库的使用" class="headerlink" title="gsap 库的使用"></a>gsap 库的使用</h3><p><strong>那么接下来我们就可以结合 gsap 库来完成动画效果：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061427980.png" alt="image-20211006142724078"></p><h4 id="gsap-实现数字变化"><a href="#gsap-实现数字变化" class="headerlink" title="gsap 实现数字变化"></a>gsap 实现数字变化</h4><p>在一些项目中，我们会见到<strong>数字快速变化的动画效果</strong>，这个<strong>动画可以很容易通过 gsap 来实现</strong>：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061428471.png" alt="image-20211006142806810"></p><h3 id="认识列表的过渡"><a href="#认识列表的过渡" class="headerlink" title="认识列表的过渡"></a>认识列表的过渡</h3><blockquote><p>目前为止，过渡动画我们只要是<strong>针对单个元素或者组件</strong>的：</p></blockquote><p>要么是<code>单个节点</code>；</p><p>要么是<code>同一时间渲染多个节点中的一个</code>；</p><blockquote><p>那么如果希望渲染的是<strong>一个列表</strong>，并且<strong>该列表中添加删除数据也希望有动画执行</strong>呢？</p></blockquote><p>这个时候我们要<code>使用 &lt;transition-group&gt; 组件</code>来完成；</p><blockquote><p><strong>使用&lt;transition-group&gt; 有如下的特点：</strong></p></blockquote><p>默认情况下，它<code>不会渲染一个元素的包裹器</code>，但是你可以<code>指定一个元素并以 tag attribute 进行渲染</code>；</p><p><code>过渡模式不可用</code>，因为我们不再相互切换特有的元素；</p><p>内部元素总是<code>需要提供唯一的 key attribute 值</code>；</p><p><code>CSS 过渡的类将会应用在内部的元素</code>中，而<code>不是这个组/容器本身</code>；</p><h4 id="列表过渡的移动动画"><a href="#列表过渡的移动动画" class="headerlink" title="列表过渡的移动动画"></a><strong>列表过渡的移动动画</strong></h4><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061431391.png" alt="image-20211006143108231"></p><p>在案例中<strong>虽然新增的或者删除的节点是有动画</strong>的，但是<strong>对于哪些其他需要移动的节点是没有动画</strong>的：</p><p>我们可以通过使用一个<code>新增的 v-move 的class</code>来完成动画；</p><p>它会在<code>元素改变位置的过程</code>中应用；</p><p>像之前的名字一样，我们可以<code>通过name来自定义前缀</code>；</p><h4 id="列表的交错过渡案例"><a href="#列表的交错过渡案例" class="headerlink" title="列表的交错过渡案例"></a>列表的交错过渡案例</h4><p><strong>我们来通过 gsap 的延迟 delay 属性，做一个交替消失的动画：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061431172.png" alt="image-20211006143128377"></p>]]></content>
    
    
    <summary type="html">Vue3动画的使用指南</summary>
    
    
    
    
    <category term="Vue3" scheme="https://qwq3.top/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue3组件化开发</title>
    <link href="https://qwq3.top/posts/bee4.html"/>
    <id>https://qwq3.top/posts/bee4.html</id>
    <published>2021-10-02T17:14:32.000Z</published>
    <updated>2021-11-18T04:02:22.746Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><ul><li>认识组件的嵌套</li><li>组件的拆分</li><li>组件的通信</li><li>父子组件之间通信的方式</li><li>父组件传递给子组件</li><li>子组件传递给父组件</li><li>自定义事件的流程</li><li>非父子组件的通信</li><li>认识插槽 Slot</li><li>切换组件案例</li><li>动态组件的传值</li><li>认识 keep-alive</li><li>缓存组件的生命周期</li><li>Webpack 的代码分包</li><li>Vue 中实现异步组件</li><li>$refs 的使用</li><li>$parent和$root</li><li>认识生命周期</li><li>组件的 v-model</li><li>认识 Mixin</li></ul></blockquote><h3 id="认识组件的嵌套"><a href="#认识组件的嵌套" class="headerlink" title="认识组件的嵌套"></a>认识组件的嵌套</h3><p>前面我们是将所有的逻辑放到一个 App.vue 中：</p><ul><li>如果我们一个应用程序将<code>所有的逻辑都放在一个组件</code>中，那么这个组件就会变成<code>非常的臃肿和难以维护</code>；</li><li>所以组件化的核心思想应该是<code>对组件进行拆分</code>，拆分成<code>一个个小的组件</code>；</li><li>再<code>将这些组件组合嵌套在一起</code>，最终形成<code>我们的应用程序</code>；</li></ul><p>我们来分析一下下面代码的嵌套逻辑，假如我们将所有的代码逻辑都放到一个 App.vue 组件中：</p><ul><li>我们会发现，将所有的代码逻辑全部放到一个组件中，代码是非常的臃肿和难以维护的。</li><li>并且在真实开发中，我们会有更多的内容和代码逻辑，对于扩展性和可维护性来说都是非常差的。</li><li>所以，在真实的开发中，我们会对组件进行拆分，拆分成一个个功能的小组件。</li></ul><h3 id="组件的拆分"><a href="#组件的拆分" class="headerlink" title="组件的拆分"></a>组件的拆分</h3><p>我们可以按照如下的方式进行拆分：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061005395.png" alt="image-20211006100554232"></p><p>按照如上的拆分方式后，我们开发对应的逻辑只需要去对应的组件编写就可。</p><h3 id="组件的通信"><a href="#组件的通信" class="headerlink" title="组件的通信"></a>组件的通信</h3><p>上面的嵌套逻辑如下，它们存在如下关系：</p><ul><li>App 组件是 Header、Main、Footer 组件的<code>父组件</code>；</li><li>Main 组件是 Banner 、ProductList 组件的<code>父组件</code>；</li></ul><p>在开发过程中，我们会经常遇到需要<strong>组件之间相互进行通信</strong>：</p><ul><li>比如<code>App可能使用了多个Header</code>，每个地方的<code>Header展示的内容不同</code>，那么我们就需要使用者<code>传递给Header一些数据</code>，让其进行展示；</li><li>又比如我们在 Main 中一次性<code>请求了Banner数据和ProductList数据</code>，那么就需要传递给它们来进行展示；</li><li>也可能是<code>子组件中发生了事件</code>，需要由<code>父组件来完成某些操作</code>，那就需要<code>子组件向父组件传递事件</code>；</li></ul><p>总之，在一个 Vue 项目中，组件之间的通信是非常重要的环节，所以接下来我们就具体学习一下组件之间是如何相</p><p>互之间传递数据的；</p><h3 id="父子组件之间通信的方式"><a href="#父子组件之间通信的方式" class="headerlink" title="父子组件之间通信的方式"></a>父子组件之间通信的方式</h3><p>父子组件之间如何进行通信呢？</p><p>父组件传递给子组件：<strong>通过 props 属性</strong>；</p><p>子组件传递给父组件：<strong>通过$emit 触发事件</strong>；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061009166.png" alt="image-20211006100914260"></p><h3 id="父组件传递给子组件"><a href="#父组件传递给子组件" class="headerlink" title="父组件传递给子组件"></a>父组件传递给子组件</h3><blockquote><p>在开发中很常见的就是<strong>父子组件之间通信</strong>，比如父组件有一些数据，需要子组件来进行展示：</p></blockquote><p>这个时候我们可以通过 props 来完成组件之间的通信；</p><blockquote><p><strong>什么是 Props 呢？</strong></p></blockquote><p>Props 是你可以在组件上注册一些自定义的 attribute；</p><p>父组件给这些 attribute 赋值，子组件通过 attribute 的名称获取到对应的值；</p><blockquote><p><strong>Props 有两种常见的用法：</strong></p></blockquote><p><code>方式一：字符串数组</code>，数组中的字符串就是 attribute 的名称；</p><p><code>方式二：对象类型</code>，对象类型我们可以在指定 attribute 名称的同时，指定它需要传递的类型、是否是必须的、</p><p>默认值等等；</p><h4 id="Props-的数组用法"><a href="#Props-的数组用法" class="headerlink" title="Props 的数组用法"></a>Props 的数组用法</h4><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061011593.png" alt="image-20211006101106104"></p><h4 id="Props-的对象用法"><a href="#Props-的对象用法" class="headerlink" title="Props 的对象用法"></a>Props 的对象用法</h4><p>数组用法中我们<strong>只能说明传入的 attribute 的名称</strong>，并<strong>不能对其进行任何形式的限制</strong>，接下来我们来看一下<strong>对象的</strong></p><p><strong>写法</strong>是如何让我们的 props 变得更加完善的。</p><p><strong>当使用对象语法的时候，我们可以对传入的内容限制更多：</strong></p><ul><li>比如指定传入的 attribute 的类型；</li><li>比如指定传入的 attribute 是否是必传的；</li><li>比如指定没有传入时，attribute 的默认值；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061011545.png" alt="image-20211006101157833"></p><h5 id="细节一：那么-type-的类型都可以是哪些呢？"><a href="#细节一：那么-type-的类型都可以是哪些呢？" class="headerlink" title="细节一：那么 type 的类型都可以是哪些呢？"></a>细节一：那么 type 的类型都可以是哪些呢？</h5><p><strong>那么 type 的类型都可以是哪些呢？</strong></p><ul><li>String</li><li>Number</li><li>Boolean</li><li>Array</li><li>Object</li><li>Date</li><li>Function</li><li>Symbol</li></ul><h5 id="细节二：对象类型的其他写法"><a href="#细节二：对象类型的其他写法" class="headerlink" title="细节二：对象类型的其他写法"></a>细节二：对象类型的其他写法</h5><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061012343.png" alt="image-20211006101253610"></p><h5 id="细节三：Prop-的大小写命名"><a href="#细节三：Prop-的大小写命名" class="headerlink" title="细节三：Prop 的大小写命名"></a>细节三：Prop 的大小写命名</h5><p><strong>Prop 的大小写命名(camelCase vs kebab-case)</strong></p><ul><li>HTML 中的 <code>attribute 名是大小写不敏感</code>的，所以<code>浏览器会把所有大写字符解释为小写字符</code>；</li><li>这意味着当你<code>使用 DOM 中的模板</code>时，<code>camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名</code>；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061014172.png" alt="image-20211006101455391"></p><h4 id="非-Prop-的-Attribute"><a href="#非-Prop-的-Attribute" class="headerlink" title="非 Prop 的 Attribute"></a>非 Prop 的 Attribute</h4><blockquote><p>什么是非 Prop 的 Attribute 呢？</p></blockquote><p>当我们<code>传递给一个组件某个属性</code>，但是<code>该属性并没有定义对应的props或者emits时</code>，就称之为 <strong>非 PropAttribute</strong>；</p><p>常见的包括<code>class</code>、<code>style</code>、<code>id</code>属性等；</p><blockquote><p>Attribute 继承</p></blockquote><p>当组件有单个根节点时，非 Prop 的 Attribute 将自动添加到根节点的 Attribute 中：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061017486.png" alt="image-20211006101745698"></p><h4 id="禁用-Attribute-继承和多根节点"><a href="#禁用-Attribute-继承和多根节点" class="headerlink" title="禁用 Attribute 继承和多根节点"></a>禁用 Attribute 继承和多根节点</h4><p>如果我们<strong>不希望组件的根元素继承 attribute</strong>，可以在组件中设置 <strong>inheritAttrs: false</strong>：</p><p>禁用 attribute 继承的<code>常见情况</code>是<code>需要将attribute应用于根元素之外的其他元素</code>；</p><p>我们可以通过 <code>$attrs来访问所有的 非props的attribute</code>；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061019623.png" alt="image-20211006101900826"></p><p><strong>多个根节点的 attribute</strong></p><p>多个根节点的 attribute 如果没有显示的绑定，那么会报警告，我们必须手动的指定要绑定到哪一个属性上：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061020657.png" alt="image-20211006102000682"></p><h3 id="子组件传递给父组件"><a href="#子组件传递给父组件" class="headerlink" title="子组件传递给父组件"></a>子组件传递给父组件</h3><blockquote><p><strong>什么情况下子组件需要传递内容到父组件呢？</strong></p></blockquote><p>当<code>子组件有一些事件发生</code>的时候，比如在组件中发生了点击，父组件需要切换内容；</p><p>子组件<code>有一些内容想要传递给父组件</code>的时候；</p><blockquote><p><strong>我们如何完成上面的操作呢？</strong></p></blockquote><p>首先，我们需要在<code>子组件中定义好在某些情况下触发的事件名称</code>；</p><p>其次，在<code>父组件中以v-on的方式传入要监听的事件名称</code>，并且绑定到对应的方法中；</p><p>最后，在子组件中发生某个事件的时候，<code>根据事件名称触发对应的事件</code>；</p><h3 id="自定义事件的流程"><a href="#自定义事件的流程" class="headerlink" title="自定义事件的流程"></a>自定义事件的流程</h3><p>我们封装一个 CounterOperation.vue 的组件：</p><p>内部其实是监听两个按钮的点击，点击之后通过 this.$emit 的方式发出去事件；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061024441.png" alt="image-20211006102441547"></p><h4 id="自定义事件的参数和验证"><a href="#自定义事件的参数和验证" class="headerlink" title="自定义事件的参数和验证"></a>自定义事件的参数和验证</h4><p>自定义事件的时候，我们也可以传递一些参数给父组件：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061025577.png" alt="image-20211006102552878"></p><p>在 vue3 当中，我们可以对传递的参数进行验证：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061026812.png" alt="image-20211006102605124"></p><h3 id="非父子组件的通信"><a href="#非父子组件的通信" class="headerlink" title="非父子组件的通信"></a>非父子组件的通信</h3><p>在开发中，我们构建了组件树之后，除了<strong>父子组件之间的通信</strong>之外，还会有<strong>非父子组件之间</strong>的通信。</p><p><strong>这里我们主要讲两种方式：</strong></p><ul><li><code>Provide/Inject；</code></li><li><code>Mitt全局事件总线；</code></li></ul><h4 id="Provide-和-Inject"><a href="#Provide-和-Inject" class="headerlink" title="Provide 和 Inject"></a>Provide 和 Inject</h4><blockquote><p>Provide/Inject 用于<strong>非父子组件之间共享数据</strong>：</p></blockquote><ul><li>比如有<code>一些深度嵌套的组件</code>，<code>子组件想要获取父组件的部分内容</code>；</li><li>在这种情况下，如果我们仍然<code>将props沿着组件链逐级传递</code>下去，就会非常的麻烦；</li></ul><blockquote><p>对于这种情况下，<strong>我们可以使用 Provide 和 Inject ：</strong></p></blockquote><ul><li>无论层级结构有多深，父组件都可以作为其所有子组件的依赖提供者；</li><li>父组件有一个 provide 选项来提供数据；</li><li>子组件有一个 inject 选项来开始使用这些数据；</li></ul><blockquote><p>实际上，你可以将依赖注入看作是“<strong>long range props”</strong>，除了：</p></blockquote><ul><li>父组件不需要知道哪些子组件使用它 provide 的 property</li><li>子组件不需要知道 inject 的 property 来自哪里</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061029849.png" alt="image-20211006102913896"></p><h5 id="Provide-和-Inject-基本使用"><a href="#Provide-和-Inject-基本使用" class="headerlink" title="Provide 和 Inject 基本使用"></a>Provide 和 Inject 基本使用</h5><p>我们开发一个这样的结构：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061029943.png" alt="image-20211006102947159"></p><h5 id="Provide-和-Inject-函数的写法"><a href="#Provide-和-Inject-函数的写法" class="headerlink" title="Provide 和 Inject 函数的写法"></a>Provide 和 Inject 函数的写法</h5><p>如果 Provide 中提供的一些数据是<strong>来自 data</strong>，那么我们可能会想要<strong>通过 this 来获取</strong>：</p><p><strong>这个时候会报错：</strong></p><p>这里给大家留一个思考题，我们的 this 使用的是哪里的 this？</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061030520.png" alt="image-20211006103026172"></p><h5 id="处理响应式数据"><a href="#处理响应式数据" class="headerlink" title="处理响应式数据"></a>处理响应式数据</h5><p>我们先来验证一个结果：<strong>如果我们修改了 this.names 的内容，那么使用 length 的子组件会不会是响应式的？</strong></p><p>我们会发现对应的子组件中是<strong>没有反应的</strong>：</p><ul><li>这是因为当我们修改了 names 之后，之前在 provide 中引入的 this.names.length 本身并不是响应式的；</li></ul><blockquote><p><strong>那么怎么样可以让我们的数据变成响应式的呢？</strong></p></blockquote><p>非常的简单，我们可以使用<code>响应式的一些API</code>来完成这些功能，比如说<code>computed</code>函数；</p><p>当然，这个 computed 是 vue3 的新特性，在后面我会专门讲解，这里大家可以先直接使用一下；</p><blockquote><p><strong>注意：我们在使用 length 的时候需要获取其中的 value</strong></p></blockquote><p>这是因为<code>computed返回的是一个ref对象</code>，需要取出其中的<code>value来使用</code>；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061032134.png" alt="image-20211006103229325"></p><h4 id="全局事件总线-mitt-库"><a href="#全局事件总线-mitt-库" class="headerlink" title="全局事件总线 mitt 库"></a>全局事件总线 mitt 库</h4><p>Vue3 从实例中移除了 $on、$off 和 $once 方法，所以我们如果希望<strong>继续使用全局事件总线，要通过第三方的库</strong>：</p><ul><li>Vue3 官方有推荐一些库，例如 <a href="https://github.com/developit/mitt">mitt</a> 或 <a href="https://github.com/scottcorgan/tiny-emitter">tiny-emitter</a>；</li><li>这里我们主要讲解一下 mitt 库的使用；</li></ul><p>首先，我们需要先安装这个库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mitt</span><br></pre></td></tr></table></figure><p>其次，我们可以封装一个工具 eventbus.js：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061034533.png" alt="image-20211006103448729"></p><h5 id="使用事件总线工具"><a href="#使用事件总线工具" class="headerlink" title="使用事件总线工具"></a><strong>使用事件总线工具</strong></h5><p><strong>在项目中可以使用它们：</strong></p><ul><li>我们在 Home.vue 中监听事件；</li><li>我们在 App.vue 中触发事件；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061035315.png" alt="image-20211006103520240"></p><h5 id="Mitt-的事件取消"><a href="#Mitt-的事件取消" class="headerlink" title="Mitt 的事件取消"></a>Mitt 的事件取消</h5><p>在某些情况下我们可能希望<strong>取消掉之前注册的函数监听</strong>：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061035992.png" alt="image-20211006103551765"></p><h3 id="认识插槽-Slot"><a href="#认识插槽-Slot" class="headerlink" title="认识插槽 Slot"></a>认识插槽 Slot</h3><p><strong>在开发中，我们会经常封装一个个可复用的组件：</strong></p><ul><li>前面我们会<code>通过props传递</code>给组件一些数据，让组件来进行展示；</li><li>但是为了让这个组件具备<code>更强的通用性</code>，我们<code>不能将组件中的内容限制为固定的div、span</code>等等这些元素；</li><li>比如某种情况下我们使用组件，希望组件显示的是<code>一个按钮</code>，某种情况下我们使用组件希望显示的是<code>一张图片</code>；</li><li>我们应该让使用者可以决定<code>某一块区域到底存放什么内容和元素</code>；</li></ul><p><strong>举个例子：假如我们定制一个通用的导航组件 - NavBar</strong></p><ul><li>这个组件分成三块区域：<code>左边-中间-右边</code>，每块区域的内容是不固定；</li><li>左边区域可能显示一个菜单图标，也可能显示一个返回按钮，可能什么都不显示；</li><li>中间区域可能显示一个搜索框，也可能是一个列表，也可能是一个标题，等等；</li><li>右边可能是一个文字，也可能是一个图标，也可能什么都不显示；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061037213.png" alt="image-20211006103753316"></p><h4 id="如何使用插槽-slot？"><a href="#如何使用插槽-slot？" class="headerlink" title="如何使用插槽 slot？"></a>如何使用插槽 slot？</h4><p><strong>这个时候我们就可以来定义插槽 slot：</strong></p><ul><li>插槽的使用过程其实是<code>抽取共性、预留不同</code>；</li><li>我们会将<code>共同的元素、内容依然在组件内</code>进行封装；</li><li>同时会将<code>不同的元素使用slot作为占位</code>，让外部决定到底显示什么样的元素；</li></ul><p><strong>如何使用 slot 呢？</strong></p><ul><li>Vue 中将<code> &lt;slot&gt; 元素作为承载分发内容</code>的出口；</li><li>在封装组件中，使用<code>特殊的元素&lt;slot&gt;</code>就可以为封装组件开启一个插槽；</li><li>该插槽<code>插入什么内容取决于父组件</code>如何使用；</li></ul><h4 id="插槽的基本使用"><a href="#插槽的基本使用" class="headerlink" title="插槽的基本使用"></a>插槽的基本使用</h4><p>我们一个组件 MySlotCpn.vue：该组件中有一个插槽，我们可以在插槽中放入需要显示的内容</p><p>我们在 App.vue 中使用它们：我们可以插入普通的内容、html 元素、组件元素，都可以是可以的；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061040465.png" alt="image-20211006104015780"></p><h4 id="插槽的默认内容"><a href="#插槽的默认内容" class="headerlink" title="插槽的默认内容"></a>插槽的默认内容</h4><p>有时候我们希望在使用插槽时，如果<strong>没有插入对应的内容，那么我们需要显示一个</strong> <code>默认的内容</code>：</p><p>当然这个默认的内容只会在没有提供插入的内容时，才会显示；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061041480.png" alt="image-20211006104121258"></p><h4 id="多个插槽的效果"><a href="#多个插槽的效果" class="headerlink" title="多个插槽的效果"></a>多个插槽的效果</h4><p>我们先测试一个知识点：如果一个组件中<strong>含有</strong><code>多个插槽</code>，<strong>我们插入多个内容时是什么效果</strong>？</p><p>我们会发现默认情况下每个插槽都会获取到我们插入的内容来显示；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061043818.png" alt="image-20211006104303403"></p><h4 id="具名插槽的使用"><a href="#具名插槽的使用" class="headerlink" title="具名插槽的使用"></a>具名插槽的使用</h4><p>事实上，我们希望达到的效果是插槽对应的显示，这个时候我们就可以使用 <strong>具名插槽：</strong></p><p>具名插槽顾名思义就是给<code>插槽起一个名字</code>，&lt;slot&gt; 元素有一个<code>特殊的 attribute：name；</code></p><p>一个<code>不带 name 的slot，会带有隐含的名字 default</code>；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061044122.png" alt="image-20211006104416427"></p><h4 id="动态插槽名"><a href="#动态插槽名" class="headerlink" title="动态插槽名"></a>动态插槽名</h4><p><strong>什么是动态插槽名呢？</strong></p><p>目前我们使用的插槽名称都是固定的；</p><p>比如 v-slot:left、v-slot:center 等等；</p><p>我们可以通过<code> v-slot:[dynamicSlotName]</code>方式动态绑定一个名称；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061044755.png" alt="image-20211006104447825"></p><h4 id="具名插槽使用的时候缩写"><a href="#具名插槽使用的时候缩写" class="headerlink" title="具名插槽使用的时候缩写"></a>具名插槽使用的时候缩写</h4><p>跟 v-on 和 v-bind 一样，<code>v-slot 也有缩写</code>；</p><p>即把参数之前的<code>所有内容 (v-slot:) 替换为字符 #</code>；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061045095.png" alt="image-20211006104516853"></p><h4 id="渲染作用域"><a href="#渲染作用域" class="headerlink" title="渲染作用域"></a>渲染作用域</h4><blockquote><p><strong>在 Vue 中有渲染作用域的概念：</strong></p></blockquote><p>父级模板里的所有内容都是在父级作用域中编译的；</p><p>子模板里的所有内容都是在子作用域中编译的；</p><blockquote><p>如何理解这句话呢？我们来看一个案例：</p></blockquote><p>在我们的案例中 ChildCpn 自然是可以让问自己作用域中的 title 内容的；</p><p>但是在 App 中，是访问不了 ChildCpn 中的内容的，因为它们是跨作用域的访问；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061046966.png" alt="image-20211006104628008"></p><h4 id="认识作用域插槽"><a href="#认识作用域插槽" class="headerlink" title="认识作用域插槽"></a>认识作用域插槽</h4><p>但是有时候我们希望插槽<strong>可以访问到子组件中的内容</strong>是非常重要的：</p><ul><li>当一个组件被用来渲染一个<code>数组元素</code>时，我们<code>使用插槽</code>，并且<code>希望插槽中没有显示每项的内容</code>；</li><li>这个 Vue 给我们提供了<code>作用域插槽</code>；</li></ul><p><strong>我们来看下面的一个案例：</strong></p><ol><li>在 App.vue 中定义好数据</li><li>传递给 ShowNames 组件中</li><li>ShowNames 组件中遍历 names 数据</li><li>定义插槽的 prop</li><li>通过 v-slot:default 的方式获取到 slot 的 props</li><li>使用 slotProps 中的 item 和 index</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061047225.png" alt="image-20211006104738405"></p><h4 id="独占默认插槽的缩写"><a href="#独占默认插槽的缩写" class="headerlink" title="独占默认插槽的缩写"></a>独占默认插槽的缩写</h4><p>如果我们的插槽是默认插槽 default，那么在使用的时候 v-slot:default=”slotProps”可以简写为 v-slot=”slotProps”：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061048853.png" alt="image-20211006104804206"></p><p>并且如果我们的插槽只有默认插槽时，组件的标签可以被当做插槽的模板来使用，这样，我们就可以将 v-slot 直接用在组件上：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061048541.png" alt="image-20211006104825923"></p><h4 id="默认插槽和具名插槽混合"><a href="#默认插槽和具名插槽混合" class="headerlink" title="默认插槽和具名插槽混合"></a>默认插槽和具名插槽混合</h4><p>但是，如果我们有默认插槽和具名插槽，那么按照完整的 template 来编写。</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061049044.png" alt="image-20211006104930899"></p><p>只要出现多个插槽，请始终为所有的插槽使用完整的基于 &lt;template&gt; 的语法：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061050553.png" alt="image-20211006105001660"></p><h3 id="切换组件案例"><a href="#切换组件案例" class="headerlink" title="切换组件案例"></a>切换组件案例</h3><p><strong>比如我们现在想要实现了一个功能：</strong></p><p>点击一个 tab-bar，切换不同的组件显示；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061050079.png" alt="image-20211006105054126"></p><p>这个案例我们可以通过两种不同的实现思路来实现：</p><p>方式一：通过 v-if 来判断，显示不同的组件；</p><p>方式二：动态组件的方式；</p><h4 id="v-if-显示不同的组件"><a href="#v-if-显示不同的组件" class="headerlink" title="v-if 显示不同的组件"></a>v-if 显示不同的组件</h4><p>我们可以先通过 v-if 来判断显示不同的组件，这个可以使用我们之前讲过的知识来实现：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061051833.png" alt="image-20211006105140908"></p><h4 id="动态组件的实现"><a href="#动态组件的实现" class="headerlink" title="动态组件的实现"></a>动态组件的实现</h4><p><strong>动态组件是使用</strong> <code>component 组件</code>，<strong>通过一个</strong><code>特殊的attribute is</code> <strong>来实现：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061052315.png" alt="image-20211006105242139"></p><p><strong>这个 currentTab 的值需要是什么内容呢？</strong></p><p>可以是通过<code>component函数注册</code>的组件；</p><p>在一个<code>组件对象的components对象中注册的组件</code>；</p><h3 id="动态组件的传值"><a href="#动态组件的传值" class="headerlink" title="动态组件的传值"></a>动态组件的传值</h3><p><strong>如果是动态组件我们可以给它们传值和监听事件吗？</strong></p><p>也是一样的；只是我们需要将属性和监听事件放到 component 上来使用</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061053348.png" alt="image-20211006105342614"></p><h3 id="认识-keep-alive"><a href="#认识-keep-alive" class="headerlink" title="认识 keep-alive"></a>认识 keep-alive</h3><p><strong>我们先对之前的案例中 About 组件进行改造：</strong></p><p>在其中增加了一个按钮，点击可以递增的功能；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061054868.png" alt="image-20211006105419148"></p><p>比如我们将 counter 点到 10，那么在切换到 home 再切换回来 about 时，<strong>状态是否可以保持呢？</strong></p><ul><li>答案是否定的；</li><li>这是因为默认情况下，我们在<code>切换组件后</code>，<code>about组件会被销毁掉</code>，再次回来时<code>会重新创建组件</code>；</li></ul><p>但是，在开发中某些情况我们希望继续保持组件的状态，而不是销毁掉，这个时候我们就可以<strong>使用一个内置组件：keep-alive</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061055656.png" alt="image-20211006105510730"></p><h4 id="keep-alive-属性"><a href="#keep-alive-属性" class="headerlink" title="keep-alive 属性"></a>keep-alive 属性</h4><p><strong>keep-alive 有一些属性：</strong></p><ul><li><code>include </code>- string | RegExp | Array。只有名称匹配的组件会被缓存；</li><li><code>exclude</code> - string | RegExp | Array。任何名称匹配的组件都不会被缓存；</li><li><code>max</code> - number | string。最多可以缓存多少组件实例，一旦达到这个数字，那么缓存组件中最近没有被访问的实例会被销毁；</li></ul><p><strong>include 和 exclude prop 允许组件有条件地缓存：</strong></p><ul><li>二者都可以用<code>逗号分隔字符串、正则表达式或一个数组</code>来表示；</li><li>匹配首先检查组件自身的 <code>name 选项</code>；</li></ul><h3 id="缓存组件的生命周期"><a href="#缓存组件的生命周期" class="headerlink" title="缓存组件的生命周期"></a>缓存组件的生命周期</h3><p>对于缓存的组件来说，再次进入时，我们是<strong>不会执行 created 或者 mounted 等生命周期函数</strong>的：</p><p>但是有时候我们确实希望监听到何时重新进入到了组件，何时离开了组件；</p><p>这个时候我们可以使用 activated 和 deactivated 这两个生命周期钩子函数来监听；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061057488.png" alt="image-20211006105659769"></p><h3 id="Webpack-的代码分包"><a href="#Webpack-的代码分包" class="headerlink" title="Webpack 的代码分包"></a>Webpack 的代码分包</h3><p><strong>默认的打包过程：</strong></p><ul><li>默认情况下，在构建整个组件树的过程中，因为组件和组件之间是<code>通过模块化直接依赖</code>的，那么<code>webpack在打包时就会将组件模块打包到一起</code>（比如一个 app.js 文件中）；</li><li>这个时候随着<code>项目的不断庞大</code>，<code>app.js文件的内容过大</code>，会造成<code>首屏的渲染速度变慢</code>；</li></ul><p><strong>打包时，代码的分包：</strong></p><ul><li>所以，对于一些<code>不需要立即使用的组件</code>，我们可以<code>单独对它们进行拆分</code>，拆分成一些<code>小的代码块chunk.js</code>；</li><li>这些 chunk.js 会在需要时<code>从服务器加载下来</code>，并且<code>运行代码</code>，显示对应的内容；</li><li><strong>那么 webpack 中如何可以对代码进行分包呢？</strong></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061059043.png" alt="image-20211006105904341"></p><h3 id="Vue-中实现异步组件"><a href="#Vue-中实现异步组件" class="headerlink" title="Vue 中实现异步组件"></a>Vue 中实现异步组件</h3><p>如果我们的项目过大了，对于<strong>某些组件</strong>我们希望<strong>通过异步的方式来进行加载</strong>（目的是可以对其进行分包处理），那么 Vue 中给我们提供了一个函数：<strong>defineAsyncComponent</strong>。</p><p><strong>defineAsyncComponent 接受两种类型的参数：</strong></p><p><code>类型一</code>：工厂函数，该工厂函数需要返回一个 Promise 对象；</p><p><code>类型二</code>：接受一个对象类型，对异步函数进行配置；</p><p><strong>工厂函数类型一的写法：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061101125.png" alt="image-20211006110104256"></p><p><strong>异步组件的写法二</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061101142.png" alt="image-20211006110121198"></p><h4 id="异步组件和-Suspense"><a href="#异步组件和-Suspense" class="headerlink" title="异步组件和 Suspense"></a>异步组件和 Suspense</h4><p>注意：<strong>目前（2021-06-08）Suspense 显示的是一个实验性的特性，API 随时可能会修改。</strong></p><p><strong>Suspense 是一个内置的全局组件，该组件有两个插槽：</strong></p><p><code>default</code>：如果 default 可以显示，那么显示 default 的内容；</p><p><code>fallback</code>：如果 default 无法显示，那么会显示 fallback 插槽的内容；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061102696.png" alt="image-20211006110257956"></p><h3 id="refs-的使用"><a href="#refs-的使用" class="headerlink" title="$refs 的使用"></a>$refs 的使用</h3><p>某些情况下，我们在组件中想要<strong>直接获取到元素对象或者子组件实例</strong>：</p><ul><li>在 Vue 开发中我们是<code>不推荐进行DOM操作</code>的；</li><li>这个时候，我们可以<code>给元素或者组件绑定一个ref的attribute属性</code>；</li></ul><p><strong>组件实例有一个$refs 属性：</strong></p><p>它是一个对象 Object，持有<code>注册过 ref attribute 的所有 DOM 元素和组件实例</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061104950.png" alt="image-20211006110448187"></p><h3 id="parent和-root"><a href="#parent和-root" class="headerlink" title="$parent和$root"></a>$parent和$root</h3><p><strong>我们可以通过$parent 来访问父元素。</strong></p><p>HelloWorld.vue 的实现：</p><p>这里我们也可以通过$root 来实现，因为 App 是我们的根组件；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061105547.png" alt="image-20211006110519565"></p><p>注意：在 Vue3 中已经<strong>移除了$children 的属性</strong>，所以不可以使用了。</p><h3 id="认识生命周期"><a href="#认识生命周期" class="headerlink" title="认识生命周期"></a>认识生命周期</h3><p><strong>什么是生命周期呢？</strong></p><ul><li>每个组件都可能会经历从<code>创建</code>、<code>挂载</code>、<code>更新</code>、<code>卸载</code>等一系列的过程；</li><li>在这个过程中的<code>某一个阶段</code>，用于可能会想要<code>添加一些属于自己的代码逻辑</code>（比如组件创建完后就请求一些服务器数据）；</li><li>但是我们<code>如何可以知道目前组件正在哪一个过程</code>呢？Vue 给我们提供了组件的<code>生命周期函数</code>；</li></ul><p><strong>生命周期函数：</strong></p><ul><li>生命周期函数是<code>一些钩子函数</code>，在<code>某个时间会被Vue源码内部进行回调</code>；</li><li>通过对生命周期函数的回调，我们可以<code>知道目前组件正在经历什么阶段</code>；</li><li>那么我们就可以在<code>该生命周期中编写属于自己的逻辑代码</code>了；</li></ul><h4 id="生命周期的流程"><a href="#生命周期的流程" class="headerlink" title="生命周期的流程"></a>生命周期的流程</h4><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061107183.png" alt="image-20211006110753382"></p><h3 id="组件的-v-model"><a href="#组件的-v-model" class="headerlink" title="组件的 v-model"></a>组件的 v-model</h3><p><strong>前面我们在</strong><code>input</code><strong>中可以使用</strong><code>v-model</code><strong>来完成双向绑定：</strong></p><ul><li>这个时候往往会非常方便，因为 v-model 默认帮助我们完成了两件事；</li><li><code>v-bind:value的数据绑定</code>和<code>@input的事件监听</code>；</li></ul><p>如果我们现在<strong>封装了一个组件</strong>，其他地方在使用这个组件时，是否也可以<strong>使用 v-model 来同时完成这两个功能</strong>呢？</p><ul><li>也是可以的，vue 也支持在组件上使用 v-model；</li></ul><p><strong>当我们在组件上使用的时候，等价于如下的操作：</strong></p><ul><li>我们会发现和<code>input元素不同的只是属性的名称和事件触发的名称</code>而已；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061110293.png" alt="image-20211006111033627"></p><h4 id="组件-v-model-的实现"><a href="#组件-v-model-的实现" class="headerlink" title="组件 v-model 的实现"></a>组件 v-model 的实现</h4><p><strong>那么，为了我们的 MyInput 组件可以正常的工作，这个组件内的 &lt;input&gt; 必须：</strong></p><ul><li>将其 value attribute 绑定到一个名叫 modelValue 的 prop 上；</li><li>在其 input 事件被触发时，将新的值通过自定义的 update:modelValue 事件抛出</li></ul><p>MyInput.vue 的组件代码如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061111835.png" alt="image-20211006111118213"></p><h4 id="computed-实现"><a href="#computed-实现" class="headerlink" title="computed 实现"></a>computed 实现</h4><p>我们依然希望在组件内部按照双向绑定的做法去完成，应该如何操作呢？<strong>我们可以使用计算属性的 setter 和 getter 来完成。</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061111917.png" alt="image-20211006111138999"></p><h4 id="绑定多个属性"><a href="#绑定多个属性" class="headerlink" title="绑定多个属性"></a>绑定多个属性</h4><blockquote><p>我们现在通过 v-model 是直接绑定了一个属性，如果我们<strong>希望绑定多个属性</strong>呢？</p></blockquote><ul><li>也就是我们希望在<code>一个组件上使用多个v-model</code>是否可以实现呢？</li><li>我们知道，<code>默认情况下</code>的 v-model 其实是<code>绑定了 modelValue 属性</code>和 <code>@update:modelValue</code>的事件；</li><li>如果我们希望绑定更多，可以<code>给v-model传入一个参数</code>，那么这个参数的名称就是我们<code>绑定属性的名称</code>；</li></ul><p>注意：这里我是绑定了两个属性的</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061115621.png" alt="image-20211006111549814"></p><p><strong>v-model:title 相当于做了两件事：</strong></p><ol><li>绑定了<code>title属性</code>；</li><li>监听了 <code>@update:title的事件</code>；</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110061116318.png" alt="image-20211006111620669"></p>]]></content>
    
    
    <summary type="html">组件之间之间的传值，Mixin，异步组件，完全搞懂vue组件</summary>
    
    
    
    
    <category term="Vue3" scheme="https://qwq3.top/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vite基础</title>
    <link href="https://qwq3.top/posts/eb7d.html"/>
    <id>https://qwq3.top/posts/eb7d.html</id>
    <published>2021-10-01T10:15:32.000Z</published>
    <updated>2021-11-18T04:02:22.746Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><ul><li>认识 Vite</li><li>浏览器原生支持模块化</li><li>Vite 的安装和使用</li><li>Vite 对 css 的支持</li><li>Vite 对 TypeScript 的支持</li><li>Vite 对 vue 的支持</li><li>Vite 打包项目</li><li>ESBuild 解析</li><li>ESBuild 的构建速度</li><li>Vite 脚手架工具</li></ul></blockquote><h3 id="认识-Vite"><a href="#认识-Vite" class="headerlink" title="认识 Vite"></a>认识 Vite</h3><p>Webpack 是目前整个前端使用最多的构建工具，但是除了 webpack 之后也有其他的一些构建工具：</p><p>比如 rollup、parcel、gulp、vite 等等</p><blockquote><p>什么是 vite 呢？ 官方的定位：下一代前端开发与构建工具；</p><p>如何定义下一代开发和构建工具呢？</p></blockquote><ul><li>我们知道在实际开发中，我们编写的代码往往是不能被浏览器直接识别的，比如 ES6、TypeScript、Vue 文件等等；</li><li>所以我们必须通过构建工具来对代码进行转换、编译，类似的工具有 webpack、rollup、parcel；</li><li>但是随着项目越来越大，需要处理的 JavaScript 呈指数级增长，模块越来越多；</li><li>构建工具需要很长的时间才能开启服务器，HMR 也需要几秒钟才能在浏览器反应出来；</li><li>所以也有这样的说法：天下苦 webpack 久矣；</li><li>Vite (法语意为 “快速的”，发音 /vit/) 是一种新型前端构建工具，能够显著提升前端开发体验。</li></ul><h3 id="浏览器原生支持模块化"><a href="#浏览器原生支持模块化" class="headerlink" title="浏览器原生支持模块化"></a>浏览器原生支持模块化</h3><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109301106363.png" alt="image-20210930110600622"></p><p>但是如果我们不借助于其他工具，直接使用 ES Module 来开发有什么问题呢？</p><ul><li>首先，我们会发现在使用 loadash 时，加载了上百个模块的 js 代码，对于浏览器发送请求是巨大的消耗；</li><li>其次，我们的代码中如果有 TypeScript、less、vue 等代码时，浏览器并不能直接识别；</li></ul><p>事实上，vite 就帮助我们解决了上面的所有问题。</p><h3 id="Vite-的安装和使用"><a href="#Vite-的安装和使用" class="headerlink" title="Vite 的安装和使用"></a>Vite 的安装和使用</h3><p>注意：Vite 本身也是依赖 Node 的，所以也需要安装好 Node 环境</p><p>并且 Vite 要求 Node 版本是大于 12 版本的；</p><p>首先，我们安装一下 vite 工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install vite –g # 全局安装</span><br><span class="line">npm install vite –D # 局部安装</span><br></pre></td></tr></table></figure><p>通过 vite 来启动项目：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx vite</span><br></pre></td></tr></table></figure><h3 id="Vite-对-css-的支持"><a href="#Vite-对-css-的支持" class="headerlink" title="Vite 对 css 的支持"></a>Vite 对 css 的支持</h3><blockquote><p>vite 可以直接支持 css 的处理</p></blockquote><p>直接导入 css 即可；</p><blockquote><p>vite 可以直接支持 css 预处理器，比如 less</p></blockquote><ul><li><p>直接导入 less；</p></li><li><p>之后安装 less 编译器；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install less -D</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>vite 直接支持 postcss 的转换：</p></blockquote><p>只需要安装 postcss，并且配置 postcss.config.js 的配置文件即可；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss postcss-preset-env -D</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109301108136.png" alt="image-20210930110811392"></p><h3 id="Vite-对-TypeScript-的支持"><a href="#Vite-对-TypeScript-的支持" class="headerlink" title="Vite 对 TypeScript 的支持"></a>Vite 对 TypeScript 的支持</h3><p>vite 对 TypeScript 是原生支持的，它会直接使用 ESBuild 来完成编译：</p><ul><li>只需要直接导入即可；</li></ul><p>如果我们查看浏览器中的请求，会发现请求的依然是 ts 的代码：</p><ul><li>这是因为 vite 中的服务器 Connect 会对我们的请求进行转发；</li><li>获取 ts 编译后的代码，给浏览器返回，浏览器可以直接进行解析；</li></ul><p><code>注意</code>：在 vite2 中，已经不再使用<code>Koa</code>了，而是使用<code>Connect</code>来搭建的服务器</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109301109421.png" alt="image-20210930110908615"></p><h3 id="Vite-对-vue-的支持"><a href="#Vite-对-vue-的支持" class="headerlink" title="Vite 对 vue 的支持"></a>Vite 对 vue 的支持</h3><p>vite 对 vue 提供第一优先级支持：</p><p>Vue 3 单文件组件支持：<a href="https://github.com/vitejs/vite/tree/main/packages/plugin-vue">@vitejs/plugin-vue</a></p><p>Vue 3 JSX 支持：<a href="https://github.com/vitejs/vite/tree/main/packages/plugin-vue-jsx">@vitejs/plugin-vue-jsx</a></p><p>Vue 2 支持：<a href="https://github.com/underfin/vite-plugin-vue2">underfin/vite-plugin-vue2</a></p><p>安装支持 vue 的插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @vitejs/plugin-vue -D</span><br></pre></td></tr></table></figure><p>在 vite.config.js 中配置插件：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109301111866.png" alt="image-20210930111138679"></p><h3 id="Vite-打包项目"><a href="#Vite-打包项目" class="headerlink" title="Vite 打包项目"></a>Vite 打包项目</h3><p>我们可以直接通过 vite build 来完成对当前项目的打包工具：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx vite build</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109301112301.png" alt="image-20210930111214388"></p><p>我们可以通过 preview 的方式，开启一个本地服务来预览打包后的效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx vite preview</span><br></pre></td></tr></table></figure><h3 id="ESBuild-解析"><a href="#ESBuild-解析" class="headerlink" title="ESBuild 解析"></a>ESBuild 解析</h3><p>ESBuild 的特点：</p><ul><li>超快的构建速度，并且不需要缓存；</li><li>支持 ES6 和 CommonJS 的模块化；</li><li>支持 ES6 的 Tree Shaking；</li><li>支持 Go、JavaScript 的 API；</li><li>支持 TypeScript、JSX 等语法编译；</li><li>支持 SourceMap；</li><li>支持代码压缩；</li><li>支持扩展其他插件；</li></ul><h3 id="ESBuild-的构建速度"><a href="#ESBuild-的构建速度" class="headerlink" title="ESBuild 的构建速度"></a>ESBuild 的构建速度</h3><p>ESBuild 的构建速度和其他构建工具速度对比：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109301114900.png" alt="image-20210930111420140"></p><p>ESBuild 为什么这么快呢？</p><ul><li>使用 Go 语言编写的，可以直接转换成机器代码，而无需经过字节码；</li><li>ESBuild 可以充分利用 CPU 的多内核，尽可能让它们饱和运行；</li><li>ESBuild 的所有内容都是从零开始编写的，而不是使用第三方，所以从一开始就可以考虑各种性能问题；</li><li>等等….</li></ul><h3 id="Vite-脚手架工具"><a href="#Vite-脚手架工具" class="headerlink" title="Vite 脚手架工具"></a>Vite 脚手架工具</h3><p>在开发中，我们不可能所有的项目都使用 vite 从零去搭建，比如一个 react 项目、Vue 项目；</p><p>这个时候 vite 还给我们提供了对应的脚手架工具；</p><p>所以 Vite 实际上是有两个工具的：</p><ul><li>vite：相当于是一个构件工具，类似于 webpack、rollup；</li><li>@vitejs/create-app：类似 vue-cli、create-react-app；</li></ul><p>如何使用脚手架工具呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init @vitejs/app</span><br></pre></td></tr></table></figure><p>上面的做法相当于省略了安装脚手架的过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install @vitejs/create-app -g</span><br><span class="line">create-app</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Vite的使用，下一代前端开发与构建工具</summary>
    
    
    
    
    <category term="Vue3" scheme="https://qwq3.top/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>babel + Vue CLI脚手架</title>
    <link href="https://qwq3.top/posts/8f22.html"/>
    <id>https://qwq3.top/posts/8f22.html</id>
    <published>2021-09-29T09:15:32.000Z</published>
    <updated>2021-11-18T04:02:22.746Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么需要-babel？"><a href="#为什么需要-babel？" class="headerlink" title="为什么需要 babel？"></a>为什么需要 babel？</h3><blockquote><p>事实上，在开发中我们很少直接去接触 babel，但是<strong>babel 对于前端开发</strong>来说，目前是<strong>不可缺少的一部分</strong>：</p></blockquote><p>开发中，我们想要使用 ES6+的语法，想要使用 TypeScript，开发 React 项目，它们都是离不开 Babel 的；</p><p>所以，学习 Babel 对于我们理解代码从编写到线上的转变过程至关重要；</p><blockquote><p><strong>那么，Babel 到底是什么呢？</strong></p></blockquote><p>Babel 是一个工具链，主要用于旧浏览器或者环境中将 ECMAScript 2015+代码转换为向后兼容版本的 JavaScript；</p><p>包括：语法转换、源代码转换等；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251520731.png" alt="image-20210925152002988"></p><h3 id="Babel-命令行使用"><a href="#Babel-命令行使用" class="headerlink" title="Babel 命令行使用"></a>Babel 命令行使用</h3><blockquote><p>babel 本身可以作为<strong>一个独立的工具</strong>（和 postcss 一样），不和 webpack 等构建工具配置来单独使用。</p></blockquote><p>如果我们希望在命令行尝试使用 babel，需要安装如下库：</p><ul><li><code>@babel/core：</code>babel 的核心代码，必须安装；</li><li><code>@babel/cli：</code>可以让我们在命令行使用 babel；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @babel/cli @babel/core -D</span><br></pre></td></tr></table></figure><p>使用 babel 来处理我们的源代码：</p><ul><li>src：是源文件的目录；</li><li>–out-dir：指定要输出的文件夹 dist；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx babel src --out-dir dist</span><br></pre></td></tr></table></figure><h3 id="插件的使用"><a href="#插件的使用" class="headerlink" title="插件的使用"></a>插件的使用</h3><p>比如我们需要转换箭头函数，那么我们就可以使用<strong>箭头函数转换相关的插件</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install @babel/plugin-transform-arrow-functions -D</span><br><span class="line">npx babel src --out-dir dist --plugins=@babel/plugin-transform-arrow-functions</span><br></pre></td></tr></table></figure><blockquote><p>查看转换后的结果：我们会发现 const 并没有转成 var</p></blockquote><p>这是因为 <code>plugin-transform-arrow-functions</code>，并没有提供这样的功能；</p><p>我们需要使用 <code>plugin-transform-block-scoping</code> 来完成这样的功能；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install @babel/plugin-transform-block-scoping -D</span><br><span class="line">npx babel src --out-dir dist --plugins=@babel/plugin-transform-block-scoping,@babel/plugin-transform-arrow-functions</span><br></pre></td></tr></table></figure><h3 id="Babel-的预设-preset"><a href="#Babel-的预设-preset" class="headerlink" title="Babel 的预设 preset"></a>Babel 的预设 preset</h3><blockquote><p>但是如果要转换的内容过多，一个个设置是比较麻烦的，我们可以使用预设（preset）：</p></blockquote><p>后面我们再具体来讲预设代表的含义；</p><blockquote><p>安装@babel/preset-env 预设：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @babel/preset-env -D</span><br></pre></td></tr></table></figure><p>执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx babel src --out-dir dist --presets=@babel/preset-env</span><br></pre></td></tr></table></figure><h3 id="Babel-的底层原理"><a href="#Babel-的底层原理" class="headerlink" title="Babel 的底层原理"></a>Babel 的底层原理</h3><blockquote><p>babel 是如何做到将我们的<strong>一段代码（ES6、TypeScript、React）</strong>转成<strong>另外一段代码（ES5）</strong>的呢？</p></blockquote><p>从一种<code>源代码（原生语言）</code>转换成另一种<code>源代码（目标语言）</code>，这是什么的工作呢？</p><p>就是<strong>编译器</strong>，事实上我们可以将 babel 看成就是一个编译器。</p><p>Babel 编译器的作用就是将<code>我们的源代码</code>，转换成浏览器可以直接识别的<code>另外一段源代码</code>；</p><p><strong>Babel 也拥有编译器的工作流程：</strong></p><ul><li>解析阶段（Parsing）</li><li>转换阶段（Transformation）</li><li>生成阶段（Code Generation）</li></ul><p>github 项目地址：<a href="https://github.com/jamiebuilds/the-super-tiny-compiler">https://github.com/jamiebuilds/the-super-tiny-compiler</a></p><h3 id="Babel-编译器执行原理"><a href="#Babel-编译器执行原理" class="headerlink" title="Babel 编译器执行原理"></a>Babel 编译器执行原理</h3><p>Babel 的执行阶段</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251525116.png" alt="image-20210925152544011"></p><p>当然，这只是一个简化版的编译器工具流程，在每个阶段又会有自己具体的工作：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251526498.png" alt="image-20210925152602665"></p><h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h3><p>在实际开发中，我们通常会在构建工具中通过配置 babel 来对其进行使用的，比如在 webpack 中。</p><p>那么我们就需要去安装相关的依赖：</p><ul><li><p>如果之前已经安装了@babel/core，那么这里不需要再次安装；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-loader @babel/core</span><br></pre></td></tr></table></figure></li></ul><p>我们可以设置一个规则，在加载 js 文件时，使用我们的 babel：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251526607.png" alt="image-20210925152654703"></p><p><strong>指定使用的插件</strong></p><p>我们必须指定使用的插件才会生效</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251527761.png" alt="image-20210925152720066"></p><h3 id="babel-preset"><a href="#babel-preset" class="headerlink" title="babel-preset"></a>babel-preset</h3><p>如果我们一个个去安装使用插件，那么需要手动来管理大量的 babel 插件，我们可以直接给 webpack 提供一个 preset，webpack 会根据我们的预设来加载对应的插件列表，并且将其传递给 babel。</p><p>比如常见的预设有三个：</p><ul><li>env</li><li>react</li><li>TypeScript</li></ul><p>安装 preset-env：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @babel/preset-env</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251528882.png" alt="image-20210925152821178"></p><h3 id="Babel-的配置文件"><a href="#Babel-的配置文件" class="headerlink" title="Babel 的配置文件"></a>Babel 的配置文件</h3><blockquote><p>像之前一样，我们可以将 babel 的配置信息放到一个独立的文件中，babel 给我们提供了两种配置文件的编写：</p></blockquote><p>babel.config.json（或者.js，.cjs，.mjs）文件；</p><p>.babelrc.json（或者.babelrc，.js，.cjs，.mjs）文件</p><blockquote><p>它们两个有什么区别呢？目前很多的项目都采用了多包管理的方式（babel 本身、element-plus、umi 等）；</p></blockquote><p>.babelrc.json：早期使用较多的配置方式，但是对于配置 Monorepos 项目是比较麻烦的；</p><p>babel.config.json（babel7）：可以直接作用于 Monorepos 项目的子包，更加推荐；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251529483.png" alt="image-20210925152916649"></p><h3 id="Vue-源码的打包"><a href="#Vue-源码的打包" class="headerlink" title="Vue 源码的打包"></a>Vue 源码的打包</h3><p>我们主要是学习 Vue 的，那么我们应该包含 Vue 相关的代码：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251529766.png" alt="image-20210925152950069"></p><p>界面上是没有效果的：并且我们查看运行的控制台，会发现如下的警告信息；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251530744.png" alt="image-20210925153005773"></p><p><strong>Vue 打包后不同版本解析</strong></p><blockquote><p><strong>vue(.runtime).global(.prod).js：</strong></p></blockquote><p>通过浏览器中的 <script src="..."> 直接使用；</p><p>我们之前通过 CDN 引入和下载的 Vue 版本就是这个版本；</p><p>会暴露一个全局的 Vue 来使用；</p><blockquote><p><strong>vue(.runtime).esm-browser(.prod).js：</strong></p></blockquote><p>用于通过原生 ES 模块导入使用 (在浏览器中通过 <script type="module"> 来使用)。</p><blockquote><p><strong>vue(.runtime).esm-bundler.js：</strong></p></blockquote><p>用于 webpack，rollup 和 parcel 等构建工具；</p><p>构建工具中默认是 vue.runtime.esm-bundler.js；</p><p>如果我们需要解析模板 template，那么需要手动指定 vue.esm-bundler.js；</p><blockquote><p><strong>vue.cjs(.prod).js：</strong></p></blockquote><p>服务器端渲染使用；</p><p>通过 require()在 Node.js 中使用；</p><h3 id="运行时-编译器-vs-仅运行时"><a href="#运行时-编译器-vs-仅运行时" class="headerlink" title="运行时+编译器 vs 仅运行时"></a>运行时+编译器 vs 仅运行时</h3><blockquote><p>在 Vue 的开发过程中我们有<strong>三种方式</strong>来编写 DOM 元素：</p></blockquote><p>方式一：<code>template模板</code>的方式（之前经常使用的方式）；</p><p>方式二：<code>render函数</code>的方式，使用 h 函数来编写渲染的内容；</p><p>方式三：通过<code>.vue文件</code>中的 template 来编写模板；</p><blockquote><p><strong>它们的模板分别是如何处理的呢？</strong></p></blockquote><p>方式二中的 h 函数可以直接返回一个<strong>虚拟节点</strong>，也就是<strong>Vnode 节点</strong>；</p><p>方式一和方式三的 template 都需要有<code>特定的代码</code>来对其进行解析：</p><p>方式三.vue 文件中的 template 可以通过在<code>vue-loader</code>对其进行编译和处理；</p><p>方式一中的 template 我们必须要<code>通过源码中一部分代码</code>来进行编译；</p><blockquote><p>所以，Vue 在让我们选择版本的时候分为 <strong>运行时+编译器</strong> vs <strong>仅运行时</strong></p></blockquote><p><code>运行时+编译器</code>包含了对 template 模板的编译代码，更加完整，但是也更大一些；</p><p><code>仅运行时</code>没有包含对 template 版本的编译代码，相对更小一些；</p><h3 id="全局标识的配置"><a href="#全局标识的配置" class="headerlink" title="全局标识的配置"></a>全局标识的配置</h3><p>我们会发现控制台还有另外的一个警告：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251533556.png" alt="image-20210925153324781"></p><p>在 GitHub 上的文档中我们可以找到说明：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251533344.png" alt="image-20210925153335701"></p><p>这是两个特性的标识，一个是使用 Vue 的 Options，一个是 Production 模式下是否支持 devtools 工具；</p><p>虽然他们都有默认值，但是强烈建议我们手动对他们进行配置；</p><h3 id="VSCode-对-SFC-文件的支持"><a href="#VSCode-对-SFC-文件的支持" class="headerlink" title="VSCode 对 SFC 文件的支持"></a>VSCode 对 SFC 文件的支持</h3><p>在前面我们提到过，真实开发中多数情况下我们都是使用 SFC（ <strong>single-file components (单文件组件)</strong> ）。</p><blockquote><p>我们先说一下 VSCode 对 SFC 的支持：</p></blockquote><p>插件一：Vetur，从 Vue2 开发就一直在使用的 VSCode 支持 Vue 的插件；</p><p>插件二：Volar，官方推荐的插件（后续会基于 Volar 开发官方的 VSCode 插件）；</p><h3 id="App-vue-的打包过程"><a href="#App-vue-的打包过程" class="headerlink" title="App.vue 的打包过程"></a>App.vue 的打包过程</h3><p>我们对代码打包会报错：我们需要合适的 Loader 来处理文件</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251536871.png" alt="image-20210925153648536"></p><p>这个时候我们需要使用 vue-loader：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-loader -D</span><br></pre></td></tr></table></figure><p>在 webpack 的模板规则中进行配置：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251536894.png" alt="image-20210925153640068"></p><h3 id="vue-compiler-sfc"><a href="#vue-compiler-sfc" class="headerlink" title="@vue/compiler-sfc"></a>@vue/compiler-sfc</h3><p>打包依然会报错，这是因为我们必须添加@vue/compiler-sfc 来对 template 进行解析：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @vue/compiler-sfc -D</span><br></pre></td></tr></table></figure><p>另外我们需要配置对应的 Vue 插件：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251537842.png" alt="image-20210925153730977"></p><p>重新打包即可支持 App.vue 的写法</p><p>另外，我们也可以编写其他的.vue 文件来编写自己的组件；</p><h3 id="为什么要搭建本地服务器？"><a href="#为什么要搭建本地服务器？" class="headerlink" title="为什么要搭建本地服务器？"></a>为什么要搭建本地服务器？</h3><blockquote><p>目前我们开发的代码，为了运行需要有两个操作：</p></blockquote><p>操作一：npm run build，编译相关的代码；</p><p>操作二：通过 live server 或者直接通过浏览器，打开 index.html 代码，查看效果；</p><p>这个过程经常操作会影响我们的开发效率，我们希望可以做到，当文件发生变化时，可以自动的完成 编译 和 展示；</p><p>为了完成自动编译，webpack 提供了几种可选的方式：</p><ul><li>webpack watch mode；</li><li>webpack-dev-server（常用）；</li><li>webpack-dev-middleware；</li></ul><h3 id="Webpack-watch"><a href="#Webpack-watch" class="headerlink" title="Webpack watch"></a>Webpack watch</h3><blockquote><p>webpack 给我们提供了 watch 模式：</p></blockquote><p>在该模式下，webpack 依赖图中的所有文件，只要有一个发生了更新，那么代码将被重新编译；</p><p>我们不需要手动去运行 npm run build 指令了；</p><blockquote><p>如何开启 watch 呢？两种方式：</p></blockquote><p>方式一：在导出的配置中，添加 watch: true；</p><p>方式二：在启动 webpack 的命令中，添加 –watch 的标识；</p><p>这里我们选择方式二，在 package.json 的 scripts 中添加一个 watch 的脚本：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251539043.png" alt="image-20210925153907405"></p><h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h3><blockquote><p>上面的方式可以监听到文件的变化，但是事实上它本身是没有自动刷新浏览器的功能的：</p></blockquote><p>当然，目前我们可以在 VSCode 中使用 live-server 来完成这样的功能；</p><p>但是，我们希望在不适用 live-server 的情况下，可以具备 live reloading（实时重新加载）的功能；</p><blockquote><p>安装 webpack-dev-server</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server -D</span><br></pre></td></tr></table></figure><p>修改配置文件，告知 dev server，从什么位置查找文件：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251539570.png" alt="image-20210925153956893"></p><p>webpack-dev-server 在编译之后不会写入到任何输出文件。而是将 bundle 文件保留在内存中：</p><p>事实上 webpack-dev-server 使用了一个库叫 memfs（memory-fs webpack 自己写的）</p><h3 id="认识模块热替换（HMR）"><a href="#认识模块热替换（HMR）" class="headerlink" title="认识模块热替换（HMR）"></a>认识模块热替换（HMR）</h3><blockquote><p>什么是 HMR 呢？</p></blockquote><ul><li>HMR 的全称是 Hot Module Replacement，翻译为模块热替换；</li><li>模块热替换是指在 应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个页面；</li></ul><blockquote><p>HMR 通过如下几种方式，来提高开发的速度：</p></blockquote><ul><li>不重新加载整个页面，这样可以保留某些应用程序的状态不丢失；</li><li>只更新需要变化的内容，节省开发的时间；</li><li>修改了 css、js 源代码，会立即在浏览器更新，相当于直接在浏览器的 devtools 中直接修改样式；</li></ul><blockquote><p>如何使用 HMR 呢？</p></blockquote><p>默认情况下，webpack-dev-server 已经支持 HMR，我们只需要开启即可；</p><p>在不开启 HMR 的情况下，当我们修改了源代码之后，整个页面会自动刷新，使用的是 live reloading；</p><h3 id="开启-HMR"><a href="#开启-HMR" class="headerlink" title="开启 HMR"></a>开启 HMR</h3><p>修改 webpack 的配置：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251541652.png" alt="image-20210925154140930"></p><p>浏览器可以看到如下效果：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251541606.png" alt="image-20210925154151957"></p><p>但是你会发现，当我们修改了某一个模块的代码时，依然是刷新的整个页面：</p><p>这是因为我们需要去指定哪些模块发生更新时，进行 HMR；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251542498.png" alt="image-20210925154207841"></p><p><strong>框架的 HMR</strong></p><blockquote><p>有一个问题：在开发其他项目时，我们是否需要经常手动去写入 module.hot.accpet 相关的 API 呢？</p><p>比如开发 Vue、React 项目，我们修改了组件，希望进行热更新，这个时候应该如何去操作呢？</p></blockquote><p>事实上社区已经针对这些有很成熟的解决方案了：</p><p>比如 vue 开发中，我们使用<code>vue-loader</code>，此 loader 支持<code>vue组件的HMR</code>，提供开箱即用的体验；</p><p>比如 react 开发中，有<code>React Hot Loader</code>，<code>实时调整react组件</code>（目前 React 官方已经弃用了，改成使用<code>react-refresh</code>）；</p><p>接下来我们来演示一下 Vue 实现一下 HMR 功能。</p><h3 id="HMR-的原理"><a href="#HMR-的原理" class="headerlink" title="HMR 的原理"></a>HMR 的原理</h3><blockquote><p>那么 HMR 的原理是什么呢？如何可以做到只更新一个模块中的内容呢？</p></blockquote><ul><li>webpack-dev-server 会创建两个服务：提供静态资源的服务（express）和 Socket 服务（net.Socket）；</li><li>express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）；</li></ul><blockquote><p>HMR Socket Server，是一个 socket 的长连接：</p></blockquote><ul><li>长连接有一个最好的好处是建立连接后双方可以通信（服务器可以直接发送文件到客户端）；</li><li>当服务器监听到对应的模块发生变化时，会生成两个文件.json（manifest 文件）和.js 文件（update chunk）；</li><li>通过长连接，可以直接将这两个文件主动发送给客户端（浏览器）；</li><li>浏览器拿到两个新的文件后，通过 HMR runtime 机制，加载这两个文件，并且针对修改的模块进行更新；</li></ul><h3 id="HMR-的原理图"><a href="#HMR-的原理图" class="headerlink" title="HMR 的原理图"></a>HMR 的原理图</h3><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251545894.png" alt="image-20210925154514772"></p><h3 id="hotOnly、host-配置"><a href="#hotOnly、host-配置" class="headerlink" title="hotOnly、host 配置"></a>hotOnly、host 配置</h3><blockquote><p>host 设置主机地址：</p></blockquote><ul><li>默认值是 localhost；</li><li>如果希望其他地方也可以访问，可以设置为 0.0.0.0；</li></ul><blockquote><p>localhost 和 0.0.0.0 的区别：</p></blockquote><p>localhost：本质上是一个域名，通常情况下会被解析成 127.0.0.1;</p><p>127.0.0.1：回环地址(Loop Back Address)，表达的意思其实是我们主机自己发出去的包，直接被自己接收;</p><ul><li>正常的数据库包经常 应用层 - 传输层 - 网络层 - 数据链路层 - 物理层 ;</li><li>而回环地址，是在网络层直接就被获取到了，是不会经常数据链路层和物理层的;</li><li>比如我们监听 127.0.0.1 时，在同一个网段下的主机中，通过 ip 地址是不能访问的;</li></ul><blockquote><p>0.0.0.0：监听 IPV4 上所有的地址，再根据端口找到不同的应用程序;</p></blockquote><p>比如我们监听 0.0.0.0 时，在同一个网段下的主机中，通过 ip 地址是可以访问的;</p><h3 id="port、open、compress"><a href="#port、open、compress" class="headerlink" title="port、open、compress"></a>port、open、compress</h3><p>port 设置监听的端口，默认情况下是 8080</p><p>open 是否打开浏览器：</p><ul><li>默认值是 false，设置为 true 会打开浏览器；</li><li>也可以设置为类似于 Google Chrome 等值；</li></ul><p>compress 是否为静态文件开启 gzip compression：</p><ul><li>默认值是 false，可以设置为 true；<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251547317.png" alt="image-20210925154719468"></li></ul><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><blockquote><p>proxy 是我们开发中非常常用的一个配置选项，它的目的设置代理来解决跨域访问的问题：</p></blockquote><p>比如我们的一个 api 请求是 <a href="http://localhost:8888，但是本地启动服务器的域名是">http://localhost:8888，但是本地启动服务器的域名是</a> <a href="http://localhost:8000，这个时候发送网络请求就会出现跨域的问题；">http://localhost:8000，这个时候发送网络请求就会出现跨域的问题；</a></p><p>那么我们可以将请求先发送到一个代理服务器，代理服务器和 API 服务器没有跨域的问题，就可以解决我们的跨域问题了；</p><blockquote><p>我们可以进行如下的设置：</p></blockquote><p><code>target</code>：表示的是代理到的目标地址，比如 /api-an/moment 会被代理到 <a href="http://localhost:8888/api-an/moment%EF%BC%9B">http://localhost:8888/api-an/moment；</a></p><p><code>pathRewrite</code>：默认情况下，我们的 /api-hy 也会被写入到 URL 中，如果希望删除，可以使用 pathRewrite；</p><p><code>secure</code>：默认情况下不接收转发到 https 的服务器上，如果希望支持，可以设置为 false；</p><p><code>changeOrigin</code>：它表示是否更新代理后请求的 headers 中 host 地址；</p><h3 id="changeOrigin-的解析"><a href="#changeOrigin-的解析" class="headerlink" title="changeOrigin 的解析"></a>changeOrigin 的解析</h3><blockquote><p>这个 changeOrigin 官方说的非常模糊，通过查看源码我发现其实是要修改代理请求中的 headers 中的 host 属性：</p></blockquote><p>因为我们真实的请求，其实是需要通过 <a href="http://localhost:8888/">http://localhost:8888</a> 来请求的；</p><p>但是因为使用了代码，默认情况下它的值时 <a href="http://localhost:8000；">http://localhost:8000；</a></p><p>如果我们需要修改，那么可以将 changeOrigin 设置为 true 即可；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251549909.png" alt="image-20210925154952410"></p><h3 id="historyApiFallback"><a href="#historyApiFallback" class="headerlink" title="historyApiFallback"></a>historyApiFallback</h3><blockquote><p>historyApiFallback 是开发中一个非常常见的属性，它主要的作用是解决 SPA 页面在路由跳转之后，进行页面刷新时，返回 404 的错误。</p></blockquote><p>boolean 值：默认是 false</p><ul><li>如果设置为 true，那么在刷新时，返回 404 错误时，会自动返回 index.html 的内容；</li></ul><p>object 类型的值，可以配置 rewrites 属性：</p><ul><li>可以配置 from 来匹配路径，决定要跳转到哪一个页面；</li></ul><p>事实上 devServer 中实现 historyApiFallback 功能是通过 connect-history-api-fallback 库的：</p><p>可以查看 <a href="https://github.com/bripkens/connect-history-api-fallback">connect-history-api-fallback</a>文档</p><h3 id="resolve-模块解析"><a href="#resolve-模块解析" class="headerlink" title="resolve 模块解析"></a>resolve 模块解析</h3><p>resolve 用于设置模块如何被解析：</p><ul><li>在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库；</li><li>resolve 可以帮助 webpack 从每个 require/import 语句中，找到需要引入到合适的模块代码；</li><li>webpack 使用 enhanced-resolve 来解析文件路径；</li></ul><p><strong>webpack 能解析三种文件路径：</strong></p><ol><li>绝对路径<br>由于已经获得文件的绝对路径，因此不需要再做进一步解析。</li><li>相对路径<br>在这种情况下，使用 import 或 require 的资源文件所处的目录，被认为是上下文目录；<br>在 import/require 中给定的相对路径，会拼接此上下文路径，来生成模块的绝对路径；</li><li>模块路径<ul><li>在 resolve.modules 中指定的所有目录检索模块；<br>默认值是 [‘node_modules’]，所以默认会从 node_modules 中查找文件；</li><li>我们可以通过设置别名的方式来替换初识模块路径，具体后面讲解 alias 的配置；</li></ul></li></ol><h3 id="文件还是文件夹"><a href="#文件还是文件夹" class="headerlink" title="文件还是文件夹"></a>文件还是文件夹</h3><blockquote><p>如果是一个文件：</p></blockquote><p>如果文件具有扩展名，则直接打包文件；</p><p>否则，将使用 resolve.extensions 选项作为文件扩展名解析；</p><blockquote><p>如果是一个文件夹：</p></blockquote><p>会在文件夹中根据 resolve.mainFiles 配置选项中指定的文件顺序查找；</p><p>resolve.mainFiles 的默认值是 [‘index’]；</p><p>再根据 resolve.extensions 来解析扩展名；</p><h3 id="extensions-和-alias-配置"><a href="#extensions-和-alias-配置" class="headerlink" title="extensions 和 alias 配置"></a>extensions 和 alias 配置</h3><blockquote><p>extensions 是解析到文件时自动添加扩展名：</p></blockquote><p>默认值是 [‘.wasm’, ‘.mjs’, ‘.js’, ‘.json’]；</p><p>所以如果我们代码中想要添加加载 .vue 或者 jsx 或者 ts 等文件时，我们必须自己写上扩展名；</p><blockquote><p>另一个非常好用的功能是配置别名 alias：</p></blockquote><p>特别是当我们项目的目录结构比较深的时候，或者一个文件的路径可能需要 ../../../这种路径片段；</p><p>我们可以给某些常见的路径起一个别名;</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251556509.png" alt="image-20210925155657501"></p><h3 id="如何区分开发环境"><a href="#如何区分开发环境" class="headerlink" title="如何区分开发环境"></a>如何区分开发环境</h3><blockquote><p>目前我们所有的 webpack 配置信息都是放到一个配置文件中的：webpack.config.js</p></blockquote><ul><li>当配置越来越多时，这个文件会变得越来越不容易维护；</li><li>并且某些配置是在开发环境需要使用的，某些配置是在生成环境需要使用的，当然某些配置是在开发和生成环境都会使用的；</li><li>所以，我们最好对配置进行划分，方便我们维护和管理；</li></ul><blockquote><p>那么，在启动时如何可以区分不同的配置呢？</p></blockquote><p>方案一：编写两个不同的配置文件，开发和生成时，分别加载不同的配置文件即可；</p><p>方式二：使用相同的一个入口配置文件，通过设置参数来区分它们；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251608778.png" alt="image-20210925160836872"></p><h3 id="入口文件解析"><a href="#入口文件解析" class="headerlink" title="入口文件解析"></a>入口文件解析</h3><blockquote><p>我们之前编写入口文件的规则是这样的：./src/index.js，但是如果我们的配置文件所在的位置变成了 config 目录，我们是否应该变成 ../src/index.js 呢？</p></blockquote><p>如果我们这样编写，会发现是报错的，依然要写成 ./src/index.js；</p><p>这是因为入口文件其实是和另一个属性时有关的 context；</p><p>context 的作用是用于解析入口（entry point）和加载器（loader）：</p><ul><li>官方说法：默认是当前路径（但是经过我测试，默认应该是 webpack 的启动目录）</li><li>另外推荐在配置中传入一个值；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251609381.png" alt="image-20210925160958707"></p><h3 id="Vue-CLI-脚手架"><a href="#Vue-CLI-脚手架" class="headerlink" title="Vue CLI 脚手架"></a>Vue CLI 脚手架</h3><p>什么是 Vue 脚手架？</p><ul><li>我们前面学习了如何通过 webpack 配置 Vue 的开发环境，但是在真实开发中我们不可能每一个项目从头来完成</li><li>所有的 webpack 配置，这样显示开发的效率会大大的降低；</li><li>所以在真实开发中，我们通常会使用脚手架来创建一个项目，Vue 的项目我们使用的就是 Vue 的脚手架；</li><li>脚手架其实是建筑工程中的一个概念，在我们软件工程中也会将一些帮助我们搭建项目的工具称之为脚手架；</li></ul><p>Vue 的脚手架就是 Vue CLI：</p><ul><li>CLI 是 Command-Line Interface, 翻译为命令行界面；</li><li>我们可以通过 CLI 选择项目的配置和创建出我们的项目；</li><li>Vue CLI 已经内置了 webpack 相关的配置，我们不需要从零来配置；</li></ul><h3 id="Vue-CLI-安装和使用"><a href="#Vue-CLI-安装和使用" class="headerlink" title="Vue CLI 安装和使用"></a>Vue CLI 安装和使用</h3><blockquote><p>安装 Vue CLI（目前最新的版本是 v4.5.13）</p></blockquote><p>我们是进行全局安装，这样在任何时候都可以通过 vue 的命令来创建项目；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @vue/cli -g</span><br></pre></td></tr></table></figure><p>升级 Vue CLI：如果是比较旧的版本，可以通过下面的命令来升级</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update @vue/cli -g</span><br></pre></td></tr></table></figure><p>通过 Vue 的命令来创建项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue create 项目的名称</span><br></pre></td></tr></table></figure><h3 id="vue-create-项目的过程"><a href="#vue-create-项目的过程" class="headerlink" title="vue create 项目的过程"></a>vue create 项目的过程</h3><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251613546.png" alt="image-20210925161303053"></p><h3 id="项目的目录结构"><a href="#项目的目录结构" class="headerlink" title="项目的目录结构"></a>项目的目录结构</h3><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251613706.png" alt="image-20210925161321540"></p><h3 id="Vue-CLI-的运行原理"><a href="#Vue-CLI-的运行原理" class="headerlink" title="Vue CLI 的运行原理"></a>Vue CLI 的运行原理</h3><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251558149.png" alt="image-20210925155806633"></p>]]></content>
    
    
    <summary type="html">babel的使用，Vue CLI脚手架知识汇总</summary>
    
    
    
    
    <category term="Vue3" scheme="https://qwq3.top/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>webpack 使用汇总</title>
    <link href="https://qwq3.top/posts/5a8c.html"/>
    <id>https://qwq3.top/posts/5a8c.html</id>
    <published>2021-09-28T10:14:32.000Z</published>
    <updated>2021-11-18T04:02:22.746Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>认识 webpack</p></blockquote><h3 id="认识-webpack"><a href="#认识-webpack" class="headerlink" title="认识 webpack"></a>认识 webpack</h3><p>事实上随着前端的快速发展，目前前端的开发已经变的越来越复杂了：</p><ul><li>比如开发过程中我们需要通过<code>模块化的方式</code>来开发；</li><li>比如也会使用一些<code>高级的特性来加快我们的开发效率或者安全性</code>，比如通过 ES6+、TypeScript 开发脚本逻辑，通过 sass、less 等方式来编写 css 样式代码；</li><li>比如开发过程中，我们还希望<code>实时的监听文件</code>的变化来并且<code>反映到浏览器上</code>，提高开发的效率；</li><li>比如开发完成后我们还需要将<code>代码进行压缩、合并以及其他相关的优化</code>；</li></ul><p>但是对于很多的<strong>前端开发者</strong>来说，并不需要思考这些问题，日常的开发中根本就没有面临这些问题：</p><ul><li><p>这是因为目前前端开发我们通常都会直接使用三大框架来开发：<code>Vue</code>、<code>React</code>、<code>Angular</code>；</p></li><li><p>但是事实上，这三大框架的创建过程我们都是<code>借助于脚手架（CLI）</code>的；</p></li><li><p>事实上 Vue-CLI、create-react-app、Angular-CLI 都是<code>基于webpack</code>来帮助我们支持模块化、less、</p><p>TypeScript、打包优化等的；</p></li></ul><h3 id="脚手架依赖-webpack"><a href="#脚手架依赖-webpack" class="headerlink" title="脚手架依赖 webpack"></a>脚手架依赖 webpack</h3><p>事实上我们上面提到的所有脚手架都是依赖于 webpack 的：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251409189.png" alt="image-20210925140936905"></p><h3 id="Webpack-到底是什么呢？"><a href="#Webpack-到底是什么呢？" class="headerlink" title="Webpack 到底是什么呢？"></a><strong>Webpack 到底是什么呢？</strong></h3><p>我们先来看一下官方的解释：</p><p><strong>webpack</strong> is a <em>static module bundler</em> for modern JavaScript applications.</p><p><strong>webpack 是一个静态的模块化打包工具，为现代的 JavaScript 应用程序；</strong></p><p>我们来对上面的解释进行拆解：</p><ul><li><strong>打包 bundler</strong>：webpack 可以将帮助我们进行打包，所以它是一个打包工具</li><li><strong>静态的 static</strong>：这样表述的原因是我们最终可以将代码打包成最终的静态资源（部署到静态服务器）；</li><li><strong>模块化 module</strong>：webpack 默认支持各种模块化开发，ES Module、CommonJS、AMD 等；</li><li><strong>现代的 modern</strong>：我们前端说过，正是因为现代前端开发面临各种各样的问题，才催生了 webpack 的出现和发展</li></ul><p><strong>Webpack 官方的图片</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251411910.png" alt="image-20210925141143722"></p><p><strong>Vue 项目加载的文件有哪些呢？</strong></p><ul><li><strong>JavaScript 的打包：</strong><br>将 ES6 转换成 ES5 的语法；<br>TypeScript 的处理，将其转换成 JavaScript；</li><li><strong>Css 的处理：</strong><br>CSS 文件模块的加载、提取；<br>Less、Sass 等预处理器的处理；</li><li><strong>资源文件 img、font：</strong><br>图片 img 文件的加载；<br>字体 font 文件的加载；</li><li><strong>HTML 资源的处理：</strong><br>打包 HTML 资源文件；</li><li><strong>处理 vue 项目的 SFC 文件：</strong><br>vue 文件；</li></ul><h3 id="Webpack-的使用前提"><a href="#Webpack-的使用前提" class="headerlink" title="Webpack 的使用前提"></a>Webpack 的使用前提</h3><p>webpack 的官方文档是<a href="https://webpack.js.org/">https://webpack.js.org/</a></p><p>webpack 的中文官方文档是<a href="https://webpack.docschina.org/">https://webpack.docschina.org/</a></p><p>DOCUMENTATION：文档详情，也是我们最关注的</p><p>Webpack 的运行是依赖 Node 环境的，所以我们电脑上必须有 Node 环境</p><ul><li>所以我们需要先安装 Node.js，并且同时会安装 npm；</li><li>我当前电脑上的 node 版本是 v14.15.5，npm 版本是 6.14.11（你也可以使用 nvm 或者 n 来管理 Node 版本）；</li><li>Node 官方网站：<a href="https://nodejs.org/">https://nodejs.org/</a></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251413301.png" alt="image-20210925141317091"></p><h3 id="Webpack-的安装"><a href="#Webpack-的安装" class="headerlink" title="Webpack 的安装"></a>Webpack 的安装</h3><p>webpack 的安装目前分为两个：<code>webpack</code>、<code>webpack-cli</code></p><p><strong>那么它们是什么关系呢？</strong></p><ul><li>执行 webpack 命令，会执行 node_modules 下的.bin 目录下的 webpack；</li><li>webpack 在执行时是依赖 webpack-cli 的，如果没有安装就会报错；</li><li>而 webpack-cli 中代码执行时，才是真正利用 webpack 进行编译和打包的过程；</li><li>所以在安装 webpack 时，我们需要同时安装 webpack-cli（第三方的脚手架事实上是没有使用 webpack-cli 的，而是类似于自己的 vue-service-cli 的东西）</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251414680.png" alt="image-20210925141419087"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli –g # 全局安装</span><br><span class="line">npm install webpack webpack-cli –D # 局部安装</span><br></pre></td></tr></table></figure><h3 id="Webpack-的默认打包"><a href="#Webpack-的默认打包" class="headerlink" title="Webpack 的默认打包"></a>Webpack 的默认打包</h3><p>我们可以通过 webpack 进行打包，之后运行<code>打包之后</code>的代码<br>在目录下直接执行 webpack 命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack</span><br></pre></td></tr></table></figure><p><strong>生成一个 dist 文件夹，里面存放一个 main.js 的文件，就是我们打包之后的文件：</strong></p><ul><li>这个文件中的代码被压缩和丑化了；</li><li>我们暂时不关心他是如何做到的，后续我讲 webpack 实现模块化原理时会再次讲到；</li><li>另外我们发现代码中依然存在 ES6 的语法，比如箭头函数、const 等，这是因为默认情况下 webpack 并不清楚我 们打包后的文件是否需要转成 ES5 之前的语法，后续我们需要通过 babel 来进行转换和设置；</li></ul><p><strong>我们发现是可以正常进行打包的，但是有一个问题，webpack 是如何确定我们的入口的呢？</strong></p><ul><li>事实上，当我们运行 webpack 时，webpack 会查找当前目录下的 src/index.js 作为入口；</li><li>所以，如果当前项目中没有存在 src/index.js 文件，那么会报错；</li></ul><p><strong>当然，我们也可以通过配置来指定入口和出口</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack --entry ./src/main.js --output-path ./build</span><br></pre></td></tr></table></figure><h3 id="创建局部的-webpack"><a href="#创建局部的-webpack" class="headerlink" title="创建局部的 webpack"></a>创建局部的 webpack</h3><p>前面我们直接执行 webpack 命令使用的是全局的 webpack，如果希望使用局部的可以按照下面的步骤来操作。</p><p>第一步：创建 package.json 文件，用于管理项目的信息、库依赖等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>第二步：安装局部的 webpack</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli -D</span><br></pre></td></tr></table></figure><p>第三步：使用局部的 webpack</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>第四步：在 package.json 中创建 scripts 脚本，执行脚本打包即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251426859.png" alt="image-20210925142650783"></p><h3 id="Webpack-配置文件"><a href="#Webpack-配置文件" class="headerlink" title="Webpack 配置文件"></a>Webpack 配置文件</h3><p>在通常情况下，webpack 需要打包的项目是非常复杂的，并且我们需要一系列的配置来满足要求，默认配置必然是不可以的。</p><p>我们可以在根目录下创建一个 webpack.config.js 文件，来作为 webpack 的配置文件：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251427676.png" alt="image-20210925142729948"></p><p>继续执行 webpack 命令，依然可以正常打包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><h3 id="指定配置文件"><a href="#指定配置文件" class="headerlink" title="指定配置文件"></a>指定配置文件</h3><p>但是如果我们的配置文件并不是 webpack.config.js 的名字，而是其他的名字呢？</p><ul><li><p>比如我们将 webpack.config.js 修改成了 wk.config.js；</p></li><li><p>这个时候我们可以通过 –config 来指定对应的配置文件；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --config wk.config.js</span><br></pre></td></tr></table></figure></li></ul><p>但是每次这样执行命令来对源码进行编译，会非常繁琐，所以我们可以在 package.json 中增加一个新的脚本：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251428384.png" alt="image-20210925142847525"></p><p>之后我们执行 npm run build 来打包即可。</p><h3 id="Webpack-的依赖图"><a href="#Webpack-的依赖图" class="headerlink" title="Webpack 的依赖图"></a>Webpack 的依赖图</h3><p>webpack 到底是如何对我们的项目进行打包的呢？</p><ul><li>事实上 webpack 在处理应用程序时，它会根据命令或者配置文件找到入口文件；</li><li>从入口开始，会生成一个 依赖关系图，这个依赖关系图会包含应用程序中所需的所有模块（比如.js 文件、cs 文件、图片、字体等）；</li><li>然后遍历图结构，打包一个个模块（根据文件的不同使用不同的 loader 来解析）；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251429707.png" alt="image-20210925142949978"></p><h3 id="编写案例代码"><a href="#编写案例代码" class="headerlink" title="编写案例代码"></a>编写案例代码</h3><p>我们创建一个 component.js</p><p>通过 JavaScript 创建了一个元素，并且希望给它设置一些样式；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251430149.png" alt="image-20210925143033261"></p><h3 id="css-loader-的使用"><a href="#css-loader-的使用" class="headerlink" title="css-loader 的使用"></a>css-loader 的使用</h3><p>上面的错误信息告诉我们需要一个 loader 来加载这个 css 文件，但是<strong>loader</strong>是什么呢？</p><ul><li>loader 可以用于对模块的源代码进行转换；</li><li>我们可以将 css 文件也看成是一个模块，我们是通过 import 来加载这个模块的；</li><li>在加载这个模块时，webpack 其实并不知道如何对其进行加载，我们必须制定对应的 loader 来完成这个功能；</li></ul><p>那么我们需要一个什么样的 loader 呢？</p><ul><li>对于加载 css 文件来说，我们需要一个可以读取 css 文件的 loader；</li><li>这个 loader 最常用的是 css-loader；</li></ul><p>css-loader 的安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install css-loader -D</span><br></pre></td></tr></table></figure><p><strong>css-loader 的使用方案</strong></p><p><strong>如何使用这个 loader 来加载 css 文件呢？有三种方式：</strong></p><ul><li>内联方式；</li><li>CLI 方式（webpack5 中不再使用）；</li><li>配置方式；</li></ul><ol><li><p><strong>内联方式：</strong>内联方式使用较少，因为不方便管理；<br>在引入的样式前加上使用的 loader，并且使用!分割<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251432854.png" alt="image-20210925143244986"></p></li><li><p><strong>CLI 方式</strong></p><p>在 webpack5 的文档中已经没有了–module-bind；</p><p>实际应用中也比较少使用，因为不方便管理；</p></li><li><p><strong>loader 配置方式</strong></p><p>配置方式表示的意思是在我们的 webpack.config.js 文件中写明配置信息：</p><ul><li>module.rules 中允许我们配置多个 loader（因为我们也会继续使用其他的 loader，来完成其他文件的加载）；</li><li>这种方式可以更好的表示 loader 的配置，也方便后期的维护，同时也让你对各个 Loader 有一个全局的概览；</li></ul><p><strong>module.rules 的配置如下：</strong></p><ul><li><p>rules 属性对应的值是一个数组：**[Rule]**</p></li><li><p>数组中存放的是一个个的 Rule，Rule 是一个对象，对象中可以设置多个属性：</p><p><code>test属性</code>：用于对 resource（资源）进行匹配的，通常会设置成正则表达式；</p><p><code>use属性</code>：对应的值时一个数组：**[UseEntry]**</p><ul><li>UseEntry 是一个对象，可以通过对象的属性来设置一些其他属性<br>loader：必须有一个 loader 属性，对应的值是一个字符串；<br>options：可选的属性，值是一个字符串或者对象，值会被传入到 loader 中；<br>query：目前已经使用 options 来替代；</li><li><strong>传递字符串（如：use: [ ‘style-loader’ ]）是 loader 属性的简写方式（如：use: [ { loader: ‘style-loader’} ]）；</strong></li></ul></li><li><p><code>loader属性</code>： Rule.use: [ { loader } ] 的简写。</p></li></ul></li><li><p><strong>Loader 的配置代码</strong><br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251436551.png" alt="image-20210925143638256"></p></li></ol><h3 id="认识-style-loader"><a href="#认识-style-loader" class="headerlink" title="认识 style-loader"></a><strong>认识 style-loader</strong></h3><blockquote><p>我们已经可以通过 css-loader 来加载 css 文件了</p></blockquote><p>但是你会发现这个 css 在我们的代码中并没有生效（页面没有效果）。</p><blockquote><p>这是为什么呢？</p></blockquote><p>因为 css-loader 只是负责将.css 文件进行解析，并不会将解析之后的 css 插入到页面中；</p><p>如果我们希望再完成插入 style 的操作，那么我们还需要另外一个 loader，就是 style-loader；</p><blockquote><p>安装 style-loader</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install style-loader -D</span><br></pre></td></tr></table></figure><h3 id="配置-style-loader"><a href="#配置-style-loader" class="headerlink" title="配置 style-loader"></a>配置 style-loader</h3><blockquote><p>那么我们应该如何使用 style-loader？</p></blockquote><p>在配置文件中，添加 style-loader；</p><p><strong>注意</strong>：因为 loader 的执行顺序是从右向左（或者说从下到上，或者说从后到前的），所以我们需要将 style-loader 写到 css-loader 的前面；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251438553.png" alt="image-20210925143850466"></p><blockquote><p>重新执行编译 npm run build，可以发现打包后的 css 已经生效了</p></blockquote><p>当前目前我们的 css 是通过页内样式的方式添加进来的；</p><p>后续我们也会讲如何将 css 抽取到单独的文件中，并且进行压缩等操作；</p><h3 id="如何处理-less-文件？"><a href="#如何处理-less-文件？" class="headerlink" title="如何处理 less 文件？"></a>如何处理 less 文件？</h3><blockquote><p>在我们开发中，我们可能会使用 less、sass、stylus 的预处理器来编写 css 样式，效率会更高。</p></blockquote><p>那么，如何可以让我们的环境支持这些预处理器呢？</p><ul><li>首先我们需要确定，less、sass 等编写的 css 需要通过工具转换成普通的 css；</li></ul><p>比如我们编写如下的 less 样式：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251439382.png" alt="image-20210925143951238"></p><h3 id="Less-工具处理"><a href="#Less-工具处理" class="headerlink" title="Less 工具处理"></a>Less 工具处理</h3><p>我们可以使用 less 工具来完成它的编译转换：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install less -D</span><br></pre></td></tr></table></figure><p>执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx lessc ./src/css/title.less title.css</span><br></pre></td></tr></table></figure><h3 id="less-loader-处理"><a href="#less-loader-处理" class="headerlink" title="less-loader 处理"></a>less-loader 处理</h3><blockquote><p>但是在项目中我们会编写大量的 css，它们如何可以自动转换呢？</p></blockquote><p>这个时候我们就可以使用 less-loader，来自动使用 less 工具转换 less 到 css；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install less-loader -D</span><br></pre></td></tr></table></figure><blockquote><p>配置 webpack.config.js</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251441618.png" alt="image-20210925144130208"></p><p>执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>less 就可以自动转换成 css，并且页面也会生效了</p><h3 id="认识-PostCSS-工具"><a href="#认识-PostCSS-工具" class="headerlink" title="认识 PostCSS 工具"></a>认识 PostCSS 工具</h3><blockquote><p>什么是 PostCSS 呢？</p></blockquote><p>PostCSS 是一个通过 JavaScript 来转换样式的工具；</p><p>这个工具可以帮助我们进行一些 CSS 的转换和适配，比如自动添加浏览器前缀、css 样式的重置；</p><p>但是实现这些功能，我们需要借助于 PostCSS 对应的插件；</p><blockquote><p>如何使用 PostCSS 呢？主要就是两个步骤</p></blockquote><p>第一步：查找 PostCSS 在构建工具中的扩展，比如 webpack 中的 postcss-loader；</p><p>第二步：选择可以添加你需要的 PostCSS 相关的插件；</p><p><strong>命令行使用 postcss</strong></p><blockquote><p>当然，我们能不能也直接在终端使用 PostCSS 呢？</p></blockquote><p>也是可以的，但是我们需要单独安装一个工具 postcss-cli；</p><p>我们可以安装一下它们：<code>postcss</code>、<code>postcss-cli</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss postcss-cli -D</span><br></pre></td></tr></table></figure><p>我们编写一个需要添加前缀的 css：</p><p><a href="https://autoprefixer.github.io/">https://autoprefixer.github.io/</a></p><p>我们可以在上面的网站中查询一些添加 css 属性的样式；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251444309.png" alt="image-20210925144443971"></p><h3 id="插件-autoprefixer"><a href="#插件-autoprefixer" class="headerlink" title="插件 autoprefixer"></a>插件 autoprefixer</h3><p>因为我们需要添加前缀，所以要安装 autoprefixer：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install autoprefixer -D</span><br></pre></td></tr></table></figure><p>直接使用使用 postcss 工具，并且制定使用 autoprefixer</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx postcss --use autoprefixer -o end.css ./src/css/style.css</span><br></pre></td></tr></table></figure><p>转化之后的 css 样式如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251445248.png" alt="image-20210925144538808"></p><h3 id="postcss-loader"><a href="#postcss-loader" class="headerlink" title="postcss-loader"></a>postcss-loader</h3><p>真实开发中我们必然不会直接使用命令行工具来对 css 进行处理，而是可以借助于构建工具：</p><p>在 webpack 中使用 postcss 就是使用<code>postcss-loader</code>来处理的；</p><p>我们来安装 postcss-loader：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-loader -D</span><br></pre></td></tr></table></figure><p>我们修改加载 css 的 loader：（配置文件已经过多，给出一部分了）</p><p>注意：因为 postcss 需要有对应的插件才会起效果，所以我们需要配置它的 plugin；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251447798.png" alt="image-20210925144753559"></p><h3 id="单独的-postcss-配置文件"><a href="#单独的-postcss-配置文件" class="headerlink" title="单独的 postcss 配置文件"></a>单独的 postcss 配置文件</h3><p>当然，我们也可以将这些配置信息放到一个单独的文件中进行管理：</p><p>在根目录下创建 postcss.config.js</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251448193.png" alt="image-20210925144823888"></p><h3 id="postcss-preset-env"><a href="#postcss-preset-env" class="headerlink" title="postcss-preset-env"></a>postcss-preset-env</h3><p>事实上，在配置<code>postcss-loader</code>时，我们配置插件并不需要使用 autoprefixer。</p><p>我们可以使用另外一个插件：<strong>postcss-preset-env</strong></p><ul><li>postcss-preset-env 也是一个 postcss 的插件；</li><li>它可以帮助我们将一些现代的 CSS 特性，转成大多数浏览器认识的 CSS，并且会根据目标浏览器或者运行时环境添加所需的 polyfill；</li><li>也包括会自动帮助我们添加 autoprefixer（所以相当于已经内置了 autoprefixer）；</li></ul><p>首先，我们需要安装<code>postcss-preset-env</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-preset-env -D</span><br></pre></td></tr></table></figure><p>之后，我们直接修改掉之前的 autoprefixer 即可：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251449628.png" alt="image-20210925144955788"></p><p>注意：我们在使用某些 postcss 插件时，也可以直接传入字符串</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251450477.png" alt="image-20210925145010287"></p><h3 id="加载图片案例准备"><a href="#加载图片案例准备" class="headerlink" title="加载图片案例准备"></a>加载图片案例准备</h3><blockquote><p>为了演示我们项目中可以加载图片，我们需要在项目中使用图片，比较常见的使用图片的方式是两种：</p><p><code>img元素</code>，设置<code>src</code>属性；</p><p><code>其他元素</code>（比如 div），设置<code>background-image</code>的 css 属性；</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251453373.png" alt="image-20210925145300307"></p><h3 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h3><blockquote><p>要处理 jpg、png 等格式的图片，我们也需要有对应的 loader：<strong>file-loader</strong></p></blockquote><p>file-loader 的作用就是帮助我们处理<code>import/require()</code>方式引入的一个文件资源，并且会将它放到我们<code>输出的文件夹</code>中；</p><p>当然我们待会儿可以学习如何修改它的名字和所在文件夹；</p><blockquote><p>安装 file-loader</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install file-loader -D</span><br></pre></td></tr></table></figure><blockquote><p>配置处理图片的 Rule</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251454513.png" alt="image-20210925145421723"></p><p>图片就出来了</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251454622.png" alt="image-20210925145440502"></p><h3 id="文件的命名规则"><a href="#文件的命名规则" class="headerlink" title="文件的命名规则"></a>文件的命名规则</h3><p>有时候我们处理后的文件名称按照一定的规则进行显示：</p><ul><li>比如保留原来的文件名、扩展名，同时为了防止重复，包含一个 hash 值等；</li></ul><p>这个时候我们可以使用 PlaceHolders 来完成，webpack 给我们提供了大量的 PlaceHolders 来显示不同的内容：</p><ul><li><a href="https://webpack.js.org/loaders/file-loader/#placeholders">https://webpack.js.org/loaders/file-loader/#placeholders</a></li><li>我们可以在文档中查阅自己需要的 placeholder；</li></ul><p>我们这里介绍几个最常用的 placeholder：</p><ul><li><strong>[ext]：</strong> 处理文件的扩展名；</li><li><strong>[name]：</strong>处理文件的名称；</li><li><strong>[hash]：</strong>文件的内容，使用 MD4 的散列函数处理，生成的一个 128 位的 hash 值（32 个十六进制）；</li><li><strong>[contentHash]：</strong>在 file-loader 中和[hash]结果是一致的（在 webpack 的一些其他地方不一样，后面会讲到）；</li><li><strong>[hash:&lt;length&gt;]：</strong>截图 hash 的长度，默认 32 个字符太长了；</li><li><strong>[path]：</strong>文件相对于 webpack 配置文件的路径；</li></ul><p><strong>设置文件的名称</strong></p><p>那么我们可以按照如下的格式编写：</p><p>这个也是 vue 的写法；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251456573.png" alt="image-20210925145627560"></p><h3 id="设置文件的存放路径"><a href="#设置文件的存放路径" class="headerlink" title="设置文件的存放路径"></a>设置文件的存放路径</h3><p>当然，我们刚才通过 img/ 已经设置了文件夹，这个也是 vue、react 脚手架中常见的设置方式：</p><p>其实按照这种设置方式就可以了；</p><p>当然我们也可以通过<code>outputPath</code>来设置输出的文件夹；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251457256.png" alt="image-20210925145701244"></p><h3 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h3><p><strong>url-loader 和 file-loader</strong>的工作方式是相似的，但是可以将较小的文件，转成 base64 的 URI。</p><p>安装 url-loader：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install url-loader -D</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251457754.png" alt="image-20210925145741781"></p><p><strong>显示结果是一样的，并且图片可以正常显示；</strong></p><p>但是在 dist 文件夹中，我们会看不到图片文件：</p><ul><li>这是因为我的两张图片的大小分别是 38kb 和 295kb；</li><li>默认情况下 url-loader 会将所有的图片文件转成 base64 编码</li></ul><h3 id="url-loader-的-limit"><a href="#url-loader-的-limit" class="headerlink" title="url-loader 的 limit"></a>url-loader 的 limit</h3><p>但是开发中我们往往是<code>小的图片需要转换</code>，但是<code>大的图片直接使用图片</code>即可</p><ul><li>这是因为<code>小的图片转换base64</code>之后可以<code>和页面一起被请求</code>，<code>减少不必要的请求过程</code>；</li><li>而<code>大的图片也进行转换</code>，反而会<code>影响页面的请求速度</code>；</li></ul><p>那么，我们如何可以<strong>限制哪些大小的图片转换和不转换</strong>呢？</p><ul><li>purl-loader 有一个 options 属性<code>limit</code>，可以用于设置转换的限制；</li><li>下面的代码 38kb 的图片会进行 base64 编码，而 295kb 的不会；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251459922.png" alt="image-20210925145943079"></p><h3 id="认识-asset-module-type"><a href="#认识-asset-module-type" class="headerlink" title="认识 asset module type"></a>认识 asset module type</h3><ul><li><p><strong>我们当前使用的 webpack 版本是 webpack5：</strong><br>在 webpack5 之前，加载这些资源我们需要<code>使用一些loader，比如raw-loader 、url-loader、file-loader</code>；<br>在 webpack5 开始，我们可以直接使用<code>资源模块类型（asset module type）</code>，来替代上面的这些 loader；</p></li><li><p>**资源模块类型(asset module type)**，通过添加 4 种新的模块类型，来替换所有这些 loader：<br><strong>asset/resource</strong> 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现；<br><strong>asset/inline</strong> 导出一个资源的 data URI。之前通过使用 url-loader 实现；<br><strong>asset/source</strong> 导出资源的源代码。之前通过使用 raw-loader 实现；<br><strong>asset</strong> 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现；</p></li></ul><h3 id="asset-module-type-的使用"><a href="#asset-module-type-的使用" class="headerlink" title="asset module type 的使用"></a>asset module type 的使用</h3><p>比如加载图片，我们可以使用下面的方式：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251501906.png" alt="image-20210925150126053"></p><blockquote><p>但是，如何可以自定义文件的输出路径和文件名呢？</p></blockquote><p><strong>方式一：</strong>修改 output，添加 assetModuleFilename 属性；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251501656.png" alt="image-20210925150147714"></p><p><strong>方式二：</strong>在 Rule 中，添加一个 generator 属性，并且设置 filename；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251501345.png" alt="image-20210925150156349"></p><h3 id="url-loader-的-limit-效果"><a href="#url-loader-的-limit-效果" class="headerlink" title="url-loader 的 limit 效果"></a>url-loader 的 limit 效果</h3><p>我们需要两个步骤来实现：</p><p><strong>步骤一：</strong>将 type 修改为 asset；</p><p><strong>步骤二：</strong>添加一个 parser 属性，并且制定 dataUrl 的条件，添加 maxSize 属性；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251502472.png" alt="image-20210925150227524"></p><h3 id="加载字体文件"><a href="#加载字体文件" class="headerlink" title="加载字体文件"></a>加载字体文件</h3><blockquote><p>如果我们需要使用某些<code>特殊的字体或者字体图标</code>，那么我们会引入很多字体相关的文件，这些文件的处理也是一样的。</p></blockquote><p>首先，我从阿里图标库中下载了几个字体图标：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251503621.png" alt="image-20210925150318754"></p><p>在 component 中引入，并且添加一个 i 元素用于显示字体图标：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251503346.png" alt="image-20210925150330525"></p><h3 id="字体的打包"><a href="#字体的打包" class="headerlink" title="字体的打包"></a>字体的打包</h3><p>这个时候打包会报错，因为无法正确的处理<code>eot、ttf、woff</code>等文件：</p><p>我们可以选择使用 file-loader 来处理，也可以选择直接使用 webpack5 的资源模块类型来处理；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251503875.png" alt="image-20210925150359119"></p><h3 id="认识-Plugin"><a href="#认识-Plugin" class="headerlink" title="认识 Plugin"></a>认识 Plugin</h3><blockquote><p><strong>Webpack 的另一个核心是 Plugin，官方有这样一段对 Plugin 的描述：</strong>While loaders are used to transform certain types of modules, plugins can be leveraged to perform a wider range of tasks like bundle optimization, asset management and injection of environment variables</p></blockquote><p>上面表达的含义翻译过来就是：</p><p>Loader 是用于<code>特定的模块类型</code>进行转换；</p><p>Plugin 可以用于<code>执行更加广泛的任务</code>，比如打包优化、资源管理、环境变量注入等；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251505375.png" alt="image-20210925150518661"></p><h3 id="CleanWebpackPlugin"><a href="#CleanWebpackPlugin" class="headerlink" title="CleanWebpackPlugin"></a>CleanWebpackPlugin</h3><p>前面我们演示的过程中，每次修改了一些配置，重新打包时，都需要手动删除 dist 文件夹：</p><p>我们可以借助于一个插件来帮助我们完成，这个插件就是 CleanWebpackPlugin；</p><p>首先，我们先安装这个插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install clean-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>之后在插件中配置：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251506652.png" alt="image-20210925150603715"></p><h3 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h3><p>另外还有一个<strong>不太规范</strong>的地方：</p><ul><li>我们的 HTML 文件是编写在根目录下的，而最终打包的<code>dist文件夹中是没有index.html</code>文件的。</li><li>在<code>进行项目部署</code>的时候，必然也是需要<code>有对应的入口文件index.html</code>；</li><li>所以我们也需要对<code>index.html进行打包处理</code>；</li></ul><p>对 HTML 进行打包处理我们可以使用另外一个插件：<strong>HtmlWebpackPlugin</strong>；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin -D</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251507076.png" alt="image-20210925150738366"></p><h3 id="生成-index-html-分析"><a href="#生成-index-html-分析" class="headerlink" title="生成 index.html 分析"></a>生成 index.html 分析</h3><p>我们会发现，现在自动在 dist 文件夹中，生成了一个 index.html 的文件：</p><p>该文件中也自动添加了我们打包的 bundle.js 文件；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251508499.png" alt="image-20210925150801481"></p><p>这个文件是如何生成的呢？</p><ul><li>默认情况下是根据 ejs 的一个模板来生成的；</li><li>在 html-webpack-plugin 的源码中，有一个 default_index.ejs 模块；</li></ul><h3 id="自定义-HTML-模板"><a href="#自定义-HTML-模板" class="headerlink" title="自定义 HTML 模板"></a>自定义 HTML 模板</h3><blockquote><p>如果我们想在自己的模块中加入一些比较特别的内容：</p></blockquote><p>比如添加一个<code>noscript标签</code>，在用户的 JavaScript 被关闭时，给予响应的提示；</p><p>比如在<code>开发vue或者react项目</code>时，我们需要一个可以挂载后续组件的<code>根标签</code>&lt;div id=”app”&gt;&lt;/div&gt;；</p><p>这个我们需要一个属于自己的 index.html 模块：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251509217.png" alt="image-20210925150951534"></p><h3 id="自定义模板数据填充"><a href="#自定义模板数据填充" class="headerlink" title="自定义模板数据填充"></a>自定义模板数据填充</h3><blockquote><p>上面的代码中，会有一些类似这样的<code>语法&lt;% 变量 %&gt;</code>，这个是<code>EJS模块填充数据</code>的方式。</p></blockquote><p>在配置 HtmlWebpackPlugin 时，我们可以添加如下配置：</p><p><strong>template：</strong>指定我们要使用的模块所在的路径；</p><p><strong>title：</strong>在进行 htmlWebpackPlugin.options.title 读取时，就会读到该信息；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251510678.png" alt="image-20210925151034899"></p><h3 id="DefinePlugin-的介绍"><a href="#DefinePlugin-的介绍" class="headerlink" title="DefinePlugin 的介绍"></a>DefinePlugin 的介绍</h3><p>但是，这个时候编译还是会报错，因为在我们的模块中还使用到一个 BASE_URL 的常量：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251511101.png" alt="image-20210925151117631"></p><p>这是因为在编译 template 模块时，有一个 BASE_URL：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;</span> /&gt;</span></span><br><span class="line">；</span><br></pre></td></tr></table></figure><p>但是我们并没有设置过这个常量值，所以会出现没有定义的错误；</p><p>这个时候我们可以使用 DefinePlugin 插件；</p><p><strong>DefinePlugin 的使用</strong></p><p>DefinePlugin 允许在编译时创建配置的全局常量，是一个 webpack 内置的插件（不需要单独安装）：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251512209.png" alt="image-20210925151215364"></p><p>这个时候，编译 template 就可以正确的编译了，会读取到<code>BASE_URL</code>的值；</p><h3 id="CopyWebpackPlugin"><a href="#CopyWebpackPlugin" class="headerlink" title="CopyWebpackPlugin"></a>CopyWebpackPlugin</h3><blockquote><p>在 vue 的打包过程中，如果我们将一些文件放到 public 的目录下，那么这个目录会被复制到 dist 文件夹中。</p></blockquote><p>这个复制的功能，我们可以使用 CopyWebpackPlugin 来完成；</p><p>安装 CopyWebpackPlugin 插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install copy-webpack-plugin -D</span><br></pre></td></tr></table></figure><p><strong>接下来配置 CopyWebpackPlugin 即可：</strong></p><p>复制的规则在 patterns 中设置；</p><p><strong>from：</strong>设置从哪一个源中开始复制；</p><p><strong>to：</strong>复制到的位置，可以省略，会默认复制到打包的目录下；</p><p><strong>globOptions：</strong>设置一些额外的选项，其中可以编写需要忽略的文件：</p><ul><li>.DS_Store：mac 目录下回自动生成的一个文件；</li><li>index.html：也不需要复制，因为我们已经通过 HtmlWebpackPlugin 完成了 index.html 的生成；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251513071.png" alt="image-20210925151344177"></p><h3 id="Mode-配置"><a href="#Mode-配置" class="headerlink" title="Mode 配置"></a>Mode 配置</h3><p>前面我们一直没有讲 mode。</p><p>Mode 配置选项，可以告知 webpack 使用响应模式的内置优化：</p><ul><li>默认值是 production（什么都不设置的情况下）；</li><li>可选值有：’none’ | ‘development’ | ‘production’；</li></ul><blockquote><p>这几个选项有什么样的区别呢?</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251514854.png" alt="image-20210925151434001"></p><p><strong>Mode 配置代表更多</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251514381.png" alt="image-20210925151451207"></p>]]></content>
    
    
    <summary type="html">webpack插件的使用，依赖大全汇总</summary>
    
    
    
    
    <category term="Vue3" scheme="https://qwq3.top/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>v-for 中的 key 是什么作用</title>
    <link href="https://qwq3.top/posts/1e4.html"/>
    <id>https://qwq3.top/posts/1e4.html</id>
    <published>2021-09-27T09:14:32.000Z</published>
    <updated>2021-11-18T04:02:22.746Z</updated>
    
    <content type="html"><![CDATA[<h3 id="v-for-中的-key-是什么作用？"><a href="#v-for-中的-key-是什么作用？" class="headerlink" title="v-for 中的 key 是什么作用？"></a>v-for 中的 key 是什么作用？</h3><p>在使用 v-for 进行列表渲染时，我们通常会给元素或者组件绑定一个<code>key属性</code></p><p>这个 key 属性有什么作用呢？我们先来看一下<code>官方的解释</code>：</p><ul><li>key 属性主要用在 Vue 的<code>虚拟DOM算法</code>，在<code>新旧nodes</code>对比时辨识<code>VNodes</code></li><li>如果<code>不使用key</code>，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地<code>修改/复用相同类型元素</code>的算法</li><li>而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除/销毁 key 不存在的元素</li></ul><p>官方的解释对于初学者来说并不好理解，比如下面的问题:</p><ul><li>什么是新旧 nodes，什么是 VNode？</li><li>没有 key 的时候，如何尝试修改和复用的？</li><li>有 key 的时候，如何基于 key 重新排列的？</li></ul><h3 id="认识-VNode"><a href="#认识-VNode" class="headerlink" title="认识 VNode"></a>认识 VNode</h3><p>我们先来解释一下 VNode 的概念：</p><ul><li>因为目前我们还没有比较完整的学习组件的概念，所以目前我们先理解 HTML 元素创建出来的 VNode；</li><li>VNode 的全称是 Virtual Node，也就是虚拟节点；</li><li>事实上，无论是组件还是元素，它们最终在 Vue 中表示出来的都是一个个 VNode；</li><li>VNode 的本质是一个 JavaScript 的对象；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251343087.png" alt="image-20210925134319170"></p><h3 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h3><p>如果我们不只是一个简单的 div，而是有一大堆的元素，那么它们应该会形成一个 VNode Tree：<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251343695.png" alt="image-20210925134356824"></p><h3 id="插入-F-的案例"><a href="#插入-F-的案例" class="headerlink" title="插入 F 的案例"></a>插入 F 的案例</h3><p>我们先来看一个案例：这个案例是当我点击按钮时会在中间插入一个 f；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251344408.png" alt="image-20210925134420445"></p><ul><li>我们可以确定的是，这次更新对于 ul 和 button 是不需要进行更新，需要更新的是我们 li 的列表：<ol><li>在 Vue 中，对于相同父元素的子元素节点并不会重新渲染整个列表；</li><li>因为对于列表中 a、b、c、d 它们都是没有变化的；</li><li>在操作真实 DOM 的时候，我们只需要在中间插入一个 f 的 li 即可；</li></ol></li><li>那么 Vue 中对于列表的更新究竟是如何操作的呢？<ol><li>Vue 事实上会对于有 key 和没有 key 会调用两个不同的方法；</li><li>有 key，那么就使用 patchKeyedChildren 方法；</li><li>没有 key，那么久使用 patchUnkeyedChildren 方法；</li></ol></li></ul><h3 id="Vue-源码对于-key-的判断"><a href="#Vue-源码对于-key-的判断" class="headerlink" title="Vue 源码对于 key 的判断"></a>Vue 源码对于 key 的判断</h3><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251348903.png" alt="image-20210925134810853"></p><h3 id="没有-key-的操作（源码）"><a href="#没有-key-的操作（源码）" class="headerlink" title="没有 key 的操作（源码）"></a>没有 key 的操作（源码）</h3><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251348249.png" alt="image-20210925134838494"></p><h4 id="没有-key-的过程如下"><a href="#没有-key-的过程如下" class="headerlink" title="没有 key 的过程如下"></a>没有 key 的过程如下</h4><p>我们会发现上面的 diff 算法效率并不高：</p><ul><li>c 和 d 来说它们事实上并不需要有任何的改动；</li><li>但是因为我们的 c 被 f 所使用了，所有后续所有的内容都要一次进行改动，并且最后进行新增；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251349022.png" alt="image-20210925134931707"></p><h3 id="有-key-执行操作（源码）"><a href="#有-key-执行操作（源码）" class="headerlink" title="有 key 执行操作（源码）"></a>有 key 执行操作（源码）</h3><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251349960.png"></p><h4 id="有-key-的-diff-算法如下"><a href="#有-key-的-diff-算法如下" class="headerlink" title="有 key 的 diff 算法如下"></a>有 key 的 diff 算法如下</h4><ol><li><p>第一步的操作是从头开始进行遍历、比较：</p><ul><li>a 和 b 是一致的会继续进行比较；</li><li>c 和 f 因为 key 不一致，所以就会 break 跳出循环；</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251350421.png"></p></li><li><p>第二步的操作是从尾部开始进行遍历、比较：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251351335.png"></p></li><li><p>第三步是如果旧节点遍历完毕，但是依然有新的节点，那么就新增节点：<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251352705.png"></p></li><li><p>第四步是如果新的节点遍历完毕，但是依然有旧的节点，那么就移除旧节点：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251352850.png"></p></li><li><p>第五步是最特色的情况，中间还有很多未知的或者乱序的节点：<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109251356049.png"></p><p>所以我们可以发现，Vue 在进行 diff 算法的时候，会尽量利用我们的 key 来进行优化操作：</p><ul><li>在没有 key 的时候我们的效率是非常低效的；</li><li>在进行插入或者重置顺序的时候，保持相同的 key 可以让 diff 算法更加的高效；</li></ul></li></ol>]]></content>
    
    
    <summary type="html">v-for 中的 key 是什么作用, 深入研究vue3源码</summary>
    
    
    
    
    <category term="Vue3" scheme="https://qwq3.top/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue3的变化</title>
    <link href="https://qwq3.top/posts/e4a0.html"/>
    <id>https://qwq3.top/posts/e4a0.html</id>
    <published>2021-09-26T08:14:32.000Z</published>
    <updated>2021-11-18T04:02:22.746Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>目前需要学习 Vue3 吗？</strong></p></blockquote><p>在 2020 年的 9 月 19 日，万众期待的 Vue3 终于发布了正式版，命名为<strong>“One Piece”</strong>。</p><p>它也带来了很多新的特性：更好的性能、更小的包体积、更好的 TypeScript 集成、更优秀的 API 设计。</p><p>在 vue3 刚刚发布时，很多人也是跃跃欲试，想要尝试 vue3 的各种新特性。</p><p>但是事实上在刚刚发布的时候我们使用 vue3 来写 demo 练习是没有问题的，真正在实际业务项目中使用 vue3 还需要一个相对的过程；</p><p>包括 vue3 的进一步稳定、包括社区更多 vue3 相关的插件、组件库的支持和完善。</p><blockquote><p><strong>那么现在是否是学习 vue3 的时间呢？</strong></p></blockquote><p>答案是肯定的</p><p>首先 vue3 在经过一系列的更新和维护后，已经是趋于稳定，并且在之前尤雨溪也宣布在今年（2021 年）第二季度会</p><p>将 vue3 作为 Vue CLI 的默认版本了。</p><p>目前社区也经过一定时间的沉淀，更加的完善了，包括 AntDesignVue、Element-Plus 都提供了对 Vue3 的支持，所以</p><p>很多公司目前新的项目都已经在使用 Vue3 来进行开发了。</p><p>p 并且在面试的时候，几乎都会问到各种各样 Vue3、Vite2 工具相关的问题。</p><h3 id="Vue3-带来的变化（源码）"><a href="#Vue3-带来的变化（源码）" class="headerlink" title="Vue3 带来的变化（源码）"></a><strong>Vue3 带来的变化（源码）</strong></h3><ol><li>源码通过 monorepo 的形式来管理源代码：<br>Mono：单个<br>Repo：repository 仓库<br>主要是将许多项目的代码存储在同一个 repository 中；<br>这样做的目的是多个包本身相互独立，可以有自己的功能逻辑、单元测试等，同时又在同一个仓库下方便管理；<br>而且模块划分的更加清晰，可维护性、可扩展性更强；</li><li>源码使用 TypeScript 来进行重写：<br>在 Vue2.x 的时候，Vue 使用 Flow 来进行类型检测<br>在 Vue3.x 的时候，Vue 的源码全部使用 TypeScript 来进行重构，并且 Vue 本身对 TypeScript 支持也更好了；</li></ol><h3 id="Vue3-带来的变化（性能）"><a href="#Vue3-带来的变化（性能）" class="headerlink" title="Vue3 带来的变化（性能）"></a><strong>Vue3 带来的变化（性能）</strong></h3><ol><li>使用 Proxy 进行数据劫持<ul><li>在 Vue2.x 的时候，Vue2 是使用 Object.defineProperty 来劫持数据的 getter 和 setter 方法的；</li><li>这种方式一致存在一个缺陷就是当给对象添加或者删除属性时，是无法劫持和监听的；</li><li>所以在 Vue2.x 的时候，不得不提供一些特殊的 API，比如$set或$delete，事实上都是一些 hack 方法，也增加了开发者学习新的 API 的成本；</li><li>而在 Vue3.x 开始，Vue 使用 Proxy 来实现数据的劫持，这个 API 的用法和相关的原理我也会在后续讲到；</li></ul></li><li>删除了一些不必要的 API：<ul><li>移除了实例上的$on, $off 和 $once；</li><li>移除了一些特性：如 filter、内联模板等；</li></ul></li><li>包括编译方面的优化：<ul><li>生成 Block Tree、Slot 编译优化、diff 算法优化；</li></ul></li></ol><h3 id="Vue3-带来的变化（新的-API）"><a href="#Vue3-带来的变化（新的-API）" class="headerlink" title="Vue3 带来的变化（新的 API）"></a><strong>Vue3 带来的变化（新的 API）</strong></h3><ol><li>由 Options API 到 Composition API：<ul><li>在 Vue2.x 的时候，我们会通过 Options API 来描述组件对象；</li><li>Options API 包括 data、props、methods、computed、生命周期等等这些选项；</li><li>存在比较大的问题是多个逻辑可能是在不同的地方：<ul><li>比如 created 中会使用某一个 method 来修改 data 的数据，代码的内聚性非常差；</li></ul></li><li>Composition API 可以将 相关联的代码 放到同一处 进行处理，而不需要在多个 Options 之间寻找；</li></ul></li><li>Hooks 函数增加代码的复用性：<ul><li>在 Vue2.x 的时候，我们通常通过 mixins 在多个组件之间共享逻辑；</li><li>但是有一个很大的缺陷就是 mixins 也是由一大堆的 Options 组成的，并且多个 mixins 会存在命名冲突的问题；</li><li>在 Vue3.x 中，我们可以通过 Hook 函数，来将一部分独立的逻辑抽取出去，并且它们还可以做到是响应式的</li></ul></li></ol><h3 id="Vue-的源码"><a href="#Vue-的源码" class="headerlink" title="Vue 的源码"></a><strong>Vue 的源码</strong></h3><blockquote><p>如果想要学习 Vue 的源码，比如看 createApp 的实现过程，应该怎么办呢？</p></blockquote><ol><li>第一步：在 GitHub 上搜索 vue-next，下载源代码；<br>这里推荐通过 git clone 的方式下载；</li><li>第二步：安装 Vue 源码项目相关的依赖；<br>执行 yarn install</li><li>第三步：对项目执行打包操作<br>执行 yarn dev（执行前修改脚本）<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109250954886.png" alt="image-20210925095430520"></li><li>第四步：通过 packages/vue/dist/vue.global.js 调试代码</li></ol>]]></content>
    
    
    <summary type="html">Vue3的变化</summary>
    
    
    
    
    <category term="Vue3" scheme="https://qwq3.top/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>京东自动签到实现教程</title>
    <link href="https://qwq3.top/posts/3830.html"/>
    <id>https://qwq3.top/posts/3830.html</id>
    <published>2021-08-20T06:45:21.000Z</published>
    <updated>2021-11-18T04:02:22.742Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前段时间在某论坛上看到关于京东签到脚本的实现方式，于是就进行了记录部署过程</p></blockquote><div class="tip warning"><p>任何脚本都是有风险的，实践之前请注意，京东 cokies 代表的即是你本人，不要轻易将你的 cokies 交给其他人，下面示例中使用的是 Github<a href="https://github.com/zero205">zero205</a>搬运的代码，内置了该搬运工的助力码，也就是使用改代码必会帮他助力（不过人家不能用爱发电 hhh，更新速度也很快）</p></div><div class="tip warning"><p>该教程仅供学习使用，请于 24 小时内删除该代码！</p></div><h2 id="部署方式-1：利用腾讯云或阿里云函数实现"><a href="#部署方式-1：利用腾讯云或阿里云函数实现" class="headerlink" title="部署方式 1：利用腾讯云或阿里云函数实现"></a>部署方式 1：利用腾讯云或阿里云函数实现</h2><p>如果你没有服务器，并且也不想折腾的很麻烦，建议使用此方式进行部署</p><p>首先我们先来了解什么是：Github Action</p><h2 id="Github-Action"><a href="#Github-Action" class="headerlink" title="Github Action"></a><a href="https://link.zhihu.com/?target=https://github.com/features/actions">Github Action</a></h2><h3 id="GitHub-Actions-是什么？"><a href="#GitHub-Actions-是什么？" class="headerlink" title="GitHub Actions 是什么？"></a>GitHub Actions 是什么？</h3><p>Github Actions 是由 Github 创建的 CI/CD 服务。 它的目的是使所有软件开发工作流程的自动化变得容易。 直接从 GitHub 构建，测试和部署代码。CI（持续集成）由很多操作组成，比如代码合并、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。</p><p>很多操作在不同项目里面是类似的，完全可以共享。GitHub 允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。</p><p>如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方。</p><p>GitHub 做了一个<a href="https://link.zhihu.com/?target=https://github.com/marketplace?type=actions">GitHub Marketplace</a> ，可以搜索到他人提交的 actions。另外，还有一个<a href="https://link.zhihu.com/?target=https://github.com/sdras/awesome-actions">Awesome Actions</a>的仓库，也可以找到不少 action。</p><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>GitHub Actions 有一些自己的术语。</p><ul><li>workflow （工作流程）：持续集成一次运行的过程。</li><li>job （任务）：一个 workflow 由一个或多个 job 构成，含义是一次持续集成的运行，可以完成多个任务。</li><li>step（步骤）：每个 job 由多个 step 构成，一步步完成。</li><li>action （动作）：每个 step 可以依次执行一个或多个命令（action）。</li></ul><h4 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h4><p>GitHub Ac­tions 为每个任务 (job) 都提供了一个虚拟机来执行，每台虚拟机都有相同的硬件资源：</p><ul><li>2-core CPU, 7 GB RAM 内存, 14 GB SSD 硬盘空间</li><li>硬盘总容量为 90G 左右，可用空间为 30G 左右，评测详见：《GitHub Actions 虚拟服务器环境简单评测》</li></ul><p>使用限制：</p><ul><li>每个仓库只能同时支持 20 个 workflow 并行。</li><li>每小时可以调用 1000 次 GitHub API 。</li><li>每个 job 最多可以执行 6 个小时。</li><li>免费版的用户最大支持 20 个 job 并发执行，macOS 最大只支持 5 个。</li><li>私有仓库每月累计使用时间为 2000 分钟，超过后$ 0.008/分钟，公共仓库则无限制。</li><li>操作系统方面可选择 Win­dows server、Linux、ma­cOS，并预装了大量软件包和工具。</li></ul><blockquote><p>TIPS： 虽然名称叫持续集成，但当所有任务终止和完成时，虚拟环境内的数据会随之清空，并不会持续。即每个新任务都是一个全&gt;新的虚拟环境。</p></blockquote><h4 id="workflow-文件"><a href="#workflow-文件" class="headerlink" title="workflow 文件"></a>workflow 文件</h4><p>GitHub Ac­tions 的配置文件叫做 work­flow 文件，存放在代码仓库的<code>.github/workflows</code> 目录中。</p><p>work­flow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为.yml，比如 <code>build.yml</code>。一个库可以有多个 work­flow 文件，GitHub 只要发现<code>.github/workflows</code> 目录里面有<code>.yml</code> 文件，就会按照文件中所指定的触发条件在符合条件时自动运行该文件中的工作流程。</p><p>在 Ac­tions 页面可以看到很多种语言的 work­flow 文件的模版，可以用于简单的构建与测试。下面是一个简单的 work­flow 文件示例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">name: Hello World</span><br><span class="line">on: push</span><br><span class="line"><span class="built_in">jobs</span>:</span><br><span class="line">  my_first_job:</span><br><span class="line">    name: My first job</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">    - name: checkout</span><br><span class="line">      uses: actions/checkout@master</span><br><span class="line">    - name: Run a single-line script</span><br><span class="line">      run: <span class="built_in">echo</span> <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">  my_second_job:</span><br><span class="line">    name: My second job</span><br><span class="line">    runs-on: macos-latest</span><br><span class="line">    steps:</span><br><span class="line">    - name: Run a multi-line script</span><br><span class="line">      env:</span><br><span class="line">        MY_VAR: Hello World!</span><br><span class="line">        MY_NAME: P3TERX</span><br><span class="line">      run: |</span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$MY_VAR</span></span><br><span class="line">        <span class="built_in">echo</span> My name is <span class="variable">$MY_NAME</span></span><br></pre></td></tr></table></figure><h4 id="workflow-语法"><a href="#workflow-语法" class="headerlink" title="workflow 语法"></a>workflow 语法</h4><p>(1) name</p><p>name 字段是 work­flow 的名称。若忽略此字段，则默认会设置为 work­flow 文件名。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: GitHub Actions Demo</span><br></pre></td></tr></table></figure><p>(2) on</p><p>on 字段指定 work­flow 的触发条件，通常是某些事件，比如示例中的触发事件是 push，即在代码 push 到仓库后被触发。on 字段也可以是事件的数组，多种事件触发，比如在 push 或 pull_request 时触发：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">on: [push, pull_request]</span><br></pre></td></tr></table></figure><ul><li>push 指定分支触发</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - master</span><br></pre></td></tr></table></figure><ul><li>push tag 时触发</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    tags:</span><br><span class="line">    - <span class="string">&#x27;v*&#x27;</span></span><br></pre></td></tr></table></figure><p>完整的事件列表，请查看<a href="https://link.zhihu.com/?target=https://docs.github.com/en/actions/reference/events-that-trigger-workflows">官方文档</a>。除了代码库事件，GitHub Actions 也支持外部事件触发，或者定时运行。</p><p>(3) jobs</p><p>jobs 表示要执行的一项或多项任务。每一项任务必须关联一个 ID (job<em>id)，比如示例中的 my_first_job 和 my_second_job。job_id 里面的 name 字段是任务的名称。job_id 不能有空格，只能使用数字、英文字母和 - 或</em>符号，而 name 可以随意，若忽略 name 字段，则默认会设置为 job_id。</p><p>当有多个任务时，可以指定任务的依赖关系，即运行顺序，否则是同时运行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">jobs</span>:</span><br><span class="line">  job1:</span><br><span class="line">  job2:</span><br><span class="line">    needs: job1</span><br><span class="line">  job3:</span><br><span class="line">    needs: [job1, job2]</span><br></pre></td></tr></table></figure><p>上面代码中，job1 必须先于 job2 完成，而 job3 等待 job1 和 job2 的完成才能运行。因此，这个 work­flow 的运行顺序依次为：job1、job2、job3。</p><p>(4) runs-on</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runs-on: ubuntu-18.04</span><br></pre></td></tr></table></figure><p>runs-on 字段指定任务运行所需要的虚拟服务器环境，是必填字段，目前可用的虚拟机如下：</p><p>（5）steps</p><p>steps 字段指定每个任务的运行步骤，可以包含一个或多个步骤。步骤开头使用 - 符号。每个步骤可以指定以下字段:</p><ul><li>name：步骤名称。</li><li>uses：该步骤引用的 action 或 Docker 镜像。</li><li>run：该步骤运行的 bash 命令。</li><li>env：该步骤所需的环境变量。 其中 uses 和 run 是必填字段，每个步骤只能有其一。同样名称也是可以忽略的。</li></ul><h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><p>action 是 GitHub Ac­tions 中的重要组成部分，这点从名称中就可以看出，actions 是 action 的复数形式。它是已经编写好的步骤脚本，存放在 GitHub 仓库中。</p><p>对于初学者来说可以直接引用其它开发者已经写好的 action，可以在官方 action 仓库或者 <a href="https://link.zhihu.com/?target=https://github.com/marketplace?type=actions">GitHub Marketplace</a> 去获取。此外 <a href="https://link.zhihu.com/?target=https://github.com/sdras/awesome-actions">Awesome Actions</a> 这个项目收集了很多非常不错的 action。 既然 action 是代码仓库，当然就有版本的概念。引用某个具体版本的 action：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">steps:</span><br><span class="line">  - uses: actions/setup-node@74bc508 <span class="comment"># 指定一个 commit</span></span><br><span class="line">  - uses: actions/setup-node@v1.2    <span class="comment"># 指定一个 tag</span></span><br><span class="line">  - uses: actions/setup-node@master  <span class="comment"># 指定一个分支</span></span><br></pre></td></tr></table></figure><p>了解了 Github action 之后，我们就可以开始进行操作了。</p><h2 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h2><p>进入<a href="https://github.com/">https://github.com/</a></p><ol><li><p>注册账号后右上角<a href="https://github.com/new">导入仓库</a>，如图 ( 有能力的自己新建仓库 然后拉取代码后手动执行一次工作流 ）</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820112557547.png" alt="image-20210820112557547"></p></li><li><p>点击<a href="https://github.com/new/import">Import a repository.</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820113009384.png" alt="image-20210820113009384"></p></li><li><p>在 Your old repository’s clone URL 输入下面链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;zero205&#x2F;JD_tencent_scf</span><br></pre></td></tr></table></figure><p>Repository name 仓库名字随便起名，将仓库改为私有，然后点击 Begin import，完成导入</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820115116965.png" alt="image-20210820115116965"></p></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820115712606.png" alt="image-20210820115712606"></p><ol start="4"><li>将分支切换为 main 分支后，在下拉菜单中点击最下方’view all branches’，点击’Default branch’最右侧箭头,然后在新页面继续点击箭头,再弹出框中选择’scf’为主分支<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820120235626.png" alt="image-20210820120235626"><br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820120339068.png" alt="image-20210820120339068"><br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820120540716.png" alt="image-20210820120540716"> 5. 点击 Updata 后，确定更改 scf 为主分支<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820120629917.png" alt="image-20210820120629917"> 6. 然后回到代码仓库中，在仓库页面点击’main’分支,在下拉菜单中点击最下方’view all branches’,点击’maim’分支右侧垃圾桶,确认删除分支<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820120832318.png" alt="image-20210820120832318"> 7. 点击刚才页面’scf’分支右侧笔图标,将其重命名为’main’<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820121215393.png" alt="image-20210820121215393"></li></ol><h2 id="同步zero205仓库的代码"><a href="#同步zero205仓库的代码" class="headerlink" title="同步zero205仓库的代码"></a>同步<a href="https://github.com/zero205">zero205</a>仓库的代码</h2><h3 id="通过-reposync-方式进行代码同步"><a href="#通过-reposync-方式进行代码同步" class="headerlink" title="通过 reposync 方式进行代码同步"></a>通过 reposync 方式进行代码同步</h3><h3 id="PAT-Personal-Access-Token-模式"><a href="#PAT-Personal-Access-Token-模式" class="headerlink" title="PAT(Personal Access Token)模式"></a>PAT(Personal Access Token)模式</h3><p>即用私人访问命令的形式来判断该账户是否有权限接触仓库。通过 github 配置有一定限制性的密钥，并将其发放给其他开发人员，以共同完成代码仓库的开发和管理。</p><div class="tip warning faa-horizontal animated-hover"><p>注意 PAT 的隐私性，PAT 只会在生成时显示一次！保证你的 PAT 权限只勾选了你所需要的权限，永远不要将所有权限都开放给未知的人和事物，永远不要泄露你的 PAT！</p></div><h4 id="申请-PAT"><a href="#申请-PAT" class="headerlink" title="申请 PAT"></a>申请 PAT</h4><p><a href="https://github.com/settings/tokens/new">点此来生成一个 token</a> ，把 <code>repo</code>和<code>workflow</code> 两部分勾上，然后点击最下面的创建按钮。</p><h4 id="填写-PAT-到-Secrets"><a href="#填写-PAT-到-Secrets" class="headerlink" title="填写 PAT 到 Secrets"></a>填写 PAT 到 Secrets</h4><p>申请完毕后，在分支中点击<code>Settings</code>-<code>Secrets</code>-<code>New secret</code></p><p><code>name</code>填<code>PAT</code>，<code>Value</code>填入上方申请到的 PAT,保存即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820125306744.png" alt="image-20210820125306744"></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820125401819.png" alt="image-20210820125401819"></p><h4 id="手动触发一次代码同步"><a href="#手动触发一次代码同步" class="headerlink" title="手动触发一次代码同步"></a>手动触发一次代码同步</h4><p>点击<code>Actions</code>，执行<code>Run Workflows</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820125641172.png" alt="image-20210820125641172"></p><p>等待两分钟左右,能够发现代码全部同步过来</p><h2 id="Github-Action-部署"><a href="#Github-Action-部署" class="headerlink" title="Github Action 部署"></a>Github Action 部署</h2><h3 id="开通服务"><a href="#开通服务" class="headerlink" title="开通服务"></a>开通服务</h3><p>依次登录 <a href="https://console.cloud.tencent.com/scf">SCF 云函数控制台</a> 和 <a href="https://console.cloud.tencent.com/sls">SLS 控制台</a> 开通相关服务，确保账户下已开通服务并创建相应<a href="https://console.cloud.tencent.com/cam/role">服务角色</a> <strong>SCF_QcsRole、SLS_QcsRole</strong></p><blockquote><p>注意！为了确保权限足够，获取这两个参数时不要使用子账户！此外，腾讯云账户需要<a href="https://console.cloud.tencent.com/developer/auth">实名认证</a>。</p></blockquote><h3 id="新建腾讯云密钥（用于身份识别）"><a href="#新建腾讯云密钥（用于身份识别）" class="headerlink" title="新建腾讯云密钥（用于身份识别）"></a>新建腾讯云密钥（用于身份识别）</h3><p>在这里新建一个访问密钥 <a href="https://console.cloud.tencent.com/cam/capi">新建密钥</a></p><p>新建完成后你可以得到你的<code>SecretId</code>和<code>SecretKey</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820131344297.png" alt="image-20210820131344297"></p><blockquote><p>将 SecretId 和 SecretKey 分别配置在仓库的 secrets 变量里面</p><p>TENCENT_SECRET_ID 对应你的 SecretId 的值</p><p>TENCENT_SECRET_KEY 对应你的 SecretKey 的值</p></blockquote><p><strong>secrets 变量位置 : <code>Settings</code>–<code>左边栏的Secrets</code>–<code>右上角New repository secret</code>–<code>Name填变量名称,Value填变量值</code></strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820131437884.png" alt="image-20210820131437884"></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820131504267.png" alt="image-20210820131504267"></p><h3 id="获取京东-cookie"><a href="#获取京东-cookie" class="headerlink" title="获取京东 cookie"></a>获取京东 cookie</h3><p>这里有两种获取方式，自己选一种合适方便的获取京东 的 cookie 就好了</p><h4 id="浏览器获取京东-cookie"><a href="#浏览器获取京东-cookie" class="headerlink" title="浏览器获取京东 cookie"></a>浏览器获取京东 cookie</h4><p><strong>以下浏览器都行</strong></p><ul><li>Chrome 浏览器</li><li>新版 Edge 浏览器</li><li>国产 360，QQ 浏览器切换到极速模式</li></ul><h5 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h5><ol><li><p>电脑浏览器打开京东网址 <a href="https://m.jd.com/">https://m.jd.com/</a></p></li><li><p>按键盘 F12 键打开开发者工具，然后点下图中的图标<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820131824689.png" alt="切换到手机模式"></p></li><li><p>此时是未登录状态(使用手机短信验证码登录)，如已登录请忽略此步骤</p><ul><li>使用手机短信验证码登录(此方式 cookie 有效时长大概 31 天，其他登录方式比较短)</li></ul></li><li><p>登录后，选择 Network,有很多链接的话点箭头这里清空下<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820131918697.png" alt="清空"></p></li><li><p>然后再点我的，链接就变少了<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820131955882.png" alt="再次点击我的"></p></li><li><p>点第一个链接(log.gif)进去，找到 cookie，复制出来，新建一个 TXT 文本临时保存一下，下面需要用到<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820132251486.png" alt="复制cookie"></p></li><li><p>第六步复制出来的 cookie 比较长，我们只需要<code>pt_pin=xxxx;</code>和 <code>pt_key=xxxx;</code>部分的内容即可(注:英文引号<code>;</code>是必要的)。可以用下面的脚本，在 Chrome 浏览器按 F12，console 里面输入下面脚本按 enter 回车键<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820132154968.png" alt="获取短cookie"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var CV &#x3D; &#39;单引号里面放第六步拿到的cookie&#39;;</span><br><span class="line">var CookieValue &#x3D; CV.match(&#x2F;pt_pin&#x3D;.+?;&#x2F;) + CV.match(&#x2F;pt_key&#x3D;.+?;&#x2F;);</span><br><span class="line">copy(CookieValue);</span><br></pre></td></tr></table></figure></li><li><p>这样子整理出关键的的 cookie 已经在你的剪贴板上， 可直接粘贴</p></li><li><p>如果需获取第二个京东账号的 cookie,不要在刚才的浏览器上面退出登录账号一(否则刚才获取的 cookie 会失效),需另外换一个浏览器(Chrome 浏览器 <code>ctr+shift+n</code> 打开无痕模式也行),然后继续按上面步骤操作即可</p></li></ol><h4 id="插件获取京东-cookie"><a href="#插件获取京东-cookie" class="headerlink" title="插件获取京东 cookie"></a>插件获取京东 cookie</h4><blockquote><p>此教程内容由 tg 用户@wukongdada 提供,特此感谢</p></blockquote><p><strong>以下浏览器都行</strong></p><ul><li>Chrome 浏览器</li><li>新版 Edge 浏览器(chrome 内核)</li></ul><h5 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h5><ol><li>电脑浏览器打开京东网址 <a href="https://m.jd.com/">https://m.jd.com/</a></li><li>Chrome 类浏览器安装 EditThisCookie 插件<ul><li>Chrome 插件商店搜 EditThisCookie, 或者<a href="https://chrome.google.com/webstore/detail/editthiscookie/fngmhnnpilhplaeedifhccceomclgfbg?utm_source=chrome-ntp-icon">打开此网站</a> 进行安装</li><li>仅使用百分浏览器，谷歌浏览器测试过，其他谷歌类浏览器请自行测试。</li><li>无法登录 Chrome 插件商店或者打不开网址建议使用 edge chrome 版。</li></ul></li><li>edge chrome 浏览器安装 Cookie Editor 插件 - edge 插件商店搜 Cookie Editor，或<a href="https://microsoftedge.microsoft.com/addons/detail/cookie-editor/ajfboaconbpkglpfanbmlfgojgndmhmc?hl=zh-CN">打开以下网址</a> 完成插件安装</li><li>输入的网址是 <code>jd.com</code></li><li>现在点击回到京东触屏版，再点击 EditThisCookie/Cookie Editor，再点击搜索，输入 key 或 pin，如下图所示的 pt_key，复制 pt_key 的 value 值。此插件可以看到 cookie 的有效期。<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820133130360.png" alt="image-20210820133130360"></li><li>按照以下格式形成自己的 jd_cookie<ul><li><code>pt_key=复制插件搜索出来的key值;pt_pin=复制插件搜索出来的pin值;</code> ,后面的英文引号<code>;</code>是必须要的</li><li>给一个京东 cookie 具体示例 <code>pt_key=jdDC2F833333EFDGTCE5BD4AD1A952D4F4DF84A46052;pt_pin=jd_123456;</code></li></ul></li><li>如果需获取第二个京东账号的 cookie,不要在刚才的浏览器上面退出登录账号一(否则刚才获取的 cookie 会失效),需另外换一个浏览器(Chrome 浏览器 <code>ctr+shift+n</code> 打开无痕模式也行),然后继续按上面步骤操作即可</li></ol><h3 id="配置-secrets-变量"><a href="#配置-secrets-变量" class="headerlink" title="配置 secrets 变量"></a>配置 secrets 变量</h3><p>首先是必需的<code>JD_COOKIE</code>，在 secrets 里面加上我们刚刚获取到的 cookie</p><p>如果涉及一个变量配置多个值，如多个 cookie，互助码，多个取消订阅关键字，去掉里面的 <strong>空格</strong> 和 <strong>换行</strong> 使用 <code>&amp;</code> 连接</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820133530446.png" alt="image-20210820133530446"></p><p>secret 变量有三个<strong>选填变量</strong> <code>SCF_REGION</code>,<code>TENCENT_FUNCTION_NAME</code>,<code>TENCENTSCF_MEMORYSIZE</code>.都有默认值,可不修改.</p><p><code>SCF_REGION</code>用于控制部署区域的选择，默认值为<code>ap-guangzhou</code>，其他地区具体参数代码填写可以自行查找官方说明 <a href="https://cloud.tencent.com/document/product/213/6091">地域和可用区</a></p><p><code>TENCENT_FUNCTION_NAME</code>用于控制部署到云函数后函数名的命名,别瞎改,改名的话确保之前的已经删除 默认值为<code>JD</code></p><p><code>TENCENTSCF_MEMORYSIZE</code>值为运行内存大小的设定值，默认值为<code>64</code>，需求更大内存的可填入<code>128</code>，云函数有 128MB 就能满足了</p><p>请注意<strong>提高内存设定值相应地也会加快消耗云函数的免费额度，超出免费额度将会产生费用</strong></p><h2 id="执行-action-workflow-进行部署，workflow-未报错即部署成功"><a href="#执行-action-workflow-进行部署，workflow-未报错即部署成功" class="headerlink" title="执行 action workflow 进行部署，workflow 未报错即部署成功"></a>执行 action workflow 进行部署，workflow 未报错即部署成功</h2><p><strong>下图 workflow 名字现在叫做 Deploy</strong><br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820134036575.png" alt="部署"></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820134416463.png" alt="image-20210820134416463"></p><h2 id="查看和测试"><a href="#查看和测试" class="headerlink" title="查看和测试"></a>查看和测试</h2><p>登录后，在 <a href="https://console.cloud.tencent.com/scf/index">腾讯云函数地址</a> 点击管理控制台，查看最新部署的函数。</p><p>在左侧栏的日志查询中，可以查看到触发的日志，包括是否打卡成功等。</p><p><strong>请点击右下角切换旧版编辑器!</strong><br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820134701931.png" alt="image-20210820134701931"></p><p><strong>自己参照图内填写测试脚本名称,不带后缀,测什么,填什么</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210821120527058.png" alt="测试"></p><blockquote><p>如果出错了，排查问题第一步先看自己<a href="https://console.cloud.tencent.com/scf/list-detail?rid=5&ns=default&id=jd">腾讯云函数</a>那边的环境变量跟自己在仓库配置的 <code>secrets</code> 是否一致</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210820135211797.png" alt="image-20210820135211797"></p></blockquote><h2 id="Script-脚本列表"><a href="#Script-脚本列表" class="headerlink" title="Script 脚本列表"></a>Script 脚本列表</h2><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol><li>其中 <a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_bean_sign.js">jd_bean_sign.js</a> 可 N 个京东账号，Node.js 专用，核心脚本是 JD_DailyBonus.js， IOS 软件用户请使用 NobyDa 的 <a href="https://raw.githubusercontent.com/NobyDa/Script/master/JD-DailyBonus/JD_DailyBonus.js">JD_DailyBonus.js</a></li><li>以字母排序。</li></ol><table><thead><tr><th>序号</th><th>文件</th><th>名称</th><th>活动入口</th></tr></thead><tbody><tr><td>1</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_bean_change.js">jd_bean_change.js</a></td><td>京东资产变动通知</td><td></td></tr><tr><td>2</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_bean_home.js">jd_bean_home.js</a></td><td>领京豆额外奖励</td><td>京东 APP 首页-领京豆</td></tr><tr><td>3</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_bean_sign.js">jd_bean_sign.js</a></td><td>京东多合一签到</td><td>各处的签到汇总</td></tr><tr><td>4</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_beauty.js">jd_beauty.js</a></td><td>美丽研究院</td><td>京东 app 首页-美妆馆-底部中间按钮</td></tr><tr><td>5</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_blueCoin.js">jd_blueCoin.js</a></td><td>东东超市兑换奖品</td><td>京东 APP 我的-更多工具-东东超市</td></tr><tr><td>6</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_bookshop.js">jd_bookshop.js</a></td><td>口袋书店</td><td>京东 app 首页-京东图书-右侧口袋书店</td></tr><tr><td>7</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_car.js">jd_car.js</a></td><td>京东汽车</td><td>京东 APP 首页-京东汽车-屏幕右中部，车主福利</td></tr><tr><td>8</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_car_exchange.js">jd_car_exchange.js</a></td><td>京东汽车兑换</td><td>京东 APP 首页-京东汽车-屏幕右中部，车主福利</td></tr><tr><td>9</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_cash.js">jd_cash.js</a></td><td>签到领现金</td><td>京东 APP 搜索领现金进入</td></tr><tr><td>10</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_cfd.js">jd_cfd.js</a></td><td>京喜财富岛</td><td>京喜 APP-我的-京喜财富岛</td></tr><tr><td>11</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_club_lottery.js">jd_club_lottery.js</a></td><td>摇京豆</td><td>京东 APP 首页-领京豆-摇京豆/京东 APP 首页-我的-京东会员-摇京豆</td></tr><tr><td>12</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_crazy_joy.js">jd_crazy_joy.js</a></td><td>crazyJoy 任务</td><td>京东 APP 我的-更多工具-疯狂的 JOY</td></tr><tr><td>13</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_crazy_joy_bonus.js">jd_crazy_joy_bonus.js</a></td><td>监控 crazyJoy 分红</td><td>京东 APP 我的-更多工具-疯狂的 JOY</td></tr><tr><td>14</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_crazy_joy_coin.js">jd_crazy_joy_coin.js</a></td><td>crazyJoy 挂机</td><td>京东 APP 我的-更多工具-疯狂的 JOY</td></tr><tr><td>15</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_daily_egg.js">jd_daily_egg.js</a></td><td>天天提鹅</td><td>京东金融-天天提鹅</td></tr><tr><td>16</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_delCoupon.js">jd_delCoupon.js</a></td><td>删除优惠券</td><td>京东 APP 我的-优惠券</td></tr><tr><td>17</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_dreamFactory.js">jd_dreamFactory.js</a></td><td>京喜工厂</td><td>京东 APP-游戏与互动-查看更多-京喜工厂</td></tr><tr><td>18</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_dreamFactory2.js">jd_dreamFactory2.js</a></td><td>京喜工厂</td><td>京东 APP-游戏与互动-查看更多-京喜工厂</td></tr><tr><td>19</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_family.js">jd_family.js</a></td><td>京东家庭号</td><td>玩一玩-家庭号</td></tr><tr><td>20</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_fruit.js">jd_fruit.js</a></td><td>东东农场</td><td>京东 APP 我的-更多工具-东东农场</td></tr><tr><td>21</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_get_share_code.js">jd_get_share_code.js</a></td><td>获取互助码</td><td></td></tr><tr><td>22</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_global.js">jd_global.js</a></td><td>环球挑战赛</td><td>京东 app 搜索京东国际-环球挑战赛</td></tr><tr><td>23</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_global_mh.js">jd_global_mh.js</a></td><td>京东国际盲盒</td><td>京东 app 首页浮动窗口</td></tr><tr><td>24</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_jdfactory.js">jd_jdfactory.js</a></td><td>东东工厂</td><td>京东 APP 首页-数码电器-东东工厂</td></tr><tr><td>25</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_jdzz.js">jd_jdzz.js</a></td><td>京东赚赚</td><td>京东赚赚小程序</td></tr><tr><td>26</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_joy.js">jd_joy.js</a></td><td>宠汪汪</td><td>京东 APP 我的-更多工具-宠汪汪</td></tr><tr><td>27</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_joy_feedPets.js">jd_joy_feedPets.js</a></td><td>宠汪汪 🐕 喂食</td><td>京东 APP 我的-更多工具-宠汪汪</td></tr><tr><td>28</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_joy_help.js">jd_joy_help.js</a></td><td>宠汪汪强制为别人助力</td><td>京东 APP 我的-更多工具-宠汪汪</td></tr><tr><td>29</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_joy_reward.js">jd_joy_reward.js</a></td><td>宠汪汪积分兑换奖品</td><td>京东 APP 我的-更多工具-宠汪汪</td></tr><tr><td>30</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_joy_run.js">jd_joy_run.js</a></td><td>宠汪汪赛跑</td><td>京东 APP 我的-更多工具-宠汪汪</td></tr><tr><td>31</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_jxd.js">jd_jxd.js</a></td><td>京小兑</td><td>微信搜索小程序-京小兑</td></tr><tr><td>32</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_jxnc.js">jd_jxnc.js</a></td><td>京喜农场</td><td>京喜 APP 我的-京喜农场</td></tr><tr><td>33</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_kd.js">jd_kd.js</a></td><td>京东快递签到</td><td><a href="https://jingcai-h5.jd.com/#/">活动地址</a></td></tr><tr><td>34</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_live.js">jd_live.js</a></td><td>京东直播</td><td>京东 APP 首页-京东直播</td></tr><tr><td>35</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_live_redrain.js">jd_live_redrain.js</a></td><td>超级直播间红包雨</td><td></td></tr><tr><td>36</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_lotteryMachine.js">jd_lotteryMachine.js</a></td><td>京东抽奖机</td><td>京东 APP 中各种抽奖活动的汇总</td></tr><tr><td>37</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_mohe.js">jd_mohe.js</a></td><td>5G 超级盲盒</td><td><a href="https://isp5g.m.jd.com/">活动地址</a></td></tr><tr><td>38</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_moneyTree.js">jd_moneyTree.js</a></td><td>京东摇钱树</td><td>京东 APP 我的-更多工具-摇钱树</td></tr><tr><td>39</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_ms.js">jd_ms.js</a></td><td>京东秒秒币</td><td>京东 app-京东秒杀-签到领红包</td></tr><tr><td>40</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_necklace.js">jd_necklace.js</a></td><td>点点券</td><td>京东 APP-领券中心/券后 9.9-领点点券</td></tr><tr><td>41</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_nzmh.js">jd_nzmh.js</a></td><td>女装盲盒抽京豆</td><td>京东 app-女装馆-赢京豆</td></tr><tr><td>42</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_pet.js">jd_pet.js</a></td><td>东东萌宠</td><td>京东 APP 我的-更多工具-东东萌宠</td></tr><tr><td>43</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_pigPet.js">jd_pigPet.js</a></td><td>金融养猪</td><td>京东金融养猪猪</td></tr><tr><td>44</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_plantBean.js">jd_plantBean.js</a></td><td>京东种豆得豆</td><td>京东 APP 我的-更多工具-种豆得豆</td></tr><tr><td>45</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_price.js">jd_price.js</a></td><td>京东保价</td><td>京东保价</td></tr><tr><td>46</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_rankingList.js">jd_rankingList.js</a></td><td>京东排行榜</td><td>京东 APP 首页-更多频道-排行榜-悬浮按钮</td></tr><tr><td>47</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_redPacket.js">jd_redPacket.js</a></td><td>京东全民开红包</td><td>京东 APP 首页-领券-锦鲤红包</td></tr><tr><td>48</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_sgmh.js">jd_sgmh.js</a></td><td>闪购盲盒</td><td>京东 APP 首页-闪购-闪购盲盒</td></tr><tr><td>49</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_shop.js">jd_shop.js</a></td><td>进店领豆</td><td>京东 APP 首页-领京豆-进店领豆</td></tr><tr><td>50</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_sign.js">jd_sign.js</a></td><td>京东卡包签到</td><td></td></tr><tr><td>51</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_small_home.js">jd_small_home.js</a></td><td>东东小窝</td><td>京东 APP 我的-游戏与更多-东东小窝</td></tr><tr><td>52</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_speed.js">jd_speed.js</a></td><td>✈️ 天天加速</td><td>京东 APP 我的-更多工具-天天加速</td></tr><tr><td>53</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_speed_sign.js">jd_speed_sign.js</a></td><td>京东极速版</td><td>京东极速版 app-现金签到</td></tr><tr><td>54</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_superMarket.js">jd_superMarket.js</a></td><td>东东超市</td><td>京东 APP 首页-京东超市-底部东东超市</td></tr><tr><td>55</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_syj.js">jd_syj.js</a></td><td>赚京豆</td><td>赚京豆(微信小程序)-赚京豆-签到领京豆</td></tr><tr><td>56</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jd_unsubscribe.js">jd_unsubscribe.js</a></td><td>取关京东店铺和商品</td><td></td></tr><tr><td>57</td><td><a href="https://gitee.com/lxk0301/jd_scripts/raw/master/jx_sign.js">jx_sign.js</a></td><td>京喜签到</td><td></td></tr></tbody></table><h2 id="环境变量说明"><a href="#环境变量说明" class="headerlink" title="环境变量说明"></a>环境变量说明</h2><h3 id="京东-必须"><a href="#京东-必须" class="headerlink" title="京东(必须)"></a>京东(必须)</h3><table><thead><tr><th>Name</th><th>归属</th><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>JD_COOKIE</code></td><td>京东</td><td>必须</td><td>京东 cookie,多个账号的 cookie 使用<code>&amp;</code>隔开。具体获取参考<a href="https://github.com/lukesyy/jd_yun/blob/main/backUp/GetJdCookie.md">浏览器获取京东 cookie 教程</a> 或者 <a href="https://github.com/lukesyy/jd_yun/blob/main/backUp/GetJdCookie2.md">插件获取京东 cookie 教程</a></td></tr></tbody></table><h3 id="京东隐私安全-环境变量"><a href="#京东隐私安全-环境变量" class="headerlink" title="京东隐私安全 环境变量"></a>京东隐私安全 环境变量</h3><table><thead><tr><th>Name</th><th>归属</th><th>属性</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>JD_DEBUG</code></td><td>脚本打印 log</td><td>非必须</td><td>true</td><td>运行脚本时，是否显示 log,默认显示。改成 false 表示不显示，注重隐私的人可以设置 JD_DEBUG 为 false</td></tr><tr><td><code>JD_USER_AGENT</code></td><td>京东</td><td>非必须</td><td></td><td>自定义此库里京东系列脚本的 UserAgent，不懂不知不会 UserAgent 的请不要随意填写内容。如需使用此功能建议填写京东 APP 的 UA</td></tr></tbody></table><p><strong>推送通知环境变量(目前提供<code>微信server酱</code>、<code>pushplus(推送加)</code>、<code>iOS Bark APP</code>、<code>telegram机器人</code>、<code>钉钉机器人</code>、<code>企业微信机器人</code>、<code>iGot</code>等通知方式)</strong></p><table><thead><tr><th>Name</th><th>归属</th><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>PUSH_KEY</code></td><td>微信 server 酱推送</td><td>非必须</td><td>server 酱的微信通知<a href="http://sc.ftqq.com/3.version">官方文档</a>，已兼容 <a href="https://sct.ftqq.com/">Server 酱·Turbo 版</a></td></tr><tr><td><code>BARK_PUSH</code></td><td><a href="https://apps.apple.com/us/app/bark-customed-notifications/id1403753865">BARK 推送</a></td><td>非必须</td><td>IOS 用户下载 BARK 这个 APP,填写内容是 app 提供的<code>设备码</code>，例如：<a href="https://api.day.app/123">https://api.day.app/123</a> ，那么此处的设备码就是<code>123</code>，再不懂看 <a href="https://github.com/lukesyy/jd_yun/blob/main/icon/bark.jpg">这个图</a>（注：支持自建填完整链接即可）</td></tr><tr><td><code>BARK_SOUND</code></td><td><a href="https://apps.apple.com/us/app/bark-customed-notifications/id1403753865">BARK 推送</a></td><td>非必须</td><td>bark 推送声音设置，例如<code>choo</code>,具体值请在<code>bark</code>-<code>推送铃声</code>-<code>查看所有铃声</code></td></tr><tr><td><code>BARK_GROUP</code></td><td><a href="https://apps.apple.com/us/app/bark-customed-notifications/id1403753865">BARK 推送</a></td><td>非必须</td><td>bark 推送消息分组，例如<code>jd_scripts</code></td></tr><tr><td><code>TG_BOT_TOKEN</code></td><td>telegram 推送</td><td>非必须</td><td>tg 推送(需设备可连接外网),<code>TG_BOT_TOKEN</code>和<code>TG_USER_ID</code>两者必需,填写自己申请<a href="https://t.me/BotFather">@BotFather</a>的 Token,如<code>10xxx4:AAFcqxxxxgER5uw</code> , <a href="https://github.com/lukesyy/jd_yun/blob/main/backUp/TG_PUSH.md">具体教程</a></td></tr><tr><td><code>TG_USER_ID</code></td><td>telegram 推送</td><td>非必须</td><td>tg 推送(需设备可连接外网),<code>TG_BOT_TOKEN</code>和<code>TG_USER_ID</code>两者必需,填写<a href="https://t.me/getuseridbot">@getuseridbot</a>中获取到的纯数字 ID, <a href="https://github.com/lukesyy/jd_yun/blob/main/backUp/TG_PUSH.md">具体教程</a></td></tr><tr><td><code>DD_BOT_TOKEN</code></td><td>钉钉推送</td><td>非必须</td><td>钉钉推送(<code>DD_BOT_TOKEN</code>和<code>DD_BOT_SECRET</code>两者必需)<a href="https://developers.dingtalk.com/document/app/custom-robot-access">官方文档</a> ,只需<code>https://oapi.dingtalk.com/robot/send?access_token=XXX</code> 等于<code>=</code>符号后面的 XXX 即可</td></tr><tr><td><code>DD_BOT_SECRET</code></td><td>钉钉推送</td><td>非必须</td><td>(<code>DD_BOT_TOKEN</code>和<code>DD_BOT_SECRET</code>两者必需) ,密钥，机器人安全设置页面，加签一栏下面显示的 SEC 开头的<code>SECXXXXXXXXXX</code>等字符 , 注:钉钉机器人安全设置只需勾选<code>加签</code>即可，其他选项不要勾选,再不懂看 <a href="https://github.com/lukesyy/jd_yun/blob/main/icon/DD_bot.png">这个图</a></td></tr><tr><td><code>QYWX_KEY</code></td><td>企业微信机器人推送</td><td>非必须</td><td>密钥，企业微信推送 webhook 后面的 key <a href="https://work.weixin.qq.com/api/doc/90000/90136/91770">详见官方说明文档</a></td></tr><tr><td><code>QYWX_AM</code></td><td>企业微信应用消息推送</td><td>非必须</td><td>corpid,corpsecret,touser,agentid,素材库图片 id <a href="http://note.youdao.com/s/HMiudGkb">参考文档 1</a> <a href="http://note.youdao.com/noteshare?id=1a0c8aff284ad28cbd011b29b3ad0191">参考文档 2</a> 素材库图片填 0 为图文消息, 填 1 为纯文本消息</td></tr><tr><td><code>IGOT_PUSH_KEY</code></td><td>iGot 推送</td><td>非必须</td><td>iGot 聚合推送，支持多方式推送，确保消息可达。 <a href="https://wahao.github.io/Bark-MP-helper">参考文档</a></td></tr><tr><td><code>PUSH_PLUS_TOKEN</code></td><td>pushplus 推送</td><td>非必须</td><td>微信扫码登录后一对一推送或一对多推送下面的 token(您的 Token) <a href="http://www.pushplus.plus/">官方网站</a></td></tr><tr><td><code>PUSH_PLUS_USER</code></td><td>pushplus 推送</td><td>非必须</td><td>一对多推送的“群组编码”（一对多推送下面-&gt;您的群组(如无则新建)-&gt;群组编码）注:(1、需订阅者扫描二维码 2、如果您是创建群组所属人，也需点击“查看二维码”扫描绑定，否则不能接受群组消息推送)，只填<code>PUSH_PLUS_TOKEN</code>默认为一对一推送</td></tr><tr><td><code>TG_PROXY_HOST</code></td><td>Telegram 代理的 IP</td><td>非必须</td><td>代理类型为 http。例子：http 代理 <a href="http://127.0.0.1:1080/">http://127.0.0.1:1080</a> 则填写 127.0.0.1</td></tr><tr><td><code>TG_PROXY_PORT</code></td><td>Telegram 代理的端口</td><td>非必须</td><td>例子：http 代理 <a href="http://127.0.0.1:1080/">http://127.0.0.1:1080</a> 则填写 1080</td></tr></tbody></table><h3 id="互助码类环境变量"><a href="#互助码类环境变量" class="headerlink" title="互助码类环境变量"></a>互助码类环境变量</h3><table><thead><tr><th>Name</th><th>归属</th><th>属性</th><th>需要助力次数/可提供助力次数</th><th>说明</th></tr></thead><tbody><tr><td><code>FRUITSHARECODES</code></td><td>东东农场 互助码</td><td>非必须</td><td>5/3</td><td>填写规则请看<a href="https://github.com/lukesyy/jd_yun/blob/main/jdFruitShareCodes.js">jdFruitShareCodes.js</a>或见下方<a href="https://github.com/lukesyy/jd_yun/blob/main/githubAction.md#%E4%BA%92%E5%8A%A9%E7%A0%81%E7%9A%84%E5%A1%AB%E5%86%99%E8%A7%84%E5%88%99">互助码的填写规则</a></td></tr><tr><td><code>PETSHARECODES</code></td><td>东东萌宠 互助码</td><td>非必须</td><td>5/5</td><td>填写规则和上面类似或见下方<a href="https://github.com/lukesyy/jd_yun/blob/main/githubAction.md#%E4%BA%92%E5%8A%A9%E7%A0%81%E7%9A%84%E5%A1%AB%E5%86%99%E8%A7%84%E5%88%99">互助码的填写规则</a></td></tr><tr><td><code>PLANT_BEAN_SHARECODES</code></td><td>种豆得豆 互助码</td><td>非必须</td><td>9/3</td><td>填写规则和上面类似或见下方<a href="https://github.com/lukesyy/jd_yun/blob/main/githubAction.md#%E4%BA%92%E5%8A%A9%E7%A0%81%E7%9A%84%E5%A1%AB%E5%86%99%E8%A7%84%E5%88%99">互助码的填写规则</a></td></tr><tr><td><code>DDFACTORY_SHARECODES</code></td><td>东东工厂 互助码</td><td>非必须</td><td>5/3</td><td>填写规则和上面类似或见下方<a href="https://github.com/lukesyy/jd_yun/blob/main/githubAction.md#%E4%BA%92%E5%8A%A9%E7%A0%81%E7%9A%84%E5%A1%AB%E5%86%99%E8%A7%84%E5%88%99">互助码的填写规则</a></td></tr><tr><td><code>DREAM_FACTORY_SHARE_CODES</code></td><td>京喜工厂 互助码</td><td>非必须</td><td>不固定/3</td><td>填写规则和上面类似或见下方<a href="https://github.com/lukesyy/jd_yun/blob/main/githubAction.md#%E4%BA%92%E5%8A%A9%E7%A0%81%E7%9A%84%E5%A1%AB%E5%86%99%E8%A7%84%E5%88%99">互助码的填写规则</a></td></tr><tr><td><code>JDZZ_SHARECODES</code></td><td>京东赚赚 互助码</td><td>非必须</td><td>5/2</td><td>填写规则和上面类似，或见下方<a href="https://github.com/lukesyy/jd_yun/blob/main/githubAction.md#%E4%BA%92%E5%8A%A9%E7%A0%81%E7%9A%84%E5%A1%AB%E5%86%99%E8%A7%84%E5%88%99">互助码的填写规则</a></td></tr><tr><td><code>JDJOY_SHARECODES</code></td><td>疯狂的 JOY 互助码</td><td>非必须</td><td>6/</td><td>填写规则和上面类似，或见下方<a href="https://github.com/lukesyy/jd_yun/blob/main/githubAction.md#%E4%BA%92%E5%8A%A9%E7%A0%81%E7%9A%84%E5%A1%AB%E5%86%99%E8%A7%84%E5%88%99">互助码的填写规则</a></td></tr><tr><td><code>BOOKSHOP_SHARECODES</code></td><td>京东书店 互助码</td><td>非必须</td><td>10/</td><td>填写规则和上面类似，或见下方<a href="https://github.com/lukesyy/jd_yun/blob/main/githubAction.md#%E4%BA%92%E5%8A%A9%E7%A0%81%E7%9A%84%E5%A1%AB%E5%86%99%E8%A7%84%E5%88%99">互助码的填写规则</a></td></tr><tr><td><code>JD_CASH_SHARECODES</code></td><td>签到领现金 互助码</td><td>非必须</td><td>10/</td><td>填写规则和上面类似，或见下方<a href="https://github.com/lukesyy/jd_yun/blob/main/githubAction.md#%E4%BA%92%E5%8A%A9%E7%A0%81%E7%9A%84%E5%A1%AB%E5%86%99%E8%A7%84%E5%88%99">互助码的填写规则</a></td></tr><tr><td><code>JXNC_SHARECODES</code></td><td>京喜农场 互助码</td><td>非必须</td><td>/</td><td>注意：京喜农场种植种子发生变化的时候，互助码也会变！！ 每个账号 shareCode 是一个 json， json 需要用单引号包裹且是一行字符串， 否则设置环境变量时会出错， 示例：’{“smp”:”22bdadsfaadsfadse8a”, “active”:”jdnc_1_btorange210113_2”,”joinnum”:”1”}’， 多账单间使用<code>&amp;</code>或换行分开。 详细说明参见<a href="https://github.com/LXK9301/jd_scripts/pull/202">#Pr202</a> 如果使用<code>docker-compose</code>部署就不需要在互助码两端加单引号。详细参见 Issues<a href="https://gitee.com/lxk0301/jd_scripts/issues/I35AG8">#I35AG8</a></td></tr><tr><td><code>JDSGMH_SHARECODES</code></td><td>闪购盲盒 互助码</td><td>非必须</td><td>10/</td><td>填写规则和上面类似，或见下方<a href="https://github.com/lukesyy/jd_yun/blob/main/githubAction.md#%E4%BA%92%E5%8A%A9%E7%A0%81%E7%9A%84%E5%A1%AB%E5%86%99%E8%A7%84%E5%88%99">互助码的填写规则</a></td></tr><tr><td><code>JDCFD_SHARECODES</code></td><td>京喜财富岛 互助码</td><td>非必须</td><td>未知/未知</td><td>填写规则和上面类似，或见下方<a href="https://github.com/lukesyy/jd_yun/blob/main/githubAction.md#%E4%BA%92%E5%8A%A9%E7%A0%81%E7%9A%84%E5%A1%AB%E5%86%99%E8%A7%84%E5%88%99">互助码的填写规则</a></td></tr><tr><td><code>dyjCode</code></td><td>大赢家 互助码</td><td>非必须</td><td>未知/未知</td><td>仅支持单个互助码，，暂不支持多号。格式：redEnvelopeId@markedPin</td></tr><tr><td><code>TYT_PACKETID</code></td><td>推一推 互助码</td><td>非必须</td><td>未知/未知</td><td>仅支持单个互助码，暂不支持多号</td></tr><tr><td><code>MONEYTREE_SHARECODES</code></td><td>摇钱树 互助码</td><td>非必须</td><td>未知/未知</td><td>填写规则和上面类似，或见下方<a href="https://github.com/lukesyy/jd_yun/blob/main/githubAction.md#%E4%BA%92%E5%8A%A9%E7%A0%81%E7%9A%84%E5%A1%AB%E5%86%99%E8%A7%84%E5%88%99">互助码的填写规则</a></td></tr></tbody></table><h3 id="控制脚本功能环境变量"><a href="#控制脚本功能环境变量" class="headerlink" title="控制脚本功能环境变量"></a>控制脚本功能环境变量</h3><table><thead><tr><th>Name</th><th>归属</th><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>JD_BEAN_STOP</code></td><td>京东多合一签到</td><td>非必须</td><td><code>jd_bean_sign.js</code>自定义延迟签到,单位毫秒.默认分批并发无延迟， 延迟作用于每个签到接口，如填入延迟则切换顺序签到(耗时较长)， 如需填写建议输入数字<code>1</code>，详见<a href="https://github.com/NobyDa/Script/blob/master/JD-DailyBonus/JD_DailyBonus.js#L93">此处说明</a></td></tr><tr><td><code>JD_BEAN_SIGN_STOP_NOTIFY</code></td><td>京东多合一签到</td><td>非必须</td><td><code>jd_bean_sign.js</code>脚本运行后不推送签到结果通知，默认推送，填<code>true</code>表示不发送通知</td></tr><tr><td><code>JD_BEAN_SIGN_NOTIFY_SIMPLE</code></td><td>京东多合一签到</td><td>非必须</td><td><code>jd_bean_sign.js</code>脚本运行后推送签到结果简洁版通知， 默认推送全部签到结果，填<code>true</code>表示推送简洁通知，<a href="https://github.com/lukesyy/jd_yun/blob/main/icon/bean_sign_simple.jpg">效果图</a></td></tr><tr><td><code>PET_NOTIFY_CONTROL</code></td><td>东东萌宠 推送开关</td><td>非必须</td><td>控制京东萌宠是否静默运行, <code>false</code>为否(发送推送通知消息),<code>true</code>为是(即：不发送推送通知消息)</td></tr><tr><td><code>FRUIT_NOTIFY_CONTROL</code></td><td>东东农场 推送开关</td><td>非必须</td><td>控制京东农场是否静默运行, <code>false</code>为否(发送推送通知消息),<code>true</code>为是(即：不发送推送通知消息)</td></tr><tr><td><code>JD_JOY_REWARD_NOTIFY</code></td><td>宠汪汪 兑换京豆推送开关</td><td>非必须</td><td>控制<code>jd_joy_reward.js</code>脚本是否静默运行, <code>false</code>为否(发送推送通知消息),<code>true</code>为是(即：不发送推送通知消息)</td></tr><tr><td><code>JOY_FEED_COUNT</code></td><td>宠汪汪喂食数量</td><td>非必须</td><td>控制<code>jd_joy_feedPets.js</code>脚本喂食数量,可以填的数字 10,20,40,80,其他数字不可.</td></tr><tr><td><code>JOY_HELP_FEED</code></td><td>宠汪汪帮好友喂食</td><td>非必须</td><td>控制<code>jd_joy_steal.js</code>脚本是否给好友喂食,<code>false</code>为否,<code>true</code>为是(给好友喂食)</td></tr><tr><td><code>JOY_RUN_FLAG</code></td><td>宠汪汪是否赛跑</td><td>非必须</td><td>控制<code>jd_joy.js</code>脚本是否参加赛跑(默认参加双人赛跑), <code>false</code>为否,<code>true</code>为是，脚本默认是<code>true</code></td></tr><tr><td><code>JOY_TEAM_LEVEL</code></td><td>宠汪汪 参加什么级别的赛跑</td><td>非必须</td><td>控制<code>jd_joy.js</code>脚本参加几人的赛跑,可选数字为<code>2</code>,<code>10</code>,<code>50</code>， 其中 2 代表参加双人 PK 赛，10 代表参加 10 人突围赛， 50 代表参加 50 人挑战赛(注：此项功能在<code>JOY_RUN_FLAG</code>为 true 的时候才生效)， 如若想设置不同账号参加不同类别的比赛则用&amp;区分即可(如下三个账号：<code>2&amp;10&amp;50</code>)</td></tr><tr><td><code>JOY_RUN_NOTIFY</code></td><td>宠汪汪 宠汪汪赛跑获胜后是否推送通知</td><td>非必须</td><td>控制<code>jd_joy.js</code>脚本宠汪汪赛跑获胜后是否推送通知， <code>false</code>为否(不推送通知消息),<code>true</code>为是(即：发送推送通知消息)</td></tr><tr><td><code>JOY_RUN_HELP_MYSELF</code></td><td>宠汪汪 赛跑自己账号内部互助</td><td>非必须</td><td>输入<code>true</code>为开启内部互助</td></tr><tr><td><code>JD_JOY_REWARD_NAME</code></td><td>宠汪汪 积分兑换多少京豆</td><td>非必须</td><td>目前可填值为<code>20</code>或者<code>500</code>,脚本默认<code>20</code>,<code>0</code>表示不兑换京豆</td></tr><tr><td><code>MARKET_COIN_TO_BEANS</code></td><td>东东超市 兑换京豆数量</td><td>非必须</td><td>控制<code>jd_blueCoin.js</code>兑换京豆数量, 可输入值为<code>20</code>或者<code>1000</code>的数字或者其他商品的名称,例如<code>碧浪洗衣凝珠</code></td></tr><tr><td><code>MARKET_REWARD_NOTIFY</code></td><td>东东超市 兑换奖品推送开关</td><td>非必须</td><td>控制<code>jd_blueCoin.js</code>兑换奖品成功后是否静默运行, <code>false</code>为否(发送推送通知消息),<code>true</code>为是(即：不发送推送通知消息)</td></tr><tr><td><code>JOIN_PK_TEAM</code></td><td>东东超市 自动参加 PK 队伍</td><td>非必须</td><td>每次 pk 活动参加作者创建的 pk 队伍,<code>true</code>表示参加,<code>false</code>表示不参加</td></tr><tr><td><code>SUPERMARKET_LOTTERY</code></td><td>东东超市抽奖</td><td>非必须</td><td>每天运行脚本是否使用金币去抽奖,<code>true</code>表示抽奖,<code>false</code>表示不抽奖</td></tr><tr><td><code>FRUIT_BEAN_CARD</code></td><td>农场 使用水滴换豆卡</td><td>非必须</td><td>农场使用水滴换豆卡(如果出现限时活动时 100g 水换 20 豆,此时比浇水划算,推荐换豆), <code>true</code>表示换豆(不浇水),<code>false</code>表示不换豆(继续浇水),脚本默认是浇水</td></tr><tr><td><code>UN_SUBSCRIBES</code></td><td>jd_unsubscribe.js</td><td>非必须</td><td>共四个参数,换行隔开.四个参数分别表示 <code>取关商品数量</code>,<code>取关店铺数量</code>,<code>遇到此商品不再进行取关</code>,<code>遇到此店铺不再进行取关</code>，<a href="https://github.com/lukesyy/jd_yun/blob/main/githubAction.md#%E5%8F%96%E5%85%B3%E5%BA%97%E9%93%BAsecret%E7%9A%84%E8%AF%B4%E6%98%8E">具体使用往下看</a></td></tr><tr><td><code>JDJOY_HELPSELF</code></td><td>疯狂的 JOY 循环助力</td><td>非必须</td><td>疯狂的 JOY 循环助力，<code>true</code>表示循环助力,<code>false</code>表示不循环助力，默认不开启循环助力。</td></tr><tr><td><code>JDJOY_APPLYJDBEAN</code></td><td>疯狂的 JOY 京豆兑换</td><td>非必须</td><td>疯狂的 JOY 京豆兑换，目前最小值为 2000 京豆(详情请查看活动页面-提现京豆)， 默认数字<code>0</code>不开启京豆兑换。</td></tr><tr><td><code>BUY_JOY_LEVEL</code></td><td>疯狂的 JOY 购买 joy 等级</td><td>非必须</td><td>疯狂的 JOY 自动购买什么等级的 JOY</td></tr><tr><td><code>MONEY_TREE_SELL_FRUIT</code></td><td>摇钱树 是否卖出金果</td><td>非必须</td><td>控制摇钱树脚本是否自动卖出金果兑换成金币，<code>true</code>卖出，<code>false</code>不卖出，默认<code>false</code></td></tr><tr><td><code>FACTORAY_WANTPRODUCT_NAME</code></td><td>东东工厂 心仪商品</td><td>非必须</td><td>提供心仪商品名称(请尽量填写完整和别的商品有区分度)，达到条件后兑换， 如不提供则会兑换当前所选商品</td></tr><tr><td><code>DREAMFACTORY_FORBID_ACCOUNT</code></td><td>京喜工厂 控制哪个京东账号不运行此脚本</td><td>非必须</td><td>输入<code>1</code>代表第一个京东账号不运行，多个使用<code>&amp;</code>连接，例：<code>1&amp;3</code>代表账号 1 和账号 3 不运行京喜工厂脚本，注：输入<code>0</code>，代表全部账号不运行京喜工厂脚本</td></tr><tr><td><code>JDFACTORY_FORBID_ACCOUNT</code></td><td>东东工厂 控制哪个京东账号不运行此脚本</td><td>非必须</td><td>输入<code>1</code>代表第一个京东账号不运行，多个使用<code>&amp;</code>连接，例：<code>1&amp;3</code>代表账号 1 和账号 3 不运行东东工厂脚本，注：输入<code>0</code>，代表全部账号不运行东东工厂脚本</td></tr><tr><td><code>CFD_NOTIFY_CONTROL</code></td><td>京喜财富岛 控制是否运行脚本后通知</td><td>非必须</td><td>输入<code>true</code>为通知,不填则为不通知</td></tr><tr><td><code>JD_JOY_PARK</code></td><td>汪汪乐园 控制是否运行此脚本,默认是</td><td>非必须</td><td>输入<code>false</code>为不运行</td></tr><tr><td><code>JD_TRY</code></td><td>京东试用 控制是否运行此脚本,默认否</td><td>非必须</td><td>输入<code>true</code>为运行</td></tr><tr><td><code>NOT_RUN</code></td><td>禁止运行某脚本 控制是否运行此脚本</td><td>非必须</td><td>输入<code>对应脚本名称，多个脚本用&amp;连接</code></td></tr></tbody></table><h3 id="互助码的填写规则"><a href="#互助码的填写规则" class="headerlink" title="互助码的填写规则"></a>互助码的填写规则</h3><blockquote><p>互助码如何获取：运行相应脚本后，在日志里面可以找到。</p></blockquote><p>同一个京东账号的好友互助码用@隔开,不同京东账号互助码用&amp;或者换行隔开,下面给一个文字示例和具体互助码示例说明</p><p>两个账号各两个互助码的文字示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">京东账号1的shareCode1@京东账号1的shareCode2&amp;京东账号2的shareCode1@京东账号2的shareCode2</span><br></pre></td></tr></table></figure><p>两个账号各两个互助码的真实示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0a74407df5df4fa99672a037eec61f7e@dbb21614667246fabcfd9685b6f448f3&amp;6fbd26cc27ac44d6a7fed34092453f77@61ff5c624949454aa88561f2cd721bf6&amp;6fbd26cc27ac44d6a7fed34092453f77@61ff5c624949454aa88561f2cd721bf6</span><br></pre></td></tr></table></figure><h3 id="取关店铺-secret-的说明"><a href="#取关店铺-secret-的说明" class="headerlink" title="取关店铺 secret 的说明"></a>取关店铺 secret 的说明</h3><blockquote><p>secret 依次是<code>取关商品数</code>,<code>取关店铺数</code>,<code>遇到此商品不再进行取关</code>,<code>遇到此店铺不再进行取关</code></p></blockquote><p>例如我要取关 <code>100</code>个商品，<code>100</code>个店铺，商品遇到商品关键字 <code>iPhone12</code> 停止取关，店铺遇到 <code>Apple京东自营旗舰店</code> 不再取关 则使用<code>换行</code>或者<code>&amp;</code>隔开即可, 下面给出换行隔开示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">100</span><br><span class="line">iPhone12</span><br><span class="line">Apple京东自营旗舰店</span><br></pre></td></tr></table></figure><p>下面给出<code>&amp;</code>符号隔开示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100&amp;100&amp;iPhone12&amp;Apple京东自营旗舰店</span><br></pre></td></tr></table></figure><h3 id="关于脚本推送通知频率"><a href="#关于脚本推送通知频率" class="headerlink" title="关于脚本推送通知频率"></a>关于脚本推送通知频率</h3><blockquote><p>如果你填写了推送通知方式中的某一种通知所需环境变量，那么脚本通知情况如下：</p></blockquote><blockquote><p>目前默认只有 jd_fruit.js,jd_pet.js,jd_bean_sign.js,jd_bean_change.js,jd_jxnc.js 这些脚本(默认)每次运行后都通知</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其余的脚本平常运行都是不通知，只有在京东cookie失效以及达到部分条件后，才会推送通知</span><br></pre></td></tr></table></figure><h1 id="部署方式-2：青龙面板"><a href="#部署方式-2：青龙面板" class="headerlink" title="部署方式 2：青龙面板"></a>部署方式 2：青龙面板</h1><p>如果本教程看不懂或者操作出现问题，证明您的计算机专业知识并不支持本文章的搭建操作。</p><h3 id="第一步-购买云服务器"><a href="#第一步-购买云服务器" class="headerlink" title="第一步 购买云服务器"></a>第一步 购买云服务器</h3><p>个人推荐阿里云服务器 1 核 2G 即可 搞活动一年一百来块钱 系统选择 CentOs 8 （CentOs 8 自带 dnf 命令）等待配置完成。</p><p>百度搜索 Finalshell 下载安装好。在 finalshell 新建连接 选择 SSH 连接。成功连接上如图</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109171516078.png"><br><strong>接下来在命令窗口，一条一条输入指令，输入完一条指令后需要等待指令操作完成再输入另外一条指令</strong><br>首先安装 docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo yum check-update</span><br><span class="line">curl -fsSL https://get.docker.com/ | sh</span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl status docker</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><p>安装完成后配置青龙面板</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit \</span><br><span class="line">  --name QL \</span><br><span class="line">  --hostname QL \</span><br><span class="line">  --restart always \</span><br><span class="line">  -p 5700:5700 \</span><br><span class="line">  -v <span class="variable">$PWD</span>/QL/config:/ql/config \</span><br><span class="line">  -v <span class="variable">$PWD</span>/QL/<span class="built_in">log</span>:/ql/<span class="built_in">log</span> \</span><br><span class="line">  -v <span class="variable">$PWD</span>/QL/db:/ql/db \</span><br><span class="line">  -v <span class="variable">$PWD</span>/QL/scripts:/ql/scripts \</span><br><span class="line">  -v <span class="variable">$PWD</span>/QL/jbot:/ql/jbot \</span><br><span class="line">  whyour/qinglong:latest</span><br></pre></td></tr></table></figure><p>等待一段时间后，在浏览器输入 ip:5700 即可登录青龙面板<br>用户名为 admin 密码是 adminadmin</p><h3 id="重置密码"><a href="#重置密码" class="headerlink" title="重置密码"></a>重置密码</h3><p>登录成功后，在/root/QL/config 中找到 auth.json<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202109171517130.png" alt="image-20210917151736914"><br>打开文件查看已重置的密码 登录即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;前段时间在某论坛上看到关于京东签到脚本的实现方式，于是就进行了记录部署过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;tip warning&quot;&gt;&lt;p&gt;任何脚本都是有风险的，实践之前请注意，京东 cokies 代表的即是你本人，不要</summary>
      
    
    
    
    
    <category term="薅羊毛" scheme="https://qwq3.top/tags/%E8%96%85%E7%BE%8A%E6%AF%9B/"/>
    
  </entry>
  
  <entry>
    <title>完全搞懂this的指向</title>
    <link href="https://qwq3.top/posts/222.html"/>
    <id>https://qwq3.top/posts/222.html</id>
    <published>2021-07-14T19:45:21.000Z</published>
    <updated>2021-11-18T04:02:22.742Z</updated>
    
    <content type="html"><![CDATA[<p>在此感谢coderwhy老师，嘿嘿</p><blockquote><p>this是JavaScript中的一个关键字，但是又一个相对比较特别的关键字，不像function、var、for、if这些关键字一样，可以很清楚的搞清楚它到底是如何使用的。</p><p>this会在执行上下文中绑定一个对象，但是是根据什么条件绑定的呢？在不同的执行条件下会绑定不同的对象，这也是让人捉摸不定的地方。</p><p>这一次，我们一起来彻底搞定this到底是如何绑定的吧！</p></blockquote><h2 id="一-理解this"><a href="#一-理解this" class="headerlink" title="一. 理解this"></a>一. 理解this</h2><h3 id="1-1-为什么使用this"><a href="#1-1-为什么使用this" class="headerlink" title="1.1. 为什么使用this"></a>1.1. 为什么使用this</h3><p>在常见的编程语言中，几乎都有this这个关键字（Objective-C中使用的是self），但是JavaScript中的this和常见的面向对象语言中的this不太一样：</p><ul><li>常见面向对象的编程语言中，比如Java、C++、Swift、Dart等等一系列语言中，this通常只会出现在<code>类的方法</code>中。</li><li>也就是你需要有一个类，类中的方法（特别是实例方法）中，this代表的是当前调用对象。</li><li>但是JavaScript中的this更加灵活，无论是它出现的位置还是它代表的含义。</li></ul><p>使用this有什么意义呢？下面的代码中，我们通过对象字面量创建出来一个对象，当我们调用对象的方法时，希望将对象的名称一起进行打印。</p><p>如果没有this，那么我们的代码会是下面的写法：</p><ul><li>在方法中，为了能够获取到name名称，必须通过obj的引用（变量名称）来获取。</li><li>但是这样做有一个很大的弊端：如果我将obj的名称换成了info，那么所有的方法中的obj都需要换成info。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;violet&quot;</span>,</span><br><span class="line">  running: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.name + <span class="string">&quot; running&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  eating: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.name + <span class="string">&quot; eating&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  studying: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.name + <span class="string">&quot; studying&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，上面的代码，在实际开发中，我们都会使用this来进行优化：</p><ul><li>当我们通过obj去调用running、eating、studying这些方法时，this就是指向的obj对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;violet&quot;</span>,</span><br><span class="line">  running: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot; running&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  eating: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot; eating&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  studying: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&quot; studying&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们会发现，在某些函数或者方法的编写中，this可以让我们更加便捷的方式来引用对象，在进行一些API设计时，代码更加的简洁和易于复用。</p><p>当然，上面只是应用this的一个场景而已，开发中使用到this的场景到处都是，这也是为什么它不容易理解的原因。</p><h3 id="1-2-this指向什么"><a href="#1-2-this指向什么" class="headerlink" title="1.2. this指向什么"></a>1.2. this指向什么</h3><p>我们先说一个最简单的，this在全局作用域下指向什么？</p><ul><li>这个问题非常容易回答，在浏览器中测试就是指向window</li><li>所以，在全局作用域下，我们可以认为this就是指向的window</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;violet&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// violet</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name); <span class="comment">// violet</span></span><br></pre></td></tr></table></figure><p>但是，开发中很少直接在全局作用域下去使用this，通常都是在<strong>函数中使用</strong>。</p><p>所有的函数在被调用时，都会创建一个执行上下文：</p><ul><li>这个上下文中记录着函数的调用栈、函数的调用方式、传入的参数信息等；</li><li>this也是其中的一个属性；</li></ul><p>我们先来看一个让人困惑的问题：</p><ul><li>定义一个函数，我们采用三种不同的方式对它进行调用，它产生了三种不同的结果</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.调用方式一: 直接调用</span></span><br><span class="line">foo(); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.调用方式二: 将foo放到一个对象中,再调用</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;violet&quot;</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo() <span class="comment">// obj对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.调用方式三: 通过call/apply调用</span></span><br><span class="line">foo.call(<span class="string">&quot;abc&quot;</span>); <span class="comment">// String &#123;&quot;abc&quot;&#125;对象</span></span><br></pre></td></tr></table></figure><p>上面的案例可以给我们什么样的启示呢？</p><ul><li>1.函数在调用时，JavaScript会默认给this绑定一个值；</li><li>2.this的绑定和定义的位置（编写的位置）没有关系；</li><li>3.this的绑定和调用方式以及调用的位置有关系；</li><li>4.this是在运行时被绑定的；</li></ul><p>那么this到底是怎么样的绑定规则呢？一起来学习一下吧</p><h2 id="二-this绑定规则"><a href="#二-this绑定规则" class="headerlink" title="二. this绑定规则"></a>二. this绑定规则</h2><blockquote><p>我们现在已经知道this无非就是在函数调用时被绑定的一个对象，我们就需要知道它在不同的场景下的绑定规则即可。</p></blockquote><h3 id="2-1-默认绑定"><a href="#2-1-默认绑定" class="headerlink" title="2.1. 默认绑定"></a>2.1. 默认绑定</h3><p>什么情况下使用默认绑定呢？独立函数调用。</p><ul><li>独立的函数调用我们可以理解成函数没有被绑定到某个对象上进行调用；</li></ul><p><strong>案例一：普通函数调用</strong></p><ul><li>该函数直接被调用，并没有进行任何的对象关联；</li><li>这种独立的函数调用会使用默认绑定，通常默认绑定时，函数中的this指向全局对象（window）；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p><strong>案例二：函数调用链（一个函数又调用另外一个函数）</strong></p><ul><li>所有的函数调用都没有被绑定到某个对象上；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.案例二:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">  test2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">  test3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line">test1();</span><br></pre></td></tr></table></figure><p><strong>案例三：将函数作为参数，传入到另一个函数中</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  func()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(bar);</span><br></pre></td></tr></table></figure><p>我们对案例进行一些修改，考虑一下打印结果是否会发生变化：</p><ul><li>这里的结果依然是window，为什么呢？</li><li>原因非常简单，在真正函数调用的位置，并没有进行任何的对象绑定，只是一个独立函数的调用；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  func()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;violet&quot;</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(obj.bar);</span><br></pre></td></tr></table></figure><h3 id="2-2-隐式绑定"><a href="#2-2-隐式绑定" class="headerlink" title="2.2. 隐式绑定"></a>2.2. 隐式绑定</h3><p>另外一种比较常见的调用方式是通过某个对象进行调用的：</p><ul><li>也就是它的调用位置中，是通过某个对象发起的函数调用。</li></ul><p><strong>案例一：通过对象调用函数</strong></p><ul><li>foo的调用位置是obj.foo()方式进行调用的</li><li>那么foo调用时this会隐式的被绑定到obj对象上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; obj对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &quot;violet&quot;,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure><p><strong>案例二：案例一的变化</strong></p><ul><li>我们通过obj2又引用了obj1对象，再通过obj1对象调用foo函数；</li><li>那么foo调用的位置上其实还是obj1被绑定了this；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// obj对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">&quot;obj1&quot;</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  name: <span class="string">&quot;obj2&quot;</span>,</span><br><span class="line">  obj1: obj1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj2.obj1.foo();</span><br></pre></td></tr></table></figure><p><strong>案例三：隐式丢失</strong></p><ul><li>结果最终是window，为什么是window呢？</li><li>因为foo最终被调用的位置是bar，而bar在进行调用时没有绑定任何的对象，也就没有形成隐式绑定；</li><li>相当于是一种默认绑定；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">&quot;obj1&quot;</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 讲obj1的foo赋值给bar</span></span><br><span class="line"><span class="keyword">var</span> bar = obj1.foo;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><h3 id="2-3-显示绑定"><a href="#2-3-显示绑定" class="headerlink" title="2.3. 显示绑定"></a>2.3. 显示绑定</h3><p>隐式绑定有一个前提条件：</p><ul><li>必须在调用的<code>对象内部</code>有一个对函数的引用（比如一个属性）；</li><li>如果没有这样的引用，在进行调用时，会报找不到该函数的错误；</li><li>正是通过这个引用，间接的将this绑定到了这个对象上；</li></ul><p>如果我们不希望在 <strong>对象内部</strong> 包含这个函数的引用，同时又希望在这个对象上进行强制调用，该怎么做呢？</p><ul><li><p>JavaScript所有的函数都可以使用call和apply方法（这个和Prototype有关）。</p></li><li><ul><li>它们两个的区别这里不再展开；</li><li>其实非常简单，第一个参数是相同的，后面的参数，apply为数组，call为参数列表；</li></ul></li><li><p>这两个函数的第一个参数都要求是一个对象，这个对象的作用是什么呢？就是给this准备的。</p></li><li><p>在调用这个函数时，会将this绑定到这个传入的对象上。</p></li></ul><p>因为上面的过程，我们明确的绑定了this指向的对象，所以称之为 <strong>显示绑定</strong>。</p><h4 id="2-3-1-call、apply"><a href="#2-3-1-call、apply" class="headerlink" title="2.3.1. call、apply"></a>2.3.1. call、apply</h4><p><strong>通过call或者apply绑定this对象</strong></p><ul><li>显示绑定后，this就会明确的指向绑定的对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.call(window); &#x2F;&#x2F; window</span><br><span class="line">foo.call(&#123;name: &quot;violet&quot;&#125;); &#x2F;&#x2F; &#123;name: &quot;violet&quot;&#125;</span><br><span class="line">foo.call(123); &#x2F;&#x2F; Number对象,存放时123</span><br></pre></td></tr></table></figure><h4 id="2-3-2-bind函数"><a href="#2-3-2-bind函数" class="headerlink" title="2.3.2. bind函数"></a>2.3.2. bind函数</h4><p><strong>如果我们希望一个函数总是显示的绑定到一个对象上，可以怎么做呢？</strong></p><p>方案一：自己手写一个辅助函数（了解）</p><ul><li>我们手动写了一个bind的辅助函数</li><li>这个辅助函数的目的是在执行foo时，总是让它的this绑定到obj对象上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &quot;violet&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bind(func, obj) &#123;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    return func.apply(obj, arguments);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar &#x3D; bind(foo, obj);</span><br><span class="line"></span><br><span class="line">bar(); &#x2F;&#x2F; obj对象</span><br><span class="line">bar(); &#x2F;&#x2F; obj对象</span><br><span class="line">bar(); &#x2F;&#x2F; obj对象</span><br></pre></td></tr></table></figure><p>方案二：使用Function.prototype.bind</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &quot;violet&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar &#x3D; foo.bind(obj);</span><br><span class="line"></span><br><span class="line">bar(); &#x2F;&#x2F; obj对象</span><br><span class="line">bar(); &#x2F;&#x2F; obj对象</span><br><span class="line">bar(); &#x2F;&#x2F; obj对象</span><br></pre></td></tr></table></figure><h4 id="2-3-3-内置函数"><a href="#2-3-3-内置函数" class="headerlink" title="2.3.3. 内置函数"></a>2.3.3. 内置函数</h4><p>有些时候，我们会调用一些JavaScript的内置函数，或者一些第三方库中的内置函数。</p><ul><li>这些内置函数会要求我们传入另外一个函数；</li><li>我们自己并不会显示的调用这些函数，而且JavaScript内部或者第三方库内部会帮助我们执行；</li><li>这些函数中的this又是如何绑定的呢？</li></ul><p><strong>案例一：setTimeout</strong></p><ul><li>setTimeout中会传入一个函数，这个函数中的this通常是window</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; window</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure><p>为什么这里是window呢？</p><ul><li>这个和setTimeout源码的内部调用有关；</li><li>setTimeout内部是通过apply进行绑定的this对象，并且绑定的是全局对象；</li></ul><p><strong>案例二：数组的forEach</strong></p><p>数组有一个高阶函数forEach，用于函数的遍历：</p><ul><li>在forEach中传入的函数打印的也是Window对象；</li><li>这是因为默认情况下传入的函数是自动调用函数（默认绑定）；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var names &#x3D; [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;];</span><br><span class="line">names.forEach(function(item) &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; 三次window</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们是否可以改变该函数的this指向呢？</p><p><img src= "/img/loading.gif" data-lazy-src="image/640" alt="图片">forEach参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var names &#x3D; [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;];</span><br><span class="line">var obj &#x3D; &#123;name: &quot;violet&quot;&#125;;</span><br><span class="line">names.forEach(function(item) &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; 三次obj对象</span><br><span class="line">&#125;, obj);</span><br></pre></td></tr></table></figure><p><strong>案例三：div的点击</strong></p><p>如果我们有一个div元素：</p><ul><li>注意：省略了部分代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  .box &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>获取元素节点，并且监听点击：</p><ul><li>在点击事件的回调中，this指向谁呢？box对象；</li><li>这是因为在发生点击时，执行传入的回调函数被调用时，会将box对象绑定到该函数中；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var box &#x3D; document.querySelector(&quot;.box&quot;);</span><br><span class="line">box.onclick &#x3D; function() &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; box对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以传入到内置函数的回调函数this如何确定呢？</p><ul><li>某些内置的函数，我们很难确定它内部是如何调用传入的回调函数；</li><li>一方面可以通过分析源码来确定，另一方面我们可以通过经验（见多识广）来确定；</li><li>但是无论如何，通常都是我们之前讲过的规则来确定的；</li></ul><h3 id="2-4-new绑定"><a href="#2-4-new绑定" class="headerlink" title="2.4. new绑定"></a>2.4. new绑定</h3><p>JavaScript中的函数可以当做一个类的构造函数来使用，也就是使用new关键字。</p><p>使用new关键字来调用函数时，会执行如下的操作：</p><ul><li>1.创建一个全新的对象；</li><li>2.这个新对象会被执行Prototype连接；</li><li>3.这个新对象会绑定到函数调用的this上（this的绑定在这个步骤完成）；</li><li>4.如果函数没有返回其他对象，表达式会返回这个新对象；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建Person</span><br><span class="line">function Person(name) &#123;</span><br><span class="line">  console.log(this); &#x2F;&#x2F; Person &#123;&#125;</span><br><span class="line">  this.name &#x3D; name; &#x2F;&#x2F; Person &#123;name: &quot;violet&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p &#x3D; new Person(&quot;violet&quot;);</span><br><span class="line">console.log(p);</span><br></pre></td></tr></table></figure><h3 id="2-5-规则优先级"><a href="#2-5-规则优先级" class="headerlink" title="2.5. 规则优先级"></a>2.5. 规则优先级</h3><p>学习了四条规则，接下来开发中我们只需要去查找函数的调用应用了哪条规则即可，但是如果一个函数调用位置应用了多条规则，优先级谁更高呢？</p><p><strong>1.默认规则的优先级最低</strong></p><p>毫无疑问，默认规则的优先级是最低的，因为存在其他规则时，就会通过其他规则的方式来绑定this</p><p><strong>2.显示绑定优先级高于隐式绑定</strong></p><p>显示绑定和隐式绑定哪一个优先级更高呢？这个我们可以测试一下：</p><ul><li>结果是obj2，说明是显示绑定生效了</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">  name: &quot;obj1&quot;,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj2 &#x3D; &#123;</span><br><span class="line">  name: &quot;obj2&quot;,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 隐式绑定</span><br><span class="line">obj1.foo(); &#x2F;&#x2F; obj1</span><br><span class="line">obj2.foo(); &#x2F;&#x2F; obj2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 隐式绑定和显示绑定同时存在</span><br><span class="line">obj1.foo.call(obj2); &#x2F;&#x2F; obj2, 说明显式绑定优先级更高</span><br></pre></td></tr></table></figure><p><strong>3.new绑定优先级高于隐式绑定</strong></p><ul><li>结果是foo，说明是new绑定生效了</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &quot;violet&quot;,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new obj.foo(); &#x2F;&#x2F; foo对象, 说明new绑定优先级更高</span><br></pre></td></tr></table></figure><p><strong>4.new绑定优先级高于bind</strong></p><p>new绑定和call、apply是不允许同时使用的，所以不存在谁的优先级更高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &quot;obj&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var foo &#x3D; new foo.call(obj);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="image/640" alt="图片">new和call同时使用</p><p>但是new绑定是否可以和bind后的函数同时使用呢？可以</p><ul><li>结果显示为foo，那么说明是new绑定生效了</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &quot;obj&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; var foo &#x3D; new foo.call(obj);</span><br><span class="line">var bar &#x3D; foo.bind(obj);</span><br><span class="line">var foo &#x3D; new bar(); &#x2F;&#x2F; 打印foo, 说明使用的是new绑定</span><br></pre></td></tr></table></figure><p>优先级总结：</p><ul><li>new绑定 &gt; 显示绑定（bind）&gt; 隐式绑定 &gt; 默认绑定</li></ul><h2 id="三-this规则之外"><a href="#三-this规则之外" class="headerlink" title="三. this规则之外"></a>三. this规则之外</h2><blockquote><p>我们讲到的规则已经足以应付平时的开发，但是总有一些语法，超出了我们的规则之外。（神话故事和动漫中总是有类似这样的人物）</p></blockquote><h3 id="3-1-忽略显示绑定"><a href="#3-1-忽略显示绑定" class="headerlink" title="3.1. 忽略显示绑定"></a>3.1. 忽略显示绑定</h3><p>如果在显示绑定中，我们传入一个null或者undefined，那么这个显示绑定会被忽略，使用默认规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &quot;violet&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.call(obj); &#x2F;&#x2F; obj对象</span><br><span class="line">foo.call(null); &#x2F;&#x2F; window</span><br><span class="line">foo.call(undefined); &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">var bar &#x3D; foo.bind(null);</span><br><span class="line">bar(); &#x2F;&#x2F; window</span><br></pre></td></tr></table></figure><h3 id="3-2-间接函数引用"><a href="#3-2-间接函数引用" class="headerlink" title="3.2. 间接函数引用"></a>3.2. 间接函数引用</h3><p>另外一种情况，创建一个函数的 <code>间接引用</code>，这种情况使用默认绑定规则。</p><p>我们先来看下面的案例结果是什么？</p><ul><li>(num2 = num1)的结果是num1的值；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var num1 &#x3D; 100;</span><br><span class="line">var num2 &#x3D; 0;</span><br><span class="line">var result &#x3D; (num2 &#x3D; num1);</span><br><span class="line">console.log(result); &#x2F;&#x2F; 100</span><br></pre></td></tr></table></figure><p>我们来下面的函数赋值结果：</p><ul><li>赋值(obj2.foo = obj1.foo)的结果是foo函数；</li><li>foo函数被直接调用，那么是默认绑定；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">  name: &quot;obj1&quot;,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">var obj2 &#x3D; &#123;</span><br><span class="line">  name: &quot;obj2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.foo(); &#x2F;&#x2F; obj1对象</span><br><span class="line">(obj2.foo &#x3D; obj1.foo)();  &#x2F;&#x2F; window</span><br></pre></td></tr></table></figure><h3 id="3-3-ES6箭头函数"><a href="#3-3-ES6箭头函数" class="headerlink" title="3.3. ES6箭头函数"></a>3.3. ES6箭头函数</h3><p>在ES6中新增一个非常好用的函数类型：箭头函数</p><ul><li>这里不再具体介绍箭头函数的用法，可以自行学习。</li></ul><p>箭头函数不使用this的四种标准规则（也就是不绑定this），而是根据外层作用域来决定this。</p><p>我们来看一个模拟网络请求的案例：</p><ul><li>这里我使用setTimeout来模拟网络请求，请求到数据后如何可以存放到data中呢？</li><li>我们需要拿到obj对象，设置data；</li><li>但是直接拿到的this是window，我们需要在外层定义：<code>var _this = this</code></li><li>在setTimeout的回调函数中使用_this就代表了obj对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  data: [],</span><br><span class="line">  getData: function() &#123;</span><br><span class="line">    var _this &#x3D; this;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">      &#x2F;&#x2F; 模拟获取到的数据</span><br><span class="line">      var res &#x3D; [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;];</span><br><span class="line">      _this.data.push(...res);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getData();</span><br></pre></td></tr></table></figure><p>上面的代码在ES6之前是我们最常用的方式，从ES6开始，我们会使用箭头函数：</p><ul><li>为什么在setTimeout的回调函数中可以直接使用this呢？</li><li>因为箭头函数并不绑定this对象，那么this引用就会从上层作用域中找到对应的this</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  data: [],</span><br><span class="line">  getData: function() &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 模拟获取到的数据</span><br><span class="line">      var res &#x3D; [&quot;abc&quot;, &quot;cba&quot;, &quot;nba&quot;];</span><br><span class="line">      this.data.push(...res);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getData();</span><br></pre></td></tr></table></figure><p>思考：如果getData也是一个箭头函数，那么setTimeout中的回调函数中的this指向谁呢？</p><ul><li>答案是window；</li><li>依然是不断的从上层作用域找，那么找到了全局作用域；</li><li>在全局作用域内，this代表的就是window</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  data: [],</span><br><span class="line">  getData: () &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      console.log(this); &#x2F;&#x2F; window</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getData();</span><br></pre></td></tr></table></figure><h2 id="四-this面试题"><a href="#四-this面试题" class="headerlink" title="四. this面试题"></a>四. this面试题</h2><h3 id="4-1-面试题一："><a href="#4-1-面试题一：" class="headerlink" title="4.1. 面试题一："></a>4.1. 面试题一：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; &quot;window&quot;;</span><br><span class="line">var person &#x3D; &#123;</span><br><span class="line">  name: &quot;person&quot;,</span><br><span class="line">  sayName: function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">function sayName() &#123;</span><br><span class="line">  var sss &#x3D; person.sayName;</span><br><span class="line">  sss(); </span><br><span class="line">  person.sayName(); </span><br><span class="line">  (person.sayName)(); </span><br><span class="line">  (b &#x3D; person.sayName)(); </span><br><span class="line">&#125;</span><br><span class="line">sayName();</span><br></pre></td></tr></table></figure><p>这道面试题非常简单，无非就是绕一下，希望把面试者绕晕：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function sayName() &#123;</span><br><span class="line">  var sss &#x3D; person.sayName;</span><br><span class="line">  &#x2F;&#x2F; 独立函数调用，没有和任何对象关联</span><br><span class="line">  sss(); &#x2F;&#x2F; window</span><br><span class="line">  &#x2F;&#x2F; 关联</span><br><span class="line">  person.sayName(); &#x2F;&#x2F; person</span><br><span class="line">  (person.sayName)(); &#x2F;&#x2F; person</span><br><span class="line">  (b &#x3D; person.sayName)(); &#x2F;&#x2F; window</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-面试题二："><a href="#4-2-面试题二：" class="headerlink" title="4.2. 面试题二："></a>4.2. 面试题二：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; &#39;window&#39;</span><br><span class="line">var person1 &#x3D; &#123;</span><br><span class="line">  name: &#39;person1&#39;,</span><br><span class="line">  foo1: function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;,</span><br><span class="line">  foo2: () &#x3D;&gt; console.log(this.name),</span><br><span class="line">  foo3: function () &#123;</span><br><span class="line">    return function () &#123;</span><br><span class="line">      console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  foo4: function () &#123;</span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line">      console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person2 &#x3D; &#123; name: &#39;person2&#39; &#125;</span><br><span class="line"></span><br><span class="line">person1.foo1(); </span><br><span class="line">person1.foo1.call(person2); </span><br><span class="line"></span><br><span class="line">person1.foo2();</span><br><span class="line">person1.foo2.call(person2);</span><br><span class="line"></span><br><span class="line">person1.foo3()();</span><br><span class="line">person1.foo3.call(person2)();</span><br><span class="line">person1.foo3().call(person2);</span><br><span class="line"></span><br><span class="line">person1.foo4()();</span><br><span class="line">person1.foo4.call(person2)();</span><br><span class="line">person1.foo4().call(person2);</span><br></pre></td></tr></table></figure><p>下面是代码解析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 隐式绑定，肯定是person1</span><br><span class="line">person1.foo1(); &#x2F;&#x2F; person1</span><br><span class="line">&#x2F;&#x2F; 隐式绑定和显示绑定的结合，显示绑定生效，所以是person2</span><br><span class="line">person1.foo1.call(person2); &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo2()是一个箭头函数，不适用所有的规则</span><br><span class="line">person1.foo2() &#x2F;&#x2F; window</span><br><span class="line">&#x2F;&#x2F; foo2依然是箭头函数，不适用于显示绑定的规则</span><br><span class="line">person1.foo2.call(person2) &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取到foo3，但是调用位置是全局作用于下，所以是默认绑定window</span><br><span class="line">person1.foo3()() &#x2F;&#x2F; window</span><br><span class="line">&#x2F;&#x2F; foo3显示绑定到person2中</span><br><span class="line">&#x2F;&#x2F; 但是拿到的返回函数依然是在全局下调用，所以依然是window</span><br><span class="line">person1.foo3.call(person2)() &#x2F;&#x2F; window</span><br><span class="line">&#x2F;&#x2F; 拿到foo3返回的函数，通过显示绑定到person2中，所以是person2</span><br><span class="line">person1.foo3().call(person2) &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo4()的函数返回的是一个箭头函数</span><br><span class="line">&#x2F;&#x2F; 箭头函数的执行找上层作用域，是person1</span><br><span class="line">person1.foo4()() &#x2F;&#x2F; person1</span><br><span class="line">&#x2F;&#x2F; foo4()显示绑定到person2中，并且返回一个箭头函数</span><br><span class="line">&#x2F;&#x2F; 箭头函数找上层作用域，是person2</span><br><span class="line">person1.foo4.call(person2)() &#x2F;&#x2F; person2</span><br><span class="line">&#x2F;&#x2F; foo4返回的是箭头函数，箭头函数只看上层作用域</span><br><span class="line">person1.foo4().call(person2) &#x2F;&#x2F; person1</span><br></pre></td></tr></table></figure><h3 id="4-3-面试题三"><a href="#4-3-面试题三" class="headerlink" title="4.3. 面试题三:"></a>4.3. 面试题三:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; &#39;window&#39;</span><br><span class="line">function Person (name) &#123;</span><br><span class="line">  this.name &#x3D; name</span><br><span class="line">  this.foo1 &#x3D; function () &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;,</span><br><span class="line">  this.foo2 &#x3D; () &#x3D;&gt; console.log(this.name),</span><br><span class="line">  this.foo3 &#x3D; function () &#123;</span><br><span class="line">    return function () &#123;</span><br><span class="line">      console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  this.foo4 &#x3D; function () &#123;</span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line">      console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1 &#x3D; new Person(&#39;person1&#39;)</span><br><span class="line">var person2 &#x3D; new Person(&#39;person2&#39;)</span><br><span class="line"></span><br><span class="line">person1.foo1()</span><br><span class="line">person1.foo1.call(person2)</span><br><span class="line"></span><br><span class="line">person1.foo2()</span><br><span class="line">person1.foo2.call(person2)</span><br><span class="line"></span><br><span class="line">person1.foo3()()</span><br><span class="line">person1.foo3.call(person2)()</span><br><span class="line">person1.foo3().call(person2)</span><br><span class="line"></span><br><span class="line">person1.foo4()()</span><br><span class="line">person1.foo4.call(person2)()</span><br><span class="line">person1.foo4().call(person2)</span><br></pre></td></tr></table></figure><p>下面是代码解析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 隐式绑定</span><br><span class="line">person1.foo1() &#x2F;&#x2F; peron1</span><br><span class="line">&#x2F;&#x2F; 显示绑定优先级大于隐式绑定</span><br><span class="line">person1.foo1.call(person2) &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo是一个箭头函数，会找上层作用域中的this，那么就是person1</span><br><span class="line">person1.foo2() &#x2F;&#x2F; person1</span><br><span class="line">&#x2F;&#x2F; foo是一个箭头函数，使用call调用不会影响this的绑定，和上面一样向上层查找</span><br><span class="line">person1.foo2.call(person2) &#x2F;&#x2F; person1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用位置是全局直接调用，所以依然是window（默认绑定）</span><br><span class="line">person1.foo3()() &#x2F;&#x2F; window</span><br><span class="line">&#x2F;&#x2F; 最终还是拿到了foo3返回的函数，在全局直接调用（默认绑定）</span><br><span class="line">person1.foo3.call(person2)() &#x2F;&#x2F; window</span><br><span class="line">&#x2F;&#x2F; 拿到foo3返回的函数后，通过call绑定到person2中进行了调用</span><br><span class="line">person1.foo3().call(person2) &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foo4返回了箭头函数，和自身绑定没有关系，上层找到person1</span><br><span class="line">person1.foo4()() &#x2F;&#x2F; person1</span><br><span class="line">&#x2F;&#x2F; foo4调用时绑定了person2，返回的函数是箭头函数，调用时，找到了上层绑定的person2</span><br><span class="line">person1.foo4.call(person2)() &#x2F;&#x2F; person2</span><br><span class="line">&#x2F;&#x2F; foo4调用返回的箭头函数，和call调用没有关系，找到上层的person1</span><br><span class="line">person1.foo4().call(person2) &#x2F;&#x2F; person1</span><br></pre></td></tr></table></figure><h3 id="4-4-面试题四："><a href="#4-4-面试题四：" class="headerlink" title="4.4. 面试题四："></a>4.4. 面试题四：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; &#39;window&#39;</span><br><span class="line">function Person (name) &#123;</span><br><span class="line">  this.name &#x3D; name</span><br><span class="line">  this.obj &#x3D; &#123;</span><br><span class="line">    name: &#39;obj&#39;,</span><br><span class="line">    foo1: function () &#123;</span><br><span class="line">      return function () &#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    foo2: function () &#123;</span><br><span class="line">      return () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1 &#x3D; new Person(&#39;person1&#39;)</span><br><span class="line">var person2 &#x3D; new Person(&#39;person2&#39;)</span><br><span class="line"></span><br><span class="line">person1.obj.foo1()()</span><br><span class="line">person1.obj.foo1.call(person2)()</span><br><span class="line">person1.obj.foo1().call(person2)</span><br><span class="line"></span><br><span class="line">person1.obj.foo2()()</span><br><span class="line">person1.obj.foo2.call(person2)()</span><br><span class="line">person1.obj.foo2().call(person2)</span><br></pre></td></tr></table></figure><p>下面是代码解析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; obj.foo1()返回一个函数</span><br><span class="line">&#x2F;&#x2F; 这个函数在全局作用于下直接执行（默认绑定）</span><br><span class="line">person1.obj.foo1()() &#x2F;&#x2F; window</span><br><span class="line">&#x2F;&#x2F; 最终还是拿到一个返回的函数（虽然多了一步call的绑定）</span><br><span class="line">&#x2F;&#x2F; 这个函数在全局作用于下直接执行（默认绑定）</span><br><span class="line">person1.obj.foo1.call(person2)() &#x2F;&#x2F; window</span><br><span class="line">person1.obj.foo1().call(person2) &#x2F;&#x2F; person2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拿到foo2()的返回值，是一个箭头函数</span><br><span class="line">&#x2F;&#x2F; 箭头函数在执行时找上层作用域下的this，就是obj</span><br><span class="line">person1.obj.foo2()() &#x2F;&#x2F; obj</span><br><span class="line">&#x2F;&#x2F; foo2()的返回值，依然是箭头函数，但是在执行foo2时绑定了person2</span><br><span class="line">&#x2F;&#x2F; 箭头函数在执行时找上层作用域下的this，找到的是person2</span><br><span class="line">person1.obj.foo2.call(person2)() &#x2F;&#x2F; person2</span><br><span class="line">&#x2F;&#x2F; foo2()的返回值，依然是箭头函数</span><br><span class="line">&#x2F;&#x2F; 箭头函数通过call调用是不会绑定this，所以找上层作用域下的this是obj</span><br><span class="line">person1.obj.foo2().call(person2) &#x2F;&#x2F; obj</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在此感谢coderwhy老师，嘿嘿&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;this是JavaScript中的一个关键字，但是又一个相对比较特别的关键字，不像function、var、for、if这些关键字一样，可以很清楚的搞清楚它到底是如何使用的。&lt;/p&gt;
&lt;p&gt;this</summary>
      
    
    
    
    
    <category term="JS" scheme="https://qwq3.top/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>基础面试题01</title>
    <link href="https://qwq3.top/posts/ff46.html"/>
    <id>https://qwq3.top/posts/ff46.html</id>
    <published>2021-06-29T09:02:13.000Z</published>
    <updated>2021-11-18T04:02:22.738Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>浏览器里，从用户输入url到用户看到页面结果的过程，发生了什么？</p></blockquote><p><strong>1、域名解析</strong></p><p>域名解析的过程：</p><p>　　（1）查询浏览器自身DNS缓存</p><p>　　（2）若上面没有找到，则搜索操作系统自身的DNS缓存</p><p>　　（3）若上面没有找到，则尝试读取hosts文件</p><p>　　（4）若上面没有找到，向本地配置的首选DNS服务器发送请求</p><p>　　（5）win系统 若上面没有找到，操作系统查找NetBIOS name cache</p><p>　　（6）win系统 若上面没有找到，查询wins服务器</p><p>　　（7）win系统 若上面没有找到，广播查找</p><p>　　（8）win系统 若上面没有找到，读取LMHOSTS文件</p><p>　若以上都没有找到，解析失败。</p><p><strong>2、TCP三次握手</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/1015311-20181018171556538-1046816086.png" alt="img"></p><p><strong>3、浏览器向服务器发送http请求</strong></p><p>一旦建立了TCP连接，web浏览器就会向web服务器发送请求命令。例如：</p><p>GET/sample/hello.jsp HTTP/1.1</p><p><strong>4、浏览器发送请求头信息</strong></p><p>　　浏览器发送请求命令之后，还要以头信息的形式向web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。</p><p><strong>5、服务器处理请求</strong></p><p>　　服务器收到http请求，确定执行什么（asp.net、php、ruby、java等）来处理他。读取参数并进行逻辑操作后，生成指定的数据。</p><p><strong>6、服务器做出应答</strong></p><p>　　客户机向服务器发出请求后，服务器会向客户机回送应答，HTTP/1.1 200 OK，应答的第一部分是协议的版本号和应答状态码</p><p><strong>7、服务器发送应答头信息</strong></p><p>　　正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</p><p><strong>8、服务器发送数据</strong></p><p>　　web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发生到此为结束，接着，它就以Content-Type 应答头信息所描述的格式发送用户所请求的实际数据。</p><p><strong>9、tcp连接关闭</strong></p><p>　　一般情况下，一旦web服务器向浏览器发送了请求数据，它就要关闭tcp连接，然后如果浏览器或者服务器在其头信息加入了这行代码：</p><p>　　Connection keep-alive</p><p>　　TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p><h1 id="浏览器渲染页面的过程"><a href="#浏览器渲染页面的过程" class="headerlink" title="浏览器渲染页面的过程"></a>浏览器渲染页面的过程</h1><ul><li>根据 <code>HTML</code> 结构生成 <code>DOM Tree</code></li><li>根据 <code>CSS</code> 生成 <code>CSSOM</code></li><li>将 <code>DOM</code> 和 <code>CSSOM</code> 整合形成 <code>RenderTree</code></li><li>根据 <code>RenderTree</code> 开始渲染和展示</li><li>遇到 <code>&lt;script&gt;</code> 时，会执行并阻塞渲染，因为 Javascript 代码有权利改变<code>DOM</code>树</li></ul><h2 id="浏览器如何渲染网页"><a href="#浏览器如何渲染网页" class="headerlink" title="浏览器如何渲染网页"></a>浏览器如何渲染网页</h2><p>要了解浏览器渲染页面的过程，首先得知道一个名词——关键渲染路径。关键渲染路径是指浏览器从最初接收请求来的HTML、CSS、javascript等资源，然后解析、构建树、渲染布局、绘制，最后呈现给用户能看到的界面这整个过程。</p><p>用户看到页面实际上可以分为两个阶段：页面内容加载完成和页面资源加载完成，分别对应于<code>DOMContentLoaded</code>和<code>Load</code>。</p><ul><li><code>DOMContentLoaded</code>事件触发时，仅当DOM加载完成，不包括样式表，图片等</li><li><code>load</code>事件触发时，页面上所有的DOM，样式表，脚本，图片都已加载完成</li></ul><p>浏览器渲染的过程主要包括以下五步：</p><ol><li>浏览器将获取的HTML文档解析成DOM树。</li><li>处理CSS标记，构成层叠样式表模型CSSOM(CSS Object Model)。</li><li>将DOM和CSSOM合并为渲染树(<code>rendering tree</code>)，代表一系列将被渲染的对象。</li><li>渲染树的每个元素包含的内容都是计算过的，它被称之为布局<code>layout</code>。浏览器使用一种流式处理的方法，只需要一次绘制操作就可以布局所有的元素。</li><li>将渲染树的各个节点绘制到屏幕上，这一步被称为绘制<code>painting</code>。</li></ol><p>需要注意的是，以上五个步骤并不一定一次性顺序完成，比如DOM或CSSOM被修改时，亦或是哪个过程会重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。而在实际情况中，JavaScript和CSS的某些操作往往会多次修改DOM或者CSSOM。</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/3534846-00ef9f3d405462ef.webp"></p><p>webkit渲染引擎流程</p><h2 id="浏览器渲染网页的具体流程"><a href="#浏览器渲染网页的具体流程" class="headerlink" title="浏览器渲染网页的具体流程"></a>浏览器渲染网页的具体流程</h2><h3 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h3><p>当浏览器接收到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树。<br> 需要注意以下几点：</p><ul><li>DOM树在构建的过程中可能会被CSS和JS的加载而执行阻塞</li><li><code>display:none</code>的元素也会在DOM树中</li><li>注释也会在DOM树中</li><li><code>script</code>标签会在DOM树中</li></ul><p>无论是DOM还是CSSOM，都是要经过<code>Bytes→characters→tokens→nodes→object model</code>这个过程。</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/3534846-770586311bb543d6.webp" alt="3534846-770586311bb543d6"></p><p>当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。</p><h3 id="构建CSSOM规则树"><a href="#构建CSSOM规则树" class="headerlink" title="构建CSSOM规则树"></a>构建CSSOM规则树</h3><p>浏览器解析CSS文件并生成CSSOM，每个CSS文件都被分析成一个StyleSheet对象，每个对象都包含CSS规则。CSS规则对象包含对应于CSS语法的选择器和声明对象以及其他对象。<br> 在这个过程需要注意的是：</p><ul><li>CSS解析可以与DOM解析同时进行。</li><li>CSS解析与<code>script</code>的执行互斥 。</li><li>在Webkit内核中进行了<code>script</code>执行优化，只有在JS访问CSS时才会发生互斥。</li></ul><h3 id="构建渲染树（Render-Tree）"><a href="#构建渲染树（Render-Tree）" class="headerlink" title="构建渲染树（Render Tree）"></a>构建渲染树（Render Tree）</h3><p>通过DOM树和CSS规则树，浏览器就可以通过它两构建渲染树了。浏览器会先从DOM树的根节点开始遍历每个可见节点，然后对每个可见节点找到适配的CSS样式规则并应用。<br> 有以下几点需要注意：</p><ul><li>Render Tree和DOM Tree不完全对应</li><li><code>display: none</code>的元素不在Render Tree中</li><li><code>visibility: hidden</code>的元素在Render Tree中</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/3534846-610f4ac0a1ad3401.webp"></p><p>渲染树生成后，还是没有办法渲染到屏幕上，渲染到屏幕需要得到各个节点的位置信息，这就需要布局（Layout）的处理了。</p><h3 id="渲染树布局-layout-of-the-render-tree"><a href="#渲染树布局-layout-of-the-render-tree" class="headerlink" title="渲染树布局(layout of the render tree)"></a>渲染树布局(layout of the render tree)</h3><p>布局阶段会从渲染树的根节点开始遍历，由于渲染树的每个节点都是一个Render Object对象，包含宽高，位置，背景色等样式信息。所以浏览器就可以通过这些样式信息来确定每个节点对象在页面上的确切大小和位置，布局阶段的输出就是我们常说的盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。需要注意的是：</p><ul><li><code>float</code>元素，<code>absoulte</code>元素，<code>fixed</code>元素会发生位置偏移。</li><li>我们常说的脱离文档流，其实就是脱离Render Tree。</li></ul><h3 id="渲染树绘制（Painting-the-render-tree）"><a href="#渲染树绘制（Painting-the-render-tree）" class="headerlink" title="渲染树绘制（Painting the render tree）"></a>渲染树绘制（Painting the render tree）</h3><p>在绘制阶段，浏览器会遍历渲染树，调用渲染器的<code>paint()</code>方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。</p><h2 id="浏览器渲染网页的那些事儿"><a href="#浏览器渲染网页的那些事儿" class="headerlink" title="浏览器渲染网页的那些事儿"></a>浏览器渲染网页的那些事儿</h2><h3 id="浏览器主要组件结构"><a href="#浏览器主要组件结构" class="headerlink" title="浏览器主要组件结构"></a>浏览器主要组件结构</h3><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/3534846-379346e21d0d5c84.webp"></p><p>浏览器主要组件</p><p>渲染引擎主要有两个：webkit和Gecko<br> Firefox使用Geoko，Mozilla自主研发的渲染引擎。Safari和Chrome都使用webkit。Webkit是一款开源渲染引擎，它本来是为linux平台研发的，后来由Apple移植到Mac及Windows上。<br> 虽然主流浏览器渲染过程叫法有区别，但是主要流程还是相同的。</p><h3 id="渲染阻塞"><a href="#渲染阻塞" class="headerlink" title="渲染阻塞"></a>渲染阻塞</h3><p>JS可以操作DOM来修改DOM结构，可以操作CSSOM来修改节点样式，这就导致了浏览器在遇到<code>&lt;script&gt;</code>标签时，DOM构建将暂停，直至脚本完成执行，然后继续构建DOM。如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。现在可以在<code>script</code>标签上增加属性<code>defer</code>或者<code>async</code>。脚本解析会将脚本中改变DOM和CSS的地方分别解析出来，追加到DOM树和CSSOM规则树上。</p><p>每次去执行JavaScript脚本都会严重地阻塞DOM树的构建，如果JavaScript脚本还操作了CSSOM，而正好这个CSSOM还没有下载和构建，浏览器甚至会延迟脚本执行和构建DOM，直至完成其CSSOM的下载和构建。所以，<code>script</code>标签的位置很重要。</p><p>JS阻塞了构建DOM树，也阻塞了其后的构建CSSOM规则树，整个解析进程必须等待JS的执行完成才能够继续，这就是所谓的JS阻塞页面。</p><p>由于CSSOM负责存储渲染信息，浏览器就必须保证在合成渲染树之前，CSSOM是完备的，这种完备是指所有的CSS（内联、内部和外部）都已经下载完，并解析完，只有CSSOM和DOM的解析完全结束，浏览器才会进入下一步的渲染，这就是CSS阻塞渲染。</p><p>CSS阻塞渲染意味着，在CSSOM完备前，页面将一直处理白屏状态，这就是为什么样式放在<code>head</code>中，仅仅是为了更快的解析CSS，保证更快的首次渲染。</p><p>需要注意的是，即便你没有给页面任何的样式声明，CSSOM依然会生成，默认生成的CSSOM自带浏览器默认样式。</p><p>当解析HTML的时候，会把新来的元素插入DOM树里面，同时去查找CSS，然后把对应的样式规则应用到元素上，查找样式表是按照从右到左的顺序去匹配的。</p><p>例如：<code>div p &#123;font-size: 16px&#125;</code>，会先寻找所有<code>p</code>标签并判断它的父标签是否为<code>div</code>之后才会决定要不要采用这个样式进行渲染）。<br> 所以，我们平时写CSS时，尽量用<code>id</code>和<code>class</code>，千万不要过渡层叠。</p><h4 id="回流和重绘（reflow和repaint）"><a href="#回流和重绘（reflow和repaint）" class="headerlink" title="回流和重绘（reflow和repaint）"></a>回流和重绘（reflow和repaint）</h4><p>我们都知道HTML默认是流式布局的，但CSS和JS会打破这种布局，改变DOM的外观样式以及大小和位置。因此我们就需要知道两个概念：<code>replaint</code>和<code>reflow</code>。</p><h3 id="reflow（回流）"><a href="#reflow（回流）" class="headerlink" title="reflow（回流）"></a>reflow（回流）</h3><p>当浏览器发现布局发生了变化，这个时候就需要倒回去重新渲染，这个回退的过程叫<code>reflow</code>。<code>reflow</code>会从<code>html</code>这个<code>root frame</code>开始递归往下，依次计算所有的结点几何尺寸和位置，以确认是渲染树的一部分发生变化还是整个渲染树。<code>reflow</code>几乎是无法避免的，因为只要用户进行交互操作，就势必会发生页面的一部分的重新渲染，且通常我们也无法预估浏览器到底会<code>reflow</code>哪一部分的代码，因为他们会相互影响。</p><h3 id="repaint（重绘）"><a href="#repaint（重绘）" class="headerlink" title="repaint（重绘）"></a>repaint（重绘）</h3><p><code>repaint</code>则是当我们改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸和位置没有发生改变。</p><p>需要注意的是，<code>display:none</code>会触发<code>reflow</code>，而<code>visibility: hidden</code>属性则并不算是不可见属性，它的语义是隐藏元素，但元素仍然占据着布局空间，它会被渲染成一个空框。所以<code>visibility:hidden</code>只会触发<code>repaint</code>，因为没有发生位置变化。</p><p>另外有些情况下，比如修改了元素的样式，浏览器并不会立刻<code>reflow</code>或<code>repaint</code>一次，而是会把这样的操作积攒一批，然后做一次<code>reflow</code>，这又叫异步<code>reflow</code>或增量异步<code>reflow</code>。但是在有些情况下，比如<code>resize</code>窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行<code>reflow</code>。</p><h3 id="引起reflow"><a href="#引起reflow" class="headerlink" title="引起reflow"></a>引起reflow</h3><p>现代浏览器会对回流做优化，它会等到足够数量的变化发生，再做一次批处理回流。</p><ul><li>页面第一次渲染（初始化）</li><li>DOM树变化（如：增删节点）</li><li>Render树变化（如：<code>padding</code>改变）</li><li>浏览器窗口<code>resize</code></li><li>获取元素的某些属性</li></ul><p>浏览器为了获得正确的值也会提前触发回流，这样就使得浏览器的优化失效了，这些属性包括<code>offsetLeft、offsetTop、offsetWidth、offsetHeight、 scrollTop/Left/Width/Height、clientTop/Left/Width/Height</code>、调用了<code>getComputedStyle()</code>。</p><h3 id="引起repaint"><a href="#引起repaint" class="headerlink" title="引起repaint"></a>引起repaint</h3><p><code>reflow</code>回流必定引起<code>repaint</code>重绘，重绘可以单独触发。<br> 背景色、颜色、字体改变（注意：字体大小发生变化时，会触发回流）</p><h4 id="减少reflow、repaint触发次数"><a href="#减少reflow、repaint触发次数" class="headerlink" title="减少reflow、repaint触发次数"></a>减少reflow、repaint触发次数</h4><ul><li>用<code>transform</code>做形变和位移可以减少<code>reflow</code></li><li>避免逐个修改节点样式，尽量一次性修改</li><li>使用<code>DocumentFragment</code>将需要多次修改的DOM元素缓存，最后一次性<code>append</code>到真实DOM中渲染</li><li>可以将需要多次修改的DOM元素设置<code>display:none</code>，操作完再显示。（因为隐藏元素不在<code>render</code>树内，因此修改隐藏元素不会触发回流重绘）</li><li>避免多次读取某些属性</li><li>通过绝对位移将复杂的节点元素脱离文档流，形成新的Render Layer，降低回流成本</li></ul><h2 id="几条关于优化渲染效率的建议"><a href="#几条关于优化渲染效率的建议" class="headerlink" title="几条关于优化渲染效率的建议"></a>几条关于优化渲染效率的建议</h2><p>结合上文有以下几点可以优化渲染效率。</p><ul><li>合法地去书写HTML和CSS ，且不要忘了文档编码类型。</li><li>样式文件应当在<code>head</code>标签中，而脚本文件在<code>body</code>结束前，这样可以防止阻塞的方式。</li><li>简化并优化CSS选择器，尽量将嵌套层减少到最小。</li><li>DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。</li><li>如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。</li><li>不要一条条地改变样式，而要通过改变<code>class</code>，或者<code>csstext</code>属性，一次性地改变样式。</li><li>尽量用<code>transform</code>来做形变和位移</li><li>尽量使用离线DOM，而不是真实的网页DOM，来改变元素样式。比如，操作<code>Document Fragment</code>对象，完成后再把这个对象加入DOM。再比如，使用<code>cloneNode()</code>方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。</li><li>先将元素设为<code>display: none</code>（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。</li><li><code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。</li><li>只在必要的时候，才将元素的<code>display</code>属性为可见，因为不可见的元素不影响重排和重绘。另外，<code>visibility : hidden</code>的元素只对重绘有影响，不影响重排。</li><li>使用<code>window.requestAnimationFrame()</code>、<code>window.requestIdleCallback()</code>这两个方法调节重新渲染。</li></ul><h1 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h1><ol><li>箭头函数没有自己的this,继承外层代码块的this。</li><li>不能当做构造函数，也就是说不可以使用new命令，否则会报错的。</li><li>不能使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li><li>不能使用yield命令，因此箭头函数不能用作 Generator（生成器） 函数。</li><li>因为没有this,所以不能使用call、bind、apply来改变this的指向。</li></ol><h1 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h1><blockquote><p>Array对象属性</p></blockquote><ol><li><p>constructor 属性返回对创建此对象的数组函数的引用。</p></li><li><p>prototype 属性使您有能力向对象添加属性和方法。</p></li><li><p>length 属性可设置或返回数组中元素的数目。</p></li></ol><p>设置 length 属性可改变数组的大小。如果设置的值比其当前值小，数组将被截断，其尾部的元素将丢失。如果设置的值比它的当前值大，数组将增大，新的元素被添加到数组的尾部，它们的值为 undefined。</p><h2 id="一、改变原来数组的方法"><a href="#一、改变原来数组的方法" class="headerlink" title="一、改变原来数组的方法"></a>一、改变原来数组的方法</h2><ol><li><code>pop()</code>      <strong>获取数组最后一个元素（改变原数组）、删除数组最后一个元素</strong></li></ol><p>arrayObject.pop()</p><p>js内置的pop()方法可用于删除并并返回数组的最后一个元素，注意这里获取了数组的最后一个元素的同时也将原数组的最后一个元素删除了。如果数组为空，则该方法不改变数组，并返回undefined</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> last = list.pop()</span><br><span class="line"><span class="built_in">console</span>.log(list) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(last) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>push</code>   <strong>数组尾部添加元素（返回数组的新长度）</strong></li></ol><p>push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayObject.push(newelement1,newelement2,....,newelementX)</span><br></pre></td></tr></table></figure> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾部添加数组元素</span></span><br><span class="line"> <span class="keyword">let</span> arr6 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"> <span class="keyword">let</span> arr7 = arr6.push(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"> <span class="built_in">console</span>.log(arr6,arr7) <span class="comment">//  [1, 2, 3, 4, 5] 5</span></span><br><span class="line"> arr6.push(<span class="number">6</span>)</span><br><span class="line"> <span class="built_in">console</span>.log(arr6) <span class="comment">//  [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"> arr6 = arr6.push(<span class="number">7</span>)</span><br><span class="line"> <span class="built_in">console</span>.log(arr6) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>reverse</code>    <strong>颠倒数组的顺序（改变原数组）</strong></li></ol><p>arrayObject.reverse()</p><p>reverse() 方法用于颠倒数组中元素的顺序。该方法会改变原来的数组，而不会创建新的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr8 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> arr9 = arr8.reverse()</span><br><span class="line"><span class="built_in">console</span>.log(arr8,arr9) <span class="comment">// [6, 5, 4, 3, 2, 1]  [6, 5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure><ol start="4"><li><code>shift</code>   <strong>获取数组的第一个元素（改变原数组）、删除数组第一个元素</strong></li></ol><p>arrayObject.shift()</p><p>shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。请注意，该方法不创建新数组，而是直接修改原有的 arrayObject。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除第一个元素,并返回第一个元素的值</span></span><br><span class="line"> <span class="keyword">let</span> arr10 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"> <span class="keyword">let</span> arr11 = arr10.shift()</span><br><span class="line"> <span class="built_in">console</span>.log(arr10,arr11) <span class="comment">// [2, 3, 4] 1</span></span><br></pre></td></tr></table></figure><ol start="5"><li><code>splice</code>   <strong>向数组中添加或删除元素（改变原数组），然后返回被删除的元素</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayObject.splice(index,howmany,item1,.....,itemX)</span><br></pre></td></tr></table></figure><p><code>index</code>：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</p><p><code>howmany</code>：必需。要删除的项目数量。如果设置为 0，则不会删除项目。</p><p><code>item1</code>, …, itemX：可选。向数组添加的新项目。</p><p><code>splice() </code>方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。</p><p>如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。</p><p>所有主流浏览器都支持 splice() 方法。</p><p>注释：请注意，splice() 方法与 slice() 方法的作用是不同的，splice() 方法会直接对数组进行修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  从数组中添加/删除项目，然后返回被删除的项目</span></span><br><span class="line"><span class="keyword">let</span> arr19 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> arr20 = arr19.splice(<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr20,arr19) <span class="comment">// [2, 3, 4, 5]  [1, 6]</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr21 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> arr22 = arr21.splice(<span class="number">1</span>,<span class="number">4</span>,<span class="number">222</span>,<span class="number">333</span>,<span class="number">666</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr22,arr21) <span class="comment">//  [2, 3, 4, 5]  [1,222,333,666,6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">6</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">&quot;George&quot;</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">&quot;John&quot;</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">&quot;Thomas&quot;</span></span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">&quot;James&quot;</span></span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">&quot;Adrew&quot;</span></span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">&quot;Martin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(arr + <span class="string">&quot;&lt;br /&gt;&quot;</span>)</span><br><span class="line">arr.splice(<span class="number">2</span>,<span class="number">0</span>,<span class="string">&quot;William&quot;</span>)</span><br><span class="line"><span class="built_in">document</span>.write(arr + <span class="string">&quot;&lt;br /&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line">George,John,Thomas,James,Adrew,Martin</span><br><span class="line">George,John,William,Thomas,James,Adrew,Martin</span><br></pre></td></tr></table></figure><ol start="6"><li><code>unshift</code>   <strong>向数组的开头添加一个或更多元素(改变原数组)，并返回新的长度</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayObject.unshift(newelement1,newelement2,....,newelementX)</span><br></pre></td></tr></table></figure><p>第一个参数必填。向数组添加的元素</p><p>unshift() 方法将把它的参数插入 arrayObject 的头部，并将已经存在的元素顺次地移到较高的下标处，以便留出空间。</p><p>该方法的第一个参数将成为数组的新元素 0，如果还有第二个参数，它将成为新的元素 1，以此类推。</p><p>请注意，unshift() 方法不创建新的创建，而是直接修改原有的数组。</p><p>注释：该方法会改变数组的长度。</p><p>注释：unshift() 方法无法在 Internet Explorer 中正确地工作</p><ol start="7"><li><code>sort</code> <strong>对数组元素进行排序（改变原数组）</strong></li></ol><p>arrayObject.sort(sortby)</p><p>对数组的引用。请注意，数组在原数组上进行排序，不生成副本。</p><p>参数可选。规定排序顺序。必须是函数。</p><p>如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。</p><p>要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的排序</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">6</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">&#x27;George&#x27;</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">&#x27;John&#x27;</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">&#x27;Thomas&#x27;</span></span><br><span class="line">arr[<span class="number">3</span>] = <span class="string">&#x27;James&#x27;</span></span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">&#x27;Adrew&#x27;</span></span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">&#x27;Martin&#x27;</span></span><br><span class="line"><span class="keyword">let</span> arr16 = arr.sort()</span><br><span class="line"><span class="built_in">console</span>.log(arr16, arr)</span><br><span class="line"><span class="comment">// [&quot;Adrew&quot;, &quot;George&quot;, &quot;James&quot;, &quot;John&quot;, &quot;Martin&quot;, &quot;Thomas&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;Adrew&quot;, &quot;George&quot;, &quot;James&quot;, &quot;John&quot;, &quot;Martin&quot;, &quot;Thomas&quot;]</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> arr17 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">6</span>)</span><br><span class="line">arr17[<span class="number">0</span>] = <span class="string">&#x27;10&#x27;</span></span><br><span class="line">arr17[<span class="number">1</span>] = <span class="string">&#x27;5&#x27;</span></span><br><span class="line">arr17[<span class="number">2</span>] = <span class="string">&#x27;40&#x27;</span></span><br><span class="line">arr17[<span class="number">3</span>] = <span class="string">&#x27;25&#x27;</span></span><br><span class="line">arr17[<span class="number">4</span>] = <span class="string">&#x27;1000&#x27;</span></span><br><span class="line">arr17[<span class="number">5</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr17.sort()) </span><br><span class="line"><span class="comment">//  [&quot;1&quot;, &quot;10&quot;, &quot;1000&quot;, &quot;25&quot;, &quot;40&quot;, &quot;5&quot;]</span></span><br></pre></td></tr></table></figure><p>如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。</p><p>比较函数应该具有两个参数 a 和 b，其返回值如下：</p><p>若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。</p><p>若 a 等于 b，则返回 0。</p><p>若 a 大于 b，则返回一个大于 0 的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNumber</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr18 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">6</span>)</span><br><span class="line">arr18[<span class="number">0</span>] = <span class="string">&#x27;10&#x27;</span></span><br><span class="line">arr18[<span class="number">1</span>] = <span class="string">&#x27;5&#x27;</span></span><br><span class="line">arr18[<span class="number">2</span>] = <span class="string">&#x27;40&#x27;</span></span><br><span class="line">arr18[<span class="number">3</span>] = <span class="string">&#x27;25&#x27;</span></span><br><span class="line">arr18[<span class="number">4</span>] = <span class="string">&#x27;1000&#x27;</span></span><br><span class="line">arr18[<span class="number">5</span>] = <span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr18.sort(sortNumber)) <span class="comment">// [&quot;1&quot;, &quot;5&quot;, &quot;10&quot;, &quot;25&quot;, &quot;40&quot;, &quot;1000&quot;]</span></span><br></pre></td></tr></table></figure><h2 id="二、不改变原来数组的方法"><a href="#二、不改变原来数组的方法" class="headerlink" title="二、不改变原来数组的方法"></a>二、不改变原来数组的方法</h2><ol><li><code>concat</code>   <strong>连接多个数组或元素（不改变原数组）</strong></li></ol><p>arrayObject.concat(arrayX,arrayX,……,arrayX)</p><p>concat() 方法用于连接两个或多个数组，该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。</p><p>该参数可以是具体的值，也可以是数组对象。可以是任意多个。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment">// 1. 数组的合并</span></span><br><span class="line"><span class="keyword">let</span> arr3 = arr1.concat(arr2)</span><br><span class="line"><span class="built_in">console</span>.log(arr1,arr2,arr3)</span><br><span class="line"><span class="comment">// [1,2,3] [4,5]  [1,2,3,4,5]</span></span><br><span class="line"> </span><br><span class="line">arr3 = arr3.concat(<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr3) <span class="comment">// [1, 2, 3, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>join</code>  <strong>将数组用分隔符连接成字符串（不改变原数组）</strong></li></ol><p>arrayObject.join(separator)</p><p>join() 方法用于把数组中的所有元素放入一个字符串。</p><p>元素是通过指定的分隔符进行分隔的。</p><p>该参数<code>可选</code>。</p><p>指定要使用的分隔符，如果省略该参数，则使用逗号作为分隔符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   数组转换成字符串，并使用分隔符连接</span></span><br><span class="line"><span class="keyword">let</span> arr4 = [<span class="number">2019</span>,<span class="number">3</span>,<span class="number">14</span>]</span><br><span class="line"><span class="keyword">let</span> arr5 = arr4.join()</span><br><span class="line"><span class="built_in">console</span>.log(arr4,arr5) <span class="comment">// [2019, 3, 14] &quot;2019,3,14&quot;</span></span><br><span class="line">arr4 = arr4.join(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr4) <span class="comment">// 2019.3.14</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>slice</code> <strong>截取原数组中某段元素（不改变原数组）</strong></li></ol><p>arrayObject.slice(start,end)</p><p><code>slice()</code> 方法可从已有的数组中返回选定的元素。</p><p>返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。</p><p>start：<code>必需</code>。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。</p><p>end：<code>可选</code>。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</p><p>请注意，该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从原数组中返回选定的元素</span></span><br><span class="line"><span class="keyword">let</span> arr12 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr13 = arr12.slice(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr12,arr13) <span class="comment">// [1, 2, 3, 4]  [2, 3, 4]</span></span><br><span class="line"><span class="keyword">let</span> arr14 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr15 = arr14.slice(-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr14,arr15) <span class="comment">// [1, 2, 3, 4]  4</span></span><br></pre></td></tr></table></figure><ol start="4"><li><code>toString</code>   <strong>把数组转换为字符串，并返回结果（不改变原数组）</strong></li></ol><p>arrayObject.toString()</p><p>toString() 方法可把数组转换为字符串，并返回结果。</p><p>arrayObject 的字符串表示。返回值与没有参数的 join() 方法返回的字符串相同。</p><p>当数组用于字符串环境时，JavaScript 会调用这一方法将数组自动转换成字符串。但是在某些情况下，需要显式地调用该方法。</p><p>注释：数组中的元素之间用逗号分隔</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数组转换成字符串</span></span><br><span class="line"><span class="keyword">let</span> arr23 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr24 = arr23.toString()</span><br><span class="line"><span class="built_in">console</span>.log(arr23,arr24) <span class="comment">// [1, 2, 3, 4] &quot;1,2,3,4&quot;</span></span><br></pre></td></tr></table></figure><ol start="5"><li> <code>toLocaleString</code>    <strong>把数组转换为本地字符串(不改变原数组)</strong></li></ol><p>arrayObject.toLocaleString()</p><p>arrayObject 的本地字符串表示。首先调用每个数组元素的 toLocaleString() 方法，然后使用地区特定的分隔符把生成的字符串连接起来，形成一个字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把数组转换为本地字符串  返回格式化对象后的字符串，该字符串格式因语言不同返回值也会不同，可以通过传参决定返回的语言及具体的表现</span></span><br><span class="line"><span class="keyword">let</span> arr25 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr26 = arr25.toLocaleString()</span><br><span class="line"><span class="built_in">console</span>.log(arr25,arr26) <span class="comment">// [1, 2, 3, 4] &quot;1,2,3,4&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> a = <span class="number">12222</span></span><br><span class="line"><span class="built_in">console</span>.log(a.toLocaleString()) <span class="comment">// 12,222 (整数部分每三位加一个逗号)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;浏览器里，从用户输入url到用户看到页面结果的过程，发生了什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1、域名解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;域名解析的过程：&lt;/p&gt;
&lt;p&gt;　　（1）查询浏览器自身DNS缓存&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="面试经验" scheme="https://qwq3.top/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>vue面试题</title>
    <link href="https://qwq3.top/posts/bd4e.html"/>
    <id>https://qwq3.top/posts/bd4e.html</id>
    <published>2021-06-28T10:52:23.000Z</published>
    <updated>2021-11-18T04:02:22.738Z</updated>
    
    <content type="html"><![CDATA[<p>20道常见的面试题</p><p>摘自boss直聘<code>陈大鱼头</code></p><blockquote><p>尽量减少 data 中的数据，data 中的数据都会增加 getter 和 setter，会收集对应的 watcher</p></blockquote><p>从镜片的厚度和黄黑相见的格子衬衫我察觉到，面前坐着的这位面试官应该是来者不善。我像以往一样，准备花 3 分钟的时间进行自我介绍。</p><p>在此期间，为了避免尴尬，我盯着面试官的眉毛中间，不过面试官明显对我的经历不是很感兴趣。他在 1 分半的时候打断了我。</p><blockquote><p><strong>你觉得自己最擅长的技术栈是什么？</strong></p></blockquote><p>Vue 吧，我很喜欢尤大，最近刚发布了 Vue 的首部纪录片，真的很好看。</p><h3 id="那你能讲一讲-MVVM-吗？"><a href="#那你能讲一讲-MVVM-吗？" class="headerlink" title="那你能讲一讲 MVVM 吗？"></a><strong>那你能讲一讲 MVVM 吗？</strong></h3><p>MVVM 是 Model-View-ViewModel 缩写，也就是把 MVC 中的 Controller 演变成 ViewModel。Model 层代表数据模型，View 代表 UI 组件，</p><p>ViewModel 是 View 和 Model 层的桥梁，数据会绑定到 viewModel 层并自动将数据渲染到页面中，视图变化的时候会通知 viewModel 层更新数据。</p><h3 id="简单说一下-Vue2-x-响应式数据原理"><a href="#简单说一下-Vue2-x-响应式数据原理" class="headerlink" title="简单说一下 Vue2.x 响应式数据原理"></a><strong>简单说一下 Vue2.x 响应式数据原理</strong></h3><p>Vue 在初始化数据时，会使用 Object.defineProperty 重新定义 data 中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的 watcher)</p><p>如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。</p><h3 id="那你知道-Vue3-x-响应式数据原理吗？"><a href="#那你知道-Vue3-x-响应式数据原理吗？" class="headerlink" title="那你知道 Vue3.x 响应式数据原理吗？"></a><strong>那你知道 Vue3.x 响应式数据原理吗？</strong></h3><p>(还好我有看，这个难不倒我)</p><p>Vue3.x 改用 Proxy 替代 Object.defineProperty。因为 Proxy 可以直接监听对象和数组的变化，并且有多达 13 种拦截方法。</p><p>并且作为新标准将受到浏览器厂商重点持续的性能优化。</p><blockquote><p>“ Proxy 只会代理对象的第一层，那么 Vue3 又是怎样处理这个问题的呢？”</p></blockquote><p>（很简单啊）</p><p>判断当前 Reflect.get 的返回值是否为 Object，如果是则再通过 reactive 方法做代理， 这样就实现了深度观测。</p><blockquote><p>“ 监测数组的时候可能触发多次 get/set，那么如何防止触发多次呢？”</p></blockquote><p>我们可以判断 key 是否为当前被代理对象 target 自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行 trigger。</p><p>面试官抬起了头。心里暗想</p><p>(这小子还行，比上两个强，应该是多多少少看过 Vue3 的源码了)</p><h3 id="再说一下-vue2-x-中如何监测数组变化"><a href="#再说一下-vue2-x-中如何监测数组变化" class="headerlink" title="再说一下 vue2.x 中如何监测数组变化"></a><strong>再说一下 vue2.x 中如何监测数组变化</strong></h3><p>使用了函数劫持的方式，重写了数组的方法，Vue 将 data 中的数组进行了原型链重写，指向了自己定义的数组原型方法。</p><p>这样当调用数组 api 时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</p><p>（能问到这的面试官都比较注重深度，这些常规操作要记牢）</p><p>（原型链的细节可以参考我的另一篇专栏）</p><h3 id="nextTick-知道吗，实现原理是什么？"><a href="#nextTick-知道吗，实现原理是什么？" class="headerlink" title="nextTick 知道吗，实现原理是什么？"></a><strong>nextTick 知道吗，实现原理是什么？</strong></h3><p>在下次 DOM 更新循环结束之后执行延迟回调。nextTick 主要使用了宏任务和微任务。根据执行环境分别尝试采用</p><p>Promise</p><p>MutationObserver</p><p>setImmediate</p><p>如果以上都不行则采用 setTimeout</p><p>定义了一个异步方法，多次调用 nextTick 会将方法存入队列中，通过这个异步方法清空当前队列。</p><p>（关于宏任务和微任务以及事件循环可以参考我的另两篇专栏）</p><p>(看到这你就会发现，其实问框架最终还是考验你的原生 JavaScript 功底)</p><h3 id="说一下-Vue-的生命周期"><a href="#说一下-Vue-的生命周期" class="headerlink" title="说一下 Vue 的生命周期"></a><strong>说一下 Vue 的生命周期</strong></h3><p>beforeCreate 是 new Vue()之后触发的第一个钩子，在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问。</p><p>created 在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发 updated 函数。</p><p>可以做一些初始数据的获取，在当前阶段无法与 Dom 进行交互，如果非要想，可以通过 vm.$nextTick 来访问 Dom。</p><p>beforeMount 发生在挂载之前，在这之前 template 模板已导入渲染函数编译。而当前阶段虚拟 Dom 已经创建完成，即将开始渲染。</p><p>在此时也可以对数据进行更改，不会触发 updated。</p><p>mounted 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点，使用$refs 属性对 Dom 进行操作。</p><p>beforeUpdate 发生在更新之前，也就是响应式数据发生更新，虚拟 dom 重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。</p><p>updated 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</p><p>beforeDestroy 发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。</p><p>destroyed 发生在实例销毁之后，这个时候只剩下了 dom 空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</p><p>(关于 Vue 的生命周期详解感兴趣的也请移步我的另一篇专栏)</p><h3 id="你的接口请求一般放在哪个生命周期中？"><a href="#你的接口请求一般放在哪个生命周期中？" class="headerlink" title="你的接口请求一般放在哪个生命周期中？"></a><strong>你的接口请求一般放在哪个生命周期中？</strong></h3><p>接口请求一般放在 mounted 中，但需要注意的是服务端渲染时不支持 mounted，需要放到 created 中。</p><h3 id="再说一下-Computed-和-Watch"><a href="#再说一下-Computed-和-Watch" class="headerlink" title="再说一下 Computed 和 Watch"></a><strong>再说一下 Computed 和 Watch</strong></h3><p>Computed 本质是一个具备缓存的 watcher，依赖的属性发生变化就会更新视图。适用于计算比较消耗性能的计算场景。</p><p>当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理。</p><p>Watch 没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开 deep：true 选项，</p><p>这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用字符串形式监听，如果没有写到组件中，不要忘记使用 unWatch 手动注销哦。</p><h3 id="说一下-v-if-和-v-show-的区别"><a href="#说一下-v-if-和-v-show-的区别" class="headerlink" title="说一下 v-if 和 v-show 的区别"></a><strong>说一下 v-if 和 v-show 的区别</strong></h3><p>当条件不成立时，v-if 不会渲染 DOM 元素，v-show 操作的是样式(display)，切换当前 DOM 的显示和隐藏。</p><h3 id="组件中的-data-为什么是一个函数？"><a href="#组件中的-data-为什么是一个函数？" class="headerlink" title="组件中的 data 为什么是一个函数？"></a><strong>组件中的 data 为什么是一个函数？</strong></h3><p>一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。如果 data 是对象的话，对象属于引用类型，会影响到所有的实例。</p><p>所以为了保证组件不同的实例之间 data 不冲突，data 必须是一个函数。</p><h3 id="说一下-v-model-的原理"><a href="#说一下-v-model-的原理" class="headerlink" title="说一下 v-model 的原理"></a><strong>说一下 v-model 的原理</strong></h3><p>v-model 本质就是一个语法糖，可以看成是 value + input 方法的语法糖。可以通过 model 属性的 prop 和 event 属性来进行自定义。</p><p>原生的 v-model，会根据标签的不同生成不同的事件和属性。</p><h3 id="Vue-事件绑定原理说一下"><a href="#Vue-事件绑定原理说一下" class="headerlink" title="Vue 事件绑定原理说一下"></a><strong>Vue 事件绑定原理说一下</strong></h3><p>原生事件绑定是通过 addEventListener 绑定给真实元素的，组件事件绑定是通过 Vue 自定义的$on 实现的。</p><blockquote><p>“ 面试官：(这小子基础还可以，接下来我得上上难度了） ”</p></blockquote><h3 id="Vue-模版编译原理知道吗，能简单说一下吗？"><a href="#Vue-模版编译原理知道吗，能简单说一下吗？" class="headerlink" title="Vue 模版编译原理知道吗，能简单说一下吗？"></a><strong>Vue 模版编译原理知道吗，能简单说一下吗？</strong></h3><p>简单说，Vue 的编译过程就是将 template 转化为 render 函数的过程。会经历以下阶段：</p><p>生成 AST 树</p><p>优化</p><p>codegen</p><p>首先解析模版，生成 AST 语法树(一种用 JavaScript 对象的形式来描述整个模板)。使用大量的正则表达式对模板进行解析，</p><p>遇到标签、文本的时候都会执行对应的钩子进行相关处理。</p><p>Vue 的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的 DOM 也不会变化。</p><p>那么优化过程就是深度遍历 AST 树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。</p><p>编译的最后一步是将优化后的 AST 树转换为可执行的代码。</p><blockquote><p>“ 面试官：(精神小伙啊，有点东西，难度提升，不信难不倒你）”</p></blockquote><h3 id="Vue2-x-和-Vue3-x-渲染器的-diff-算法分别说一下"><a href="#Vue2-x-和-Vue3-x-渲染器的-diff-算法分别说一下" class="headerlink" title="Vue2.x 和 Vue3.x 渲染器的 diff 算法分别说一下"></a><strong>Vue2.x 和 Vue3.x 渲染器的 diff 算法分别说一下</strong></h3><p>简单来说，diff 算法有以下过程</p><p>同级比较，再比较子节点</p><p>先判断一方有子节点一方没有子节点的情况(如果新的 children 没有子节点，将旧的子节点移除)</p><p>比较都有子节点的情况(核心 diff)</p><p>递归比较子节点</p><p>正常 Diff 两个树的时间复杂度是 O(n^3)，但实际情况下我们很少会进行跨层级的移动 DOM，所以 Vue 将 Diff 进行了优化，从 O(n^3) -&gt; O(n)，</p><p>只有当新旧 children 都为多个子节点时才需要用核心的 Diff 算法进行同层级比较。</p><p>Vue2 的核心 Diff 算法采用了双端比较的算法，同时从新旧 children 的两端开始进行比较，借助 key 值找到可复用的节点，再进行相关操作。</p><p>相比 React 的 Diff 算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。</p><p>Vue3.x 借鉴了 ivi 算法和 inferno 算法</p><p>在创建 VNode 时就确定其类型，以及在 mount/patch 的过程中采用位运算来判断一个 VNode 的类型，在这个基础之上再配合核心的 Diff 算法，</p><p>使得性能上较 Vue2.x 有了提升。(实际的实现可以结合 Vue3.x 源码看。)</p><p>该算法中还运用了动态规划的思想求解最长递归子序列。</p><p>(看到这你还会发现，框架内无处不蕴藏着数据结构和算法的魅力)</p><blockquote><p>“ 面试官：(可以可以，看来是个苗子，不过自我介绍属实有些无聊，下一题) ”</p></blockquote><h3 id="再说一下虚拟-Dom-以及-key-属性的作用"><a href="#再说一下虚拟-Dom-以及-key-属性的作用" class="headerlink" title="再说一下虚拟 Dom 以及 key 属性的作用"></a><strong>再说一下虚拟 Dom 以及 key 属性的作用</strong></h3><p>由于在浏览器中操作 DOM 是很昂贵的。频繁的操作 DOM，会产生一定的性能问题。这就是虚拟 Dom 的产生原因。</p><p>Vue2 的 Virtual DOM 借鉴了开源库 snabbdom 的实现。</p><p>Virtual DOM 本质就是用一个原生的 JS 对象去描述一个 DOM 节点。是对真实 DOM 的一层抽象。(也就是源码中的 VNode 类，它定义在 src/core/vdom/vnode.js 中。)</p><p>VirtualDOM 映射到真实 DOM 要经历 VNode 的 create、diff、patch 等阶段。</p><p>「key 的作用是尽可能的复用 DOM 元素。」</p><p>新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的。</p><p>需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key 也就是 children 中节点的唯一标识。</p><h3 id="keep-alive-了解吗？"><a href="#keep-alive-了解吗？" class="headerlink" title="keep-alive 了解吗？"></a><strong>keep-alive 了解吗？</strong></h3><p>keep-alive 可以实现组件缓存，当组件切换时不会对当前组件进行卸载。</p><p>常用的两个属性 include/exclude，允许组件有条件的进行缓存。</p><p>两个生命周期 activated/deactivated，用来得知当前组件是否处于活跃状态。</p><p>keep-alive 的中还运用了 LRU(Least Recently Used)算法。</p><p>（又是数据结构与算法，原来算法在前端有这么多的应用）</p><h3 id="Vue-中组件生命周期调用顺序说一下"><a href="#Vue-中组件生命周期调用顺序说一下" class="headerlink" title="Vue 中组件生命周期调用顺序说一下"></a><strong>Vue 中组件生命周期调用顺序说一下</strong></h3><p>组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。</p><p>组件的销毁操作是先父后子，销毁完成的顺序是先子后父。</p><p><strong>加载渲染过程</strong></p><p>父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate-&gt;子 created-&gt;子 beforeMount- &gt;子 mounted-&gt;父 mounted</p><p><strong>子组件更新过程</strong></p><p>父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated</p><p><strong>父组件更新过程</strong></p><p>父 beforeUpdate -&gt; 父 updated</p><p><strong>销毁过程</strong></p><p>父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</p><h3 id="Vue2-x-组件通信有哪些方式？"><a href="#Vue2-x-组件通信有哪些方式？" class="headerlink" title="Vue2.x 组件通信有哪些方式？"></a>Vue2.x 组件通信有哪些方式？</h3><p><strong>父子组件通信</strong></p><p>父-&gt;子 props，子-&gt;父 $on、$emit</p><p>获取父子组件实例 $parent、$children</p><p>Ref 获取实例的方式调用组件的属性或者方法</p><p>Provide、inject 官方不推荐使用，但是写组件库时很常用</p><p><strong>兄弟组件通信</strong></p><p>Event Bus 实现跨组件通信 Vue.prototype.$bus = new Vue</p><p>Vuex</p><p><strong>跨级组件通信</strong></p><p>Vuex</p><p>$attrs、$listeners</p><p>Provide、inject</p><h3 id="SSR-了解吗？"><a href="#SSR-了解吗？" class="headerlink" title="SSR 了解吗？"></a><strong>SSR 了解吗？</strong></h3><p>SSR 也就是服务端渲染，也就是将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 html 直接返回给客户端。</p><p>SSR 有着更好的 SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，</p><p>服务器端渲染只支持 beforeCreate 和 created 两个钩子，当我们需要一些外部扩展库时需要特殊处理，</p><p>服务端渲染应用程序也需要处于 Node.js 的运行环境。还有就是服务器会有更大的负载需求。</p><h3 id="你都做过哪些-Vue-的性能优化？"><a href="#你都做过哪些-Vue-的性能优化？" class="headerlink" title="你都做过哪些 Vue 的性能优化？"></a><strong>你都做过哪些 Vue 的性能优化？</strong></h3><p>编码阶段</p><p>尽量减少 data 中的数据，data 中的数据都会增加 getter 和 setter，会收集对应的 watcher</p><p>v-if 和 v-for 不能连用</p><p>如果需要使用 v-for 给每项元素绑定事件时使用事件代理</p><p>SPA 页面采用 keep-alive 缓存组件</p><p>在更多的情况下，使用 v-if 替代 v-show</p><p>key 保证唯一</p><p>使用路由懒加载、异步组件</p><p>防抖、节流</p><p>第三方模块按需导入</p><p>长列表滚动到可视区域动态加载</p><p>图片懒加载</p><p><strong>SEO 优化</strong></p><p>预渲染</p><p>服务端渲染 SSR</p><p><strong>打包优化</strong></p><p>压缩代码</p><p>Tree Shaking/Scope Hoisting</p><p>使用 cdn 加载第三方模块</p><p>多线程打包 happypack</p><p>splitChunks 抽离公共文件</p><p>sourceMap 优化</p><p><strong>用户体验</strong></p><p>骨架屏</p><p>PWA</p><p>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启 gzip 压缩等。</p><p>(优化是个大工程，会涉及很多方面，这里申请另开一个专栏)</p><h3 id="hash-路由和-history-路由实现原理说一下"><a href="#hash-路由和-history-路由实现原理说一下" class="headerlink" title="hash 路由和 history 路由实现原理说一下"></a><strong>hash 路由和 history 路由实现原理说一下</strong></h3><p>location.hash 的值实际就是 URL 中#后面的东西。</p><p>history 实际采用了 HTML5 中提供的 API 来实现，主要有 history.pushState()和 history.replaceState()。</p><p>面试官拿起旁边已经凉透的咖啡，喝了一口。</p><p>(我难道问不倒这小子了么)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;20道常见的面试题&lt;/p&gt;
&lt;p&gt;摘自boss直聘&lt;code&gt;陈大鱼头&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;尽量减少 data 中的数据，data 中的数据都会增加 getter 和 setter，会收集对应的 watcher&lt;/p&gt;
&lt;/blockquo</summary>
      
    
    
    
    
    <category term="面试经验" scheme="https://qwq3.top/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Redis高级</title>
    <link href="https://qwq3.top/posts/fc99.html"/>
    <id>https://qwq3.top/posts/fc99.html</id>
    <published>2021-06-24T14:57:21.000Z</published>
    <updated>2021-11-18T04:02:22.742Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学无止境</p></blockquote><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Redis 事务本质：一组命令的集合！ 一个事务中的所有命令都会被序列化，在事务执行过程的中，会按<br>照顺序执行！</p><p>一次性、顺序性、排他性！执行一些列的命令！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">------ 队列 set set set 执行------</span><br></pre></td></tr></table></figure><p><strong>Redis事务没有没有隔离级别的概念！</strong><br>所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！Exec<br><code>Redis单条命令式保存原子性的，但是事务不保证原子性</code>！</p><p>redis的事务：</p><ul><li>开启事务（multi）</li><li>命令入队（……）</li><li>执行事务（exec）</li></ul><blockquote><p>正常执行事务！</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi <span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 命令入队</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> <span class="comment"># 执行事务</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">&quot;v2&quot;</span></span><br><span class="line">4) OK</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>放弃事务！(DISCARD )</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi <span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; DISCARD <span class="comment"># 取消事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k4 <span class="comment"># 事务队列中命令都不会被执行！</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><blockquote><p>编译型异常（代码有问题！ 命令有错！） ，事务中所有的命令都不会被执行！</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; getset k3 <span class="comment"># 错误的命令</span></span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;getset&#x27;</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k4 v4</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k5 v5</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> <span class="comment"># 执行事务报错！</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">127.0.0.1:6379&gt; get k5 <span class="comment"># 所有的命令都不会被执行！</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><blockquote><p>运行时异常（1/0）， 如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行<br>的，错误命令抛出异常！</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 <span class="string">&quot;v1&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr k1 <span class="comment"># 会执行的时候失败！</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) (error) ERR value is not an <span class="built_in">integer</span> or out of range <span class="comment"># 虽然第一条命令报错了，但是</span></span><br><span class="line">依旧正常执行成功了！</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">4) <span class="string">&quot;v3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line"><span class="string">&quot;v2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line"><span class="string">&quot;v3&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>监控！ Watch （面试常问！）</p></blockquote><p><strong>悲观锁：</strong></p><ul><li>很悲观，认为什么时候都会出问题，无论做什么都会加锁！</li></ul><p><strong>乐观锁：</strong></p><ul><li>很乐观，认为什么时候都不会出问题，所以不会上锁！ - - 更新数据的时候去判断一下，在此期间是否<br>有人修改过这个数据，</li><li>获取version</li><li>更新的时候比较 version</li></ul><blockquote><p>Redis测监视测试</p></blockquote><p><strong>正常执行成功</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> out 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># 监视 money 对象</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi <span class="comment"># 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY out 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 80</span><br><span class="line">2) (<span class="built_in">integer</span>) 20</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试多线程修改值 , 使用watch 可以当做redis的乐观锁操作！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># 监视 money</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY out 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> <span class="comment"># 执行之前，另外一个线程，修改了我们的值，这个时候，就会导致事务执行失</span></span><br><span class="line">败！</span><br><span class="line">(nil)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果修改失败，获取最新的值就好</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/5MSHZsw6XxYAbO4.png"></p><h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>我们要使用 Java 来操作 Redis，知其然并知其所以然，授人以渔！ 学习不能急躁，慢慢来会很快！</p><blockquote><p>什么是Jedis 是 Redis 官方推荐的 java连接开发工具！ 使用Java 操作Redis 中间件！如果你要使用<br>java操作redis，那么一定要对Jedis 十分的熟悉！</p></blockquote><blockquote><p>测试</p></blockquote><ol><li>导入对应的依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入jedis的包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--fastjson--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.62<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>、编码测试：</li></ol><ul><li>连接数据库</li><li>操作命令</li><li>断开连接！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1、 new Jedis 对象即可</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// jedis 所有的命令就是我们之前学习的所有指令！所以之前的指令学习很重要！</span></span><br><span class="line">        System.out.println(jedis.ping());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210624102222304.png" alt="image-20210624102222304"></p><h1 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h1><ul><li>String</li><li>List</li><li>Set</li><li>Hash</li><li>Zset</li></ul><blockquote><p>所有的api命令，就是我们对应的上面学习的指令，一个都没有变化！</p></blockquote><blockquote><p>事务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTX</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">            jedis.flushDB();</span><br><span class="line">            JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">            jsonObject.put(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">            jsonObject.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;kuangshen&quot;</span>);</span><br><span class="line">            <span class="comment">// 开启事务</span></span><br><span class="line">            Transaction multi = jedis.multi();</span><br><span class="line">            String result = jsonObject.toJSONString();</span><br><span class="line">            <span class="comment">// jedis.watch(result)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            multi.set(<span class="string">&quot;user1&quot;</span>,result);</span><br><span class="line">            multi.set(<span class="string">&quot;user2&quot;</span>,result);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span> ; <span class="comment">// 代码抛出异常事务，执行失败！</span></span><br><span class="line">            multi.exec(); <span class="comment">// 执行事务！</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             multi.discard(); <span class="comment">// 放弃事务</span></span><br><span class="line">               e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;user1&quot;</span>));</span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;user2&quot;</span>));</span><br><span class="line">            jedis.close(); <span class="comment">// 关闭连接</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Redis-conf详解"><a href="#Redis-conf详解" class="headerlink" title="Redis.conf详解"></a>Redis.conf详解</h1><p>启动的时候，就通过配置文件来启动！</p><p>工作中，一些小小的配置，可以让你脱颖而出！</p><p>行家有没有，出手就知道</p><blockquote><p>单位</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/oA9uldMJS2QLq1E.png" alt="image.png"></p><ol><li>配置文件 unit单位 对大小写不敏感！</li></ol><p>就是好比我们学习Spring、Improt， include</p><blockquote><p>网络</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 127.0.0.1 <span class="comment"># 绑定的ip</span></span><br><span class="line">protected-mode yes <span class="comment"># 保护模式</span></span><br><span class="line">port 6379 <span class="comment"># 端口设置</span></span><br></pre></td></tr></table></figure><blockquote><p>通用 GENERAL</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes <span class="comment"># 以守护进程的方式运行，默认是 no，我们需要自己开启为yes！</span></span><br><span class="line">pidfile /var/run/redis_6379.pid <span class="comment"># 如果以后台的方式运行，我们就需要指定一个 pid 文件！</span></span><br><span class="line"><span class="comment"># 日志</span></span><br><span class="line"><span class="comment"># Specify the server verbosity level.</span></span><br><span class="line"><span class="comment"># This can be one of:</span></span><br><span class="line"><span class="comment"># debug (a lot of information, useful for development/testing)</span></span><br><span class="line"><span class="comment"># verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="comment"># notice (moderately verbose, what you want in production probably) 生产环境</span></span><br><span class="line"><span class="comment"># warning (only very important / critical messages are logged)</span></span><br><span class="line">loglevel notice</span><br><span class="line">logfile <span class="string">&quot;&quot;</span> <span class="comment"># 日志的文件位置名</span></span><br><span class="line">databases 16 <span class="comment"># 数据库的数量，默认是 16 个数据库</span></span><br><span class="line">always-show-logo yes <span class="comment"># 是否总是显示LOGO</span></span><br></pre></td></tr></table></figure><blockquote><p>快照</p></blockquote><p>持久化， 在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb. aof</p><p>redis 是内存数据库，如果没有持久化，那么数据断电及失！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果900s内，如果至少有一个1 key进行了修改，我们及进行持久化操作</span></span><br><span class="line">save 900 1</span><br><span class="line"><span class="comment"># 如果300s内，如果至少10 key进行了修改，我们及进行持久化操作</span></span><br><span class="line">save 300 10</span><br><span class="line"><span class="comment"># 如果60s内，如果至少10000 key进行了修改，我们及进行持久化操作</span></span><br><span class="line">save 60 10000</span><br><span class="line"><span class="comment"># 我们之后学习持久化，会自己定义这个测试！</span></span><br><span class="line">stop-writes-on-bgsave-error yes <span class="comment"># 持久化如果出错，是否还需要继续工作！</span></span><br><span class="line">rdbcompression yes <span class="comment"># 是否压缩 rdb 文件，需要消耗一些cpu资源！</span></span><br><span class="line">rdbchecksum yes <span class="comment"># 保存rdb文件的时候，进行错误的检查校验！</span></span><br><span class="line">dir ./ <span class="comment"># rdb 文件保存的目录！</span></span><br></pre></td></tr></table></figure><blockquote><p>REPLICATION 复制，我们后面讲解主从复制的，时候再进行讲解</p></blockquote><blockquote><p>SECURITY 安全</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass <span class="comment"># 获取redis的密码</span></span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; config <span class="built_in">set</span> requirepass <span class="string">&quot;123456&quot;</span> <span class="comment"># 设置redis的密码</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass <span class="comment"># 发现所有的命令都没有权限了</span></span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth 123456 <span class="comment"># 使用密码进行登录！</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>限制 CLIENTS</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">maxclients 10000 <span class="comment"># 设置能连接上redis的最大客户端的数量</span></span><br><span class="line">maxmemory &lt;bytes&gt; <span class="comment"># redis 配置最大的内存容量</span></span><br><span class="line">maxmemory-policy noeviction <span class="comment"># 内存到达上限之后的处理策略</span></span><br><span class="line">1、volatile-lru：只对设置了过期时间的key进行LRU（默认值）</span><br><span class="line">2、allkeys-lru ： 删除lru算法的key</span><br><span class="line">3、volatile-random：随机删除即将过期key</span><br><span class="line">4、allkeys-random：随机删除</span><br><span class="line">5、volatile-ttl ： 删除即将过期的</span><br><span class="line">6、noeviction ： 永不过期，返回错误</span><br></pre></td></tr></table></figure><blockquote><p>APPEND ONLY 模式 aof配置</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appendonly no <span class="comment"># 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，</span></span><br><span class="line">rdb完全够用！</span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span> <span class="comment"># 持久化的文件的名字</span></span><br><span class="line"><span class="comment"># appendfsync always # 每次修改都会 sync。消耗性能</span></span><br><span class="line">appendfsync everysec <span class="comment"># 每秒执行一次 sync，可能会丢失这1s的数据！</span></span><br><span class="line"><span class="comment"># appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，速度最快！</span></span><br></pre></td></tr></table></figure><p>具体的配置，我们在 Redis持久化 中去给大家详细详解！</p><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p> 面试和工作，持久化都是重点！</p><p>Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能！</p><h2 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h2><blockquote><p>什么是RDB</p></blockquote><p>在主从复制中，rdb就是备用了！从机上面！</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/8bZ21fKTvtBWjdl.png"></p><p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快<br>照文件直接读到内存里。</p><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程<br>都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。<br>这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那<br>RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是<br>RDB，一般情况下不需要修改这个配置！</p><p>有时候在生产环境我们会将这个文件进行备份！</p><p><code>rdb保存的文件是dump.rdb都是在我们的配置文件中快照中进行配置的！</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/CYywKnkc1j4irWQ.png" alt="image.png"></p><blockquote><p>触发机制 </p></blockquote><ol><li>save的规则满足的情况下，会自动触发rdb规则</li><li>执行 flushall 命令，也会触发我们的rdb规则！</li><li>退出redis，也会产生 rdb 文件！</li></ol><p>备份就自动生成一个 dump.rdb</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/MPuOmgse2VhQpiz.png" alt="image.png"></p><blockquote><p>如果恢复rdb文件！</p></blockquote><ol><li>只需要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb 恢复其中<br>的数据！</li><li>查看需要存在的位置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get dir</span><br><span class="line">1) <span class="string">&quot;dir&quot;</span></span><br><span class="line">2) <span class="string">&quot;/usr/local/bin&quot;</span> <span class="comment"># 如果在这个目录下存在 dump.rdb 文件，启动就会自动恢复其中的数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>几乎就他自己默认的配置就够用了，但是我们还是需要去学习！</p></blockquote><p><strong>优点</strong>：</p><ol><li>适合大规模的数据恢复！</li><li>对数据的完整性要不高！<br><strong>缺点：</strong></li><li>需要一定的时间间隔进程操作！如果redis意外宕机了，这个最后一次修改数据就没有的了！</li><li>fork进程的时候，会占用一定的内容空间！！</li></ol><h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><p>将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部在执行一遍！</p><blockquote><p>是什么 </p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/R9bNlX8x27iBQtM.png" alt="image.png"></p><p>以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件<br>但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件<br>的内容将写指令从前到后执行一次以完成数据的恢复工作</p><p>Aof保存的是 appendonly.aof 文件</p><blockquote><p>append </p></blockquote><p> <img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/gh7NDSxLMc5eyvj.png" alt="image.png"></p><p> 默认是不开启的，我们需要手动进行配置！我们只需要将 appendonly 改为yes就开启了 aof！<br>重启，redis 就可以生效了！</p><p>如果这个 aof 文件有错位，这时候 redis 是启动不起来的吗，我们需要修复这个aof文件</p><p>redis 给我们提供了一个工具 <code>redis-check-aof --fix</code></p><p> <img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/CR783Gf9d5X46jY.png" alt="image.png"></p><blockquote><p>如果文件正常，重启就可以直接恢复了！</p></blockquote><p> <img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/kSuZWoPEqVidfaD.png" alt="image.png"></p><blockquote><p>重写规则说明</p></blockquote><p>aof 默认就是文件的无限追加，文件会越来越大！</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/i7jlzDIPphJ3k4K.png" alt="image.png"></p><p> 如果 aof 文件大于 64m，太大了！ fork一个新的进程来将我们的文件进行重写！</p><blockquote><p>优点和缺点！</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">appendonly no <span class="comment"># 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下，</span></span><br><span class="line">rdb完全够用！</span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span> <span class="comment"># 持久化的文件的名字</span></span><br><span class="line"><span class="comment"># appendfsync always # 每次修改都会 sync。消耗性能</span></span><br><span class="line">appendfsync everysec <span class="comment"># 每秒执行一次 sync，可能会丢失这1s的数据！</span></span><br><span class="line"><span class="comment"># appendfsync no # 不执行 sync，这个时候操作系统自己同步数据，速度最快！</span></span><br><span class="line"><span class="comment"># rewrite 重写，</span></span><br></pre></td></tr></table></figure><p>优点：</p><ol><li>每一次修改都同步，文件的完整会更加好！</li><li>每秒同步一次，可能会丢失一秒的数据</li><li>从不同步，效率最高的！<br>缺点：</li><li>相对于数据文件来说，aof远远大于 rdb，修复的速度也比 rdb慢！</li><li>Aof 运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化</li></ol><p><strong>扩展：</strong></p><ol><li>RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储</li><li>AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始<br>的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重<br>写，使得AOF文件的体积不至于过大。</li><li>只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化</li><li>同时开启两种持久化方式</li></ol><ul><li>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF<br>文件保存的数据集要比RDB文件保存的数据集要完整。</li><li>RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者<br>建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有<br>AOF可能潜在的Bug，留着作为一个万一的手段。</li></ul><ol start="5"><li>性能建议</li></ol><ul><li>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够<br>了，只保留 save 900 1 这条规则。</li><li>如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自<br>己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产<br>生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite<br>的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重<br>写可以改到适当的数值。</li><li>如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也<br>减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，<br>启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。</li></ul><h1 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h1><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。微信、<br>微博、关注系统！</p><p>Redis 客户端可以订阅任意数量的频道。</p><p>订阅/发布消息图：</p><p>第一个：消息发送者， 第二个：频道 第三个：消息订阅者！<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/DB7uzngTAlRO4by.png" alt="image.png"></p><p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的<br>关系：<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/1hJRPkSUxTDuWsp.png" alt="image.png"></p><p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户<br>端：<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/uzlj9fb23KLaerw.png" alt="image.png"></p><blockquote><p>命令</p></blockquote><p>这些命令被广泛用于构建即时通信应用，比如网络聊天室(chatroom)和实时广播、实时提醒等。</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/HWzekTxsLGJKQSt.png" alt="image.png"></p><blockquote><p>测试</p></blockquote><p><strong>订阅端:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE kuangshenshuo  <span class="comment"># 订阅一个频道 kuangshenshuo Reading messages... (press Ctrl-C to quit) </span></span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span> </span><br><span class="line">2) <span class="string">&quot;kuangshenshuo&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 等待读取推送的信息 </span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span>  <span class="comment"># 消息 </span></span><br><span class="line">2) <span class="string">&quot;kuangshenshuo&quot;</span>  <span class="comment"># 那个频道的消息</span></span><br><span class="line">3) <span class="string">&quot;hello,kuangshen&quot;</span>  <span class="comment"># 消息的具体内容</span></span><br><span class="line"></span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;kuangshenshuo&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello,redis&quot;</span></span><br></pre></td></tr></table></figure><p><strong>发送端:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PUBLISH kuangshenshuo <span class="string">&quot;hello,kuangshen&quot;</span>   <span class="comment"># 发布者发布消息到频道！</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH kuangshenshuo <span class="string">&quot;hello,redis&quot;</span>   <span class="comment"># 发布者发布消息到频道！</span></span><br><span class="line">(<span class="built_in">integer</span>) 1 </span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure><blockquote><p>原理</p></blockquote><p>Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，籍 此加深对 Redis 的理解。</p><p>Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。</p><p>微信：</p><p>通过 SUBSCRIBE 命令订阅某频道后，redis-server里维护了一个字典，字典的键是一个个 频道！， 而字典的值则是一个链表，链表中保存了所有订阅这个channel客户端。SUBSCRIBE 命令的关键， 就是将客户端添加到给定 channel的订阅链表中。</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/AcIqOSE3nyplQKM.png" alt="image.png"></p><p>通过 PUBLISH 命令向订阅者发送消息，redis-server会使用给定的频道作为键，它所维护的 channel 字典中查找记录了订阅这个频道的所有客户端的链表，遍历这表，将消息发布给所有订阅者。</p><p>Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，可以设定对某一个 key值进行消息发布及消息订阅，当一个key值上进行了消息发后，所有订阅它的客户端都会收到相应的消息。这一功能明显的用法就是用作实时消系统，比如普通的即时聊天，群聊等功能。</p><p><strong>使用场景：</strong></p><ol><li>实时消息系统！</li><li>事实聊天！（频道当做聊天室，将信息回显给所有人即可！） </li><li>订阅，关注系统都是可以的！ 稍微复杂的场景我们就会使用 消息中间件MQ</li></ol><h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p> 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）</p><p><code>数据的复制是单向的！只能由主节点复制到从节点</code>（主节点以写为主、从节点以读为主）。</p><p><code>默认情况下，每台Redis服务器都是主节点</code></p><p>一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。</p><p><strong>主从复制的作用主要包括：</strong></p><ol><li><code>数据冗余</code>：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。</li><li><code>故障恢复</code>：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种<code>服务冗余</code>的方式</li><li><code>负载均衡</code>：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。</li><li><code>高可用基石</code>：主从复制还是哨兵和集群能够实施的基础。</li></ol><p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下：</p><ol><li><p>从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较 大；</p></li><li><p>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有 内存用作Redis存储内存，一般来说，单台Redis大使用内存不应该超过20G。</p></li><li><p>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。</p></li></ol><p>对于这种场景，我们可以使如下这种架构： </p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/1Ee5YtPLTBZkyOJ.png"></p><p>主从复制，读写分离！80%的情况下都是在进行读操作！减缓服务器的压力！架构中经常使用！  一主 二从！</p><p>只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用Redis！</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>只配置从库，不用配置主库!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication   <span class="comment"># 查看当前库的信息 # Replication </span></span><br><span class="line">role:master  <span class="comment"># 角色  </span></span><br><span class="line">master connected_slaves:0 <span class="comment">#  没有从机</span></span><br><span class="line">master_replid:b63c90e6c501143759cb0e7f450bd1eb0c70882a</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0 </span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0 </span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0 </span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure><p>复制3个配置文件，然后修改对应的信息 </p><ol><li>端口</li><li>pid 名字 </li><li>log文件名字</li><li>dump.rdb 名字 </li></ol><p>修改完毕之后，启动我们的3个redis服务器，可以通过进程信息查看！</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/7Qi6C4oDYBI1uHZ.png" alt="image.png"></p><h2 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h2><p><code>默认情况下，每台Redis服务器都是主节点；我们一般情况下只用配置从就好了！</code></p><p>认老大！  一主 （79）二从（80，81）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379   <span class="comment">#  SLAVEOF host 6379  找谁当自己的老大！</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; info replication </span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave  <span class="comment"># 当前角色是从机</span></span><br><span class="line">master_host:127.0.0.1   <span class="comment"># 可以的看到主机的信息 </span></span><br><span class="line">master_port:6379 </span><br><span class="line">master_link_status:up </span><br><span class="line">master_last_io_seconds_ago:3 </span><br><span class="line">master_sync_in_progress:0 </span><br><span class="line">slave_repl_offset:14 </span><br><span class="line">slave_priority:100 </span><br><span class="line">slave_read_only:1 </span><br><span class="line">connected_slaves:0 master_replid:a81be8dd257636b2d3e7a9f595e69d73ff03774e</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:14</span><br><span class="line">second_repl_offset:-1 </span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1 </span><br><span class="line">repl_backlog_histlen:14</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在主机中查看！</span></span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication </span></span><br><span class="line">role:master connected_slaves:1  <span class="comment"># 多了从机的配置</span></span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=42,lag=1    <span class="comment"># 多了从机的配置</span></span><br><span class="line">master_replid:a81be8dd257636b2d3e7a9f595e69d73ff03774e</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:42</span><br><span class="line">second_repl_offset:-1 </span><br><span class="line">repl_backlog_active:1 </span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1 </span><br><span class="line">repl_backlog_histlen:42 </span><br></pre></td></tr></table></figure><p>如果两个都配置完了，就是有两个从机</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/NaXd9sivbnVCc8M.png" alt="image.png"></p><p>真实的从主配置应该在配置文件中配置，这样的话是永久的，我们这里用的是命令，暂时的！</p><blockquote><p>细节</p></blockquote><p>主机可以写，从机不能写只能读！主机中的所有信息和数据，都会自动从机保存！<br>主机写：<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/gxmYE634XbqQteL.png" alt="image.png"></p><p>从机只能读取内容！</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/T68wEHfrcv2MC5x.png" alt="image.png"></p><p>测试：主机断开连接，从机依旧连接到主机的，但是没有写操作，这个候，主机如果回来了，从机依旧可以直接获取到主机写的信息！</p><p>如果是使用命令行，来配置的主从，这个时候如果重启了，就会变回主机！只要变为从机，立马就会从<br>主机中获取值！</p><blockquote><p>复制原理</p></blockquote><p>Slave 启动成功连接到 master 后会发送一个sync同步命令</p><p>Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行<br>完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</p><p>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p><p>增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步</p><p>但是只要是重新连接master，一次完全同步（全量复制）将被自动执行！ 我们的数据一定可以在从机中<br>看到！</p><blockquote><p>层层链路</p></blockquote><p>上一个M链接下一个 S！</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/K6AwES57XDjmBQh.png" alt="image.png"></p><p>这时候也可以完成我们的主从复制！</p><blockquote><p>如果没有老大了，这个时候能不能选择一个老大出来呢？ 手动！</p></blockquote><p><code>谋朝篡位</code></p><p>如果主机断开了连接，我们可以使用 <code>SLAVEOF no one</code>让自己变成主机！其他的节点就可以手动连</p><p>接到最新的这个主节点（手动）！如果这个时候老大修复了，那就重新连接！</p><h1 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h1><p>（自动选举老大的模式）</p><blockquote><p>概述</p></blockquote><p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题。</p><p>谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p><p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独<br>立运行。<code>其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/sYjzKWD3mJ9C7UB.png" alt="image.png"></p><p>这里的哨兵有两个作用</p><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li><li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服<br>务器，修改配置文件，让它们切换主机。</li></ul><p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。<br>各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/RLzoX5jQ4WbqkNM.png" alt="image.png"></p><p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认<br>为主服务器不可用，这个现象成为 <strong><code>主观下线</code></strong> 。当后面的哨兵也检测到主服务器不可用，并且数量达到一<br>定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。<br>切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<br>**<code>客观下线</code>**。</p><blockquote><p>测试！</p></blockquote><p>我们目前的状态是 一主二从！</p><ol><li>配置哨兵配置文件 sentinel.conf</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sentinel monitor 被监控的名称  host  port  1</span></span><br><span class="line"></span><br><span class="line">sentinel montitor myredis  127.0.0.1  6379 1 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>后面的这个数字1，代表主机挂了，slave投票看让谁接替成为主机，票数最多的，就会成为主机！</p><ol start="2"><li>启动哨兵！</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[root@kuangshen bin]<span class="comment"># redis-sentinel kconfig/sentinel.conf</span></span><br><span class="line">26607:X 31 Mar 2020 21:13:10.027 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">26607:X 31 Mar 2020 21:13:10.027 <span class="comment"># Redis version=5.0.8, bits=64,</span></span><br><span class="line">commit=00000000, modified=0, pid=26607, just started</span><br><span class="line">26607:X 31 Mar 2020 21:13:10.027 <span class="comment"># Configuration loaded</span></span><br><span class="line"></span><br><span class="line">                _._</span><br><span class="line">            _.-``__ <span class="string">&#x27;&#x27;</span>-._</span><br><span class="line">        _.-`` `. `_. <span class="string">&#x27;&#x27;</span>-._       Redis 5.0.8 (00000000/0) 64 bit</span><br><span class="line">    .-`` .-```. ```\/ _.,_ <span class="string">&#x27;&#x27;</span>-._</span><br><span class="line">    ( <span class="string">&#x27; , .-` | `, )` _.-&#x27;</span>|         Running <span class="keyword">in</span> sentinel mode</span><br><span class="line">    |`-._`-...-` __...-.``-._|<span class="string">&#x27;        Port: 26379</span></span><br><span class="line"><span class="string">    | `-._ `._ / _.-&#x27;</span> |             PID: 26607</span><br><span class="line">    `-._ `-._ `-./ _.-<span class="string">&#x27; _.-&#x27;</span></span><br><span class="line">    |`-._`-._ `-.__.-<span class="string">&#x27; _.-&#x27;</span>_.-<span class="string">&#x27;|</span></span><br><span class="line"><span class="string">    | `-._`-._ _.-&#x27;</span>_.-<span class="string">&#x27; |            http://redis.io</span></span><br><span class="line"><span class="string">    `-._ `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27; _.-&#x27;</span></span><br><span class="line">    |`-._`-._ `-.__.-<span class="string">&#x27; _.-&#x27;</span>_.-<span class="string">&#x27;|</span></span><br><span class="line"><span class="string">    | `-._`-._ _.-&#x27;</span>_.-<span class="string">&#x27; |</span></span><br><span class="line"><span class="string">    `-._ `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27; _.-&#x27;</span></span><br><span class="line"></span><br><span class="line">26607:X 31 Mar 2020 21:13:10.029 <span class="comment"># WARNING: The TCP backlog setting of 511</span></span><br><span class="line">cannot be enforced because /proc/sys/net/core/somaxconn is <span class="built_in">set</span> to the lower value</span><br><span class="line">of 128.</span><br><span class="line">26607:X 31 Mar 2020 21:13:10.031 <span class="comment"># Sentinel ID is</span></span><br><span class="line">4c780da7e22d2aebe3bc20c333746f202ce72996</span><br><span class="line">26607:X 31 Mar 2020 21:13:10.031 <span class="comment"># +monitor master myredis 127.0.0.1 6379 quorum</span></span><br><span class="line">1</span><br><span class="line">26607:X 31 Mar 2020 21:13:10.031 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @</span><br><span class="line">myredis 127.0.0.1 6379</span><br><span class="line">26607:X 31 Mar 2020 21:13:10.033 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @</span><br><span class="line">myredis 127.0.0.1 6379</span><br></pre></td></tr></table></figure><p>如果Master 节点断开了，这个时候就会从从机中随机选择一个服务器！ （这里面有一个投票算法！）</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/NLGfb7KyCtZJU2o.png" alt="image.png"></p><p>哨兵日志！</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/N64mMouFDGfrsQT.png" alt="image.png"></p><p>如果主机此时回来了，只能归并到新的主机下，当做从机，这就是哨兵模式的规则！</p><blockquote><p>哨兵模式</p></blockquote><p><strong>优点：</strong></p><ol><li>哨兵集群，基于主从复制模式，所有的主从配置优点，它全有</li><li>主从可以切换，故障可以转移，系统的可用性就会更好</li><li>哨兵模式就是主从模式的升级，手动到自动，更加健壮！</li></ol><p><strong>缺点：</strong></p><ol><li>Redis 不好啊在线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦！</li><li>实现哨兵模式的配置其实是很麻烦的，里面有很多选择！</li></ol><blockquote><p>哨兵模式的全部配置！</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example sentinel.conf</span></span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line">dir /tmp</span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port</span></span><br><span class="line"><span class="comment"># master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span></span><br><span class="line"><span class="comment"># quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供</span></span><br><span class="line">密码</span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span></span><br><span class="line">这个数字越小，完成failover所需的时间就越长，</span><br><span class="line">但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span><br><span class="line">可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那</span></span><br><span class="line">里同步数据时。</span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。</span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，</span></span><br><span class="line">slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知</span></span><br><span class="line">相关人员。</span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），</span></span><br><span class="line">将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信</span><br><span class="line">息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配</span><br><span class="line">置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无</span><br><span class="line">法正常启动成功。</span><br><span class="line"><span class="comment">#通知脚本</span></span><br><span class="line"><span class="comment"># shell编程</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已</span></span><br><span class="line">经发生改变的信息。</span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个。</span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通</span></span><br><span class="line">信的</span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh <span class="comment"># 一般都是由运维来配</span></span><br><span class="line">置！</span><br></pre></td></tr></table></figure><p>社会目前程序员饱和（初级和中级）、高级程序员重金难求！（提升自己！）</p><h1 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h1><p>SpringBoot 操作数据：spring-data jpa jdbc mongodb redis！</p><p>SpringData 也是和 SpringBoot 齐名的项目！</p><p>说明： 在 SpringBoot2.x 之后，原来使用的jedis 被替换为了 lettuce?</p><p>jedis : 采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用 jedis pool 连接<br>池！ 更像 BIO 模式</p><p>lettuce : 采用netty，实例可以再多个线程中进行共享，不存在线程不安全的情况！可以减少线程数据<br>了，更像 NIO 模式</p><p>源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span> <span class="comment">// 我们可以自己定义一个</span></span><br><span class="line">redisTemplate来替换这个默认的！</span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt;redisTemplate(RedisConnectionFactory redisConnectionFactory)<span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="comment">// 默认的 RedisTemplate 没有过多的设置，redis 对象都是需要序列化！</span></span><br><span class="line">        <span class="comment">// 两个泛型都是 Object, Object 的类型，我们后使用需要强制转换 &lt;String, Object&gt;</span></span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span> <span class="comment">// 由于 String 是redis中最常使用的类型，所以说单独提出来了一</span></span><br><span class="line">个bean！</span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span><span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>整合测试一下</p></blockquote><ol><li>导入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 操作redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置连接</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置redis</span></span><br><span class="line">spring.redis.host=127.0.0.1</span><br><span class="line">spring.redis.port=6379</span><br></pre></td></tr></table></figure><ol start="3"><li>测试！ </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Redis02SpringbootApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// redisTemplate 操作不同的数据类型，api和我们的指令是一样的</span></span><br><span class="line">        <span class="comment">// opsForValue 操作字符串 类似String</span></span><br><span class="line">        <span class="comment">// opsForList 操作List 类似List</span></span><br><span class="line">        <span class="comment">// opsForSet</span></span><br><span class="line">        <span class="comment">// opsForHash</span></span><br><span class="line">        <span class="comment">// opsForZSet</span></span><br><span class="line">        <span class="comment">// opsForGeo</span></span><br><span class="line">        <span class="comment">// opsForHyperLogLog</span></span><br><span class="line">        <span class="comment">// 除了进本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务，和基本的 CRUD</span></span><br><span class="line">        <span class="comment">// 获取redis的连接对象</span></span><br><span class="line">        <span class="comment">// RedisConnection connection =</span></span><br><span class="line">        redisTemplate.getConnectionFactory().getConnection();</span><br><span class="line">        <span class="comment">// connection.flushDb();</span></span><br><span class="line">        <span class="comment">// connection.flushAll();</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;mykey&quot;</span>,<span class="string">&quot;关注狂神说公众号&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;mykey&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/GiCTRI3wcvOqrDe.png" alt="image.png"><br>关于对象的保存：</p><p><code>所有的对象都需要序列化！！！</code></p><p>我们来编写一个自己的 RedisTemplete</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">ashpackage com.kuang.config;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这是我给大家写好的一个固定模板，大家在企业中，拿去就可以直接使用！</span></span><br><span class="line">    <span class="comment">// 自己定义了一个 RedisTemplate</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 我们为了自己开发方便，一般直接使用 &lt;String,Object&gt;</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;String,Object&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">// Json序列化配置</span></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span></span><br><span class="line">        Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// String 的序列化</span></span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>所有的redis操作，其实对于java开发人员来说，十分的简单，更重要是要去理解redis的思想和每一种数<br>据结构的用处和作用场景！</p><h1 id="Redis缓存穿透和雪崩"><a href="#Redis缓存穿透和雪崩" class="headerlink" title="Redis缓存穿透和雪崩"></a>Redis缓存穿透和雪崩</h1><blockquote><p>服务的高可用问题！</p></blockquote><p>在这里我们不会详细的区分析解决方案的底层！</p><p>Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一<br>些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据<br>的一致性要求很高，那么就不能使用缓存。</p><p>另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/aG9wODIJn7AEzej.png" alt="image.png"></p><h2 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h2><blockquote><p>概念</p></blockquote><p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒杀！），于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了<br>缓存穿透。</p><blockquote><p>解决方案</p></blockquote><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则<br>丢弃，从而避免了对底层存储系统的查询压力；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/nhHiCqjOGVJlWUp.png"></p><h3 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h3><p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数<br>据将会从缓存中获取，保护了后端数据源；</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/pKjOfIo76eZ2wc9.png"></p><p>但是这种方法会存在两个问题：</p><ol><li>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多<br>的空值的键；</li><li>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于<br>需要保持一致性的业务会有影响。</li></ol><h2 id="缓存击穿（量太大，缓存过期！）"><a href="#缓存击穿（量太大，缓存过期！）" class="headerlink" title="缓存击穿（量太大，缓存过期！）"></a>缓存击穿（量太大，缓存过期！）</h2><blockquote><p>概述</p></blockquote><p>这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中<br>对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一<br>个屏障上凿开了一个洞。</p><p>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访<br>问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。</p><blockquote><p>解决方案</p></blockquote><p><strong>设置热点数据永不过期</strong><br>从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。</p><p><strong>加互斥锁</strong></p><p>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布<br>式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考<br>验很大。<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/x34TrX7OavufWtc.png" alt="image.png"></p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><blockquote><p>概念</p></blockquote><p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。Redis 宕机！</p><p>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/uQKU2tR1b487NhL.png"></p><p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</p><blockquote><p>解决方案</p></blockquote><p><strong>redis高可用</strong><br>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续<br>工作，其实就是搭建的集群。（异地多活！）</p><p><strong>限流降级（在SpringCloud讲解过！）</strong></p><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对<br>某个key只允许一个线程查询数据和写缓存，其他线程等待。</p><p><strong>数据预热</strong></p><p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数<br>据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让<br>缓存失效的时间点尽量均匀。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学无止境&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h1&gt;&lt;p&gt;Redis 事务本质：一组命令的集合！ 一个事务中的所有命令都</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://qwq3.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础学习</title>
    <link href="https://qwq3.top/posts/5aaa.html"/>
    <id>https://qwq3.top/posts/5aaa.html</id>
    <published>2021-06-23T09:48:21.000Z</published>
    <updated>2021-11-18T04:02:22.742Z</updated>
    
    <content type="html"><![CDATA[<p>最近在B站跟着狂神学习，真是个宝藏男孩，下面是狂神的笔记~</p><h1 id="Nosql概述"><a href="#Nosql概述" class="headerlink" title="Nosql概述"></a>Nosql概述</h1><h2 id="为什么使用Nosql"><a href="#为什么使用Nosql" class="headerlink" title="为什么使用Nosql"></a>为什么使用Nosql</h2><blockquote><p>1、单机Mysql时代</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/2020082010365930.png" alt="在这里插入图片描述"></p><p>90年代,一个网站的访问量一般不会太大，单个数据库完全够用。随着用户增多，网站出现以下问题</p><ol><li> 数据量增加到一定程度，单机数据库就放不下了</li><li> 数据的索引（B+ Tree）,一个机器内存也存放不下</li><li> 访问量变大后（读写混合），一台服务器承受不住。</li></ol><blockquote><p>2、Memcached(缓存) + Mysql + 垂直拆分（读写分离）</p></blockquote><p>网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据库的压力，我们可以使用缓存来保证效率！</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/20200820103713734.png"></p><p>优化过程经历了以下几个过程：</p><ol><li><p> 优化数据库的数据结构和索引(难度大)</p></li><li><p> 文件缓存，通过IO流获取比每次都访问数据库效率略高，但是流量爆炸式增长时候，IO流也承受不了</p></li><li><p> MemCache,当时最热门的技术，通过在数据库和数据库访问层之间加上一层缓存，第一次访问时查询数据库，将结果保存到缓存，后续的查询先检查缓存，若有直接拿去使用，效率显著提升。</p></li></ol><blockquote><p>3、分库分表 + 水平拆分 + Mysql集群</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/20200820103739584.png"></p><blockquote><p>4、如今最近的年代</p></blockquote><p> 如今信息量井喷式增长，各种各样的数据出现（用户定位数据，图片数据等），大数据的背景下关系型数据库（RDBMS）无法满足大量数据要求。Nosql数据库就能轻松解决这些问题。</p><blockquote><p>目前一个基本的互联网项目</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/20200820103804572.png"></p><blockquote><p>为什么要用NoSQL ？</p></blockquote><p>用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！<br>这时候我们就需要使用NoSQL数据库的，Nosql可以很好的处理以上的情况！</p><h2 id="什么是Nosql"><a href="#什么是Nosql" class="headerlink" title="什么是Nosql"></a>什么是Nosql</h2><p>Not Only Structured Query Language</p><p>关系型数据库：列+行，同一个表下数据的结构是一样的。</p><p>非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。</p><p>NoSQL泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的。</p><h2 id="Nosql特点"><a href="#Nosql特点" class="headerlink" title="Nosql特点"></a>Nosql特点</h2><ol><li><p>方便扩展（数据之间没有关系，很好扩展！）</p></li><li><p>大数据量高性能（Redis一秒可以写8万次，读11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！）</p></li><li><p>数据类型是多样型的！（不需要事先设计数据库，随取随用）</p></li><li><p>传统的 RDBMS 和 NoSQL</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">传统的 RDBMS(关系型数据库)</span><br><span class="line">- 结构化组织</span><br><span class="line">- SQL</span><br><span class="line">- 数据和关系都存在单独的表中 row col</span><br><span class="line">- 操作，数据定义语言</span><br><span class="line">- 严格的一致性</span><br><span class="line">- 基础的事务</span><br><span class="line">- ...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Nosql</span><br><span class="line">- 不仅仅是数据</span><br><span class="line">- 没有固定的查询语言</span><br><span class="line">- 键值对存储，列存储，文档存储，图形数据库（社交关系）</span><br><span class="line">- 最终一致性</span><br><span class="line">- CAP定理和BASE</span><br><span class="line">- 高性能，高可用，高扩展</span><br><span class="line">- ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>了解：3V + 3高</p></blockquote><p>大数据时代的3V ：主要是<strong>描述问题</strong>的</p><p>海量Velume</p><p>多样Variety</p><p>实时Velocity</p><p>大数据时代的3高 ： 主要是对<strong>程序的要求</strong></p><p>高并发</p><p>高可扩</p><p>高性能</p><p>真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强的。</p><h2 id="阿里巴巴演进分析"><a href="#阿里巴巴演进分析" class="headerlink" title="阿里巴巴演进分析"></a>阿里巴巴演进分析</h2><p>推荐阅读：阿里云的这群疯子<a href="https://yq.aliyun.com/articles/653511">https://yq.aliyun.com/articles/653511</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/20200820103829446.png"></p><p><img src= "/img/loading.gif" data-lazy-src="image/20200820103851613.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 商品信息</span><br><span class="line">- 一般存放在关系型数据库：Mysql,阿里巴巴使用的Mysql都是经过内部改动的。</span><br><span class="line"></span><br><span class="line"># 商品描述、评论(文字居多)</span><br><span class="line">- 文档型数据库：MongoDB</span><br><span class="line"></span><br><span class="line"># 图片</span><br><span class="line">- 分布式文件系统 FastDFS</span><br><span class="line">- 淘宝：TFS</span><br><span class="line">- Google: GFS</span><br><span class="line">- Hadoop: HDFS</span><br><span class="line">- 阿里云: oss</span><br><span class="line"></span><br><span class="line"># 商品关键字 用于搜索</span><br><span class="line">- 搜索引擎：solr,elasticsearch</span><br><span class="line">- 阿里：Isearch 多隆</span><br><span class="line"></span><br><span class="line"># 商品热门的波段信息</span><br><span class="line">- 内存数据库：Redis，Memcache</span><br><span class="line"></span><br><span class="line"># 商品交易，外部支付接口</span><br><span class="line">- 第三方应用</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Nosql的四大分类"><a href="#Nosql的四大分类" class="headerlink" title="Nosql的四大分类"></a>Nosql的四大分类</h2><blockquote><p>KV键值对</p></blockquote><ul><li>新浪：Redis</li><li>美团：Redis + Tair</li><li>阿里、百度：Redis + Memcache</li></ul><blockquote><p>文档型数据库（bson数据格式）：</p></blockquote><ul><li><strong>MongoDB(掌握)</strong></li></ul><p>基于分布式文件存储的数据库。C++编写，用于处理大量文档。<br>MongoDB是RDBMS和NoSQL的中间产品。MongoDB是非关系型数据库中功能最丰富的，NoSQL中最像关系型数据库的数据库。</p><ul><li>ConthDB</li></ul><blockquote><p>列存储数据库</p></blockquote><ul><li>HBase(大数据必学)</li><li>分布式文件系统</li></ul><blockquote><p>图关系数据库</p></blockquote><p>用于广告推荐，社交网络</p><ul><li><strong>Neo4j</strong>、InfoGrid</li></ul><table><thead><tr><th><strong>分类</strong></th><th><strong>Examples举例</strong></th><th><strong>典型应用场景</strong></th><th><strong>数据模型</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>键值对（key-value）</strong></td><td>Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB</td><td>内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。</td><td>Key 指向 Value 的键值对，通常用hash table来实现</td><td>查找速度快</td><td>数据无结构化，通常只被当作字符串或者二进制数据</td></tr><tr><td><strong>列存储数据库</strong></td><td>Cassandra, HBase, Riak</td><td>分布式的文件系统</td><td>以列簇式存储，将同一列数据存在一起</td><td>查找速度快，可扩展性强，更容易进行分布式扩展</td><td>功能相对局限</td></tr><tr><td><strong>文档型数据库</strong></td><td>CouchDB, MongoDb</td><td>Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容）</td><td>Key-Value对应的键值对，Value为结构化数据</td><td>数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构</td><td>查询性能不高，而且缺乏统一的查询语法。</td></tr><tr><td><strong>图形(Graph)数据库</strong></td><td>Neo4J, InfoGrid, Infinite Graph</td><td>社交网络，推荐系统等。专注于构建关系图谱</td><td>图结构</td><td>利用图结构相关算法。比如最短路径寻址，N度关系查找等</td><td>很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群</td></tr></tbody></table><h1 id="Redis-入门"><a href="#Redis-入门" class="headerlink" title="Redis 入门"></a>Redis 入门</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>Redis是什么？</p></blockquote><p>Redis（Remote Dictionary Server )，即远程字典服务。</p><p>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、<strong>Key-Value</strong>数据库，并提供多种语言的API。</p><p>与memcached一样，为了保证效率，<strong>数据都是缓存在内存中</strong>。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p><blockquote><p>Redis能该干什么？</p></blockquote><ol><li>内存存储、持久化，内存是断电即失的，所以需要持久化（RDB、AOF）</li><li>高效率、用于高速缓冲</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器、计数器(eg：浏览量)</li><li>。。。</li></ol><blockquote><p>特性</p></blockquote><ul><li><p>多样的数据类型</p></li><li><p>持久化</p></li><li><p>集群</p></li><li><p>事务</p></li><li><p>…<br>…</p></li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>官网：<a href="https://redis.io/">https://redis.io/</a></p><p>推荐使用Linux服务器学习。</p><p>windows版本的Redis已经停更很久了…</p><h2 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h2><p><a href="https://github.com/dmajkic/redis">https://github.com/dmajkic/redis</a></p><ol><li><p>解压安装包<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/20200820103950934.png"></p></li><li><p>开启redis-server.exe</p></li><li><p>启动redis-cli.exe测试</p></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/20200820103950934.png"></p><h2 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h2><ol><li><p>下载安装包！redis-5.0.8.tar.gz</p></li><li><p>解压Redis的安装包！程序一般放在 /opt 目录下</p></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/20200820104016426.png"></p><ol start="3"><li>基本环境安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc-c++</span><br><span class="line"><span class="comment"># 然后进入redis目录下执行</span></span><br><span class="line"><span class="comment"># 如果安装redies6.X 版本 , 出现error错误 , 重新回退到5.X版本 ,</span></span><br><span class="line"><span class="comment">## 或者安装一个依赖  yum install tcl  出错是因为6.X的redis需要5.3以上的版本的gcc </span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 然后执行</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/20200820104048327.png"></p><ol start="4"><li><p>redis默认安装路径 /usr/local/bin<br><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/20200820104140692.png"></p></li><li><p>将redis的配置文件复制到 程序安装目录 /usr/local/bin/kconfig下</p></li></ol><p><img src= "/img/loading.gif" data-lazy-src="image/20200820104157817.png"></p><ol start="6"><li>redis默认不是后台启动的，需要修改配置文件！</li></ol><p><img src= "/img/loading.gif" data-lazy-src="image/20200820104213706.png"></p><ol start="7"><li>通过制定的配置文件启动redis服务</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/20200820104228556.png"></p><ol start="8"><li>使用redis-cli连接指定的端口号测试，Redis的默认端口6379</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/20200820104243223.png"></p><ol start="9"><li>查看redis进程是否开启</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/20200820104300532.png"></p><ol start="10"><li>关闭Redis服务 shutdown</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/20200820104314297.png"></p><ol start="11"><li><p>再次查看进程是否存在</p></li><li><p>后面我们会使用单机多Redis启动集群测试</p></li></ol><h2 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h2><p><strong>redis-benchmark</strong>                             Redis官方提供的性能测试工具，参数选项如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/20200513214125892.png"></p><h3 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试：100个并发连接 100000请求</span></span><br><span class="line">redis-benchmark -h localhost -p 6379 -c 100 -n 100000</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/20200820104343472.png"></p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><blockquote><p>redis默认有16个数据库</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/20200820104357466.png"></p><p>默认使用的第0个;</p><p>16个数据库为：DB 0~DB 15<br>默认使用DB 0 ，可以使用select n切换到DB n，dbsize可以查看当前数据库的大小，与key数量相关。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get databases <span class="comment"># 命令行查看数据库数量databases</span></span><br><span class="line">1) <span class="string">&quot;databases&quot;</span></span><br><span class="line">2) <span class="string">&quot;16&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; select 8 <span class="comment"># 切换数据库 DB 8</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[8]&gt; dbsize <span class="comment"># 查看数据库大小</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同数据库之间 数据是不能互通的，并且dbsize 是根据库中key的个数。</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name sakura </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SELECT 8</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[8]&gt; get name <span class="comment"># db8中并不能获取db0中的键值对。</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379[8]&gt; DBSIZE</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379[8]&gt; SELECT 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;counter:__rand_int__&quot;</span></span><br><span class="line">2) <span class="string">&quot;mylist&quot;</span></span><br><span class="line">3) <span class="string">&quot;name&quot;</span></span><br><span class="line">4) <span class="string">&quot;key:__rand_int__&quot;</span></span><br><span class="line">5) <span class="string">&quot;myset:__rand_int__&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; DBSIZE <span class="comment"># size和key个数相关</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>keys</code>：查看当前数据库中所有的key。</p><p><code>flushdb</code>：清空当前数据库中的键值对。</p><p><code>flushall</code>：清空所有数据库的键值对。</p><blockquote><p>Redis是单线程的，Redis是基于内存操作的。</p></blockquote><p>所以Redis的性能瓶颈不是CPU,而是机器内存和网络带宽。</p><p>那么为什么Redis的速度如此快呢，性能这么高呢？QPS达到10W+</p><blockquote><p>Redis为什么单线程还这么快？</p></blockquote><ul><li>误区1：高性能的服务器一定是多线程的？</li><li>误区2：多线程（CPU上下文会切换！）一定比单线程效率高！</li></ul><p><strong>核心</strong>：Redis是将所有的数据放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！），==对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的==，在内存存储数据情况下，单线程就是最佳的方案。</p><h1 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h1><p> Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作<strong>数据库</strong>，<strong>高速缓存</strong>和<strong>消息队列代理</strong>。它支持<a href="https://www.redis.net.cn/tutorial/3508.html">字符串</a>、<a href="https://www.redis.net.cn/tutorial/3509.html">哈希表</a>、<a href="https://www.redis.net.cn/tutorial/3510.html">列表</a>、<a href="https://www.redis.net.cn/tutorial/3511.html">集合</a>、<a href="https://www.redis.net.cn/tutorial/3512.html">有序集合</a>，<a href="https://www.redis.net.cn/tutorial/3508.html">位图</a>，<a href="https://www.redis.net.cn/tutorial/3513.html">hyperloglogs</a>等数据类型。内置复制、<a href="https://www.redis.net.cn/tutorial/3516.html">Lua脚本</a>、LRU收回、<a href="https://www.redis.net.cn/tutorial/3515.html">事务</a>以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动<a href="https://www.redis.net.cn/tutorial/3524.html">分区</a>。</p><h2 id="Redis-key"><a href="#Redis-key" class="headerlink" title="Redis-key"></a>Redis-key</h2><blockquote><p>在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作。</p></blockquote><p>下面学习的命令：</p><ul><li>   <code>exists key</code>：判断键是否存在</li><li>   <code>del key</code>：删除键值对</li><li>   <code>move key db</code>：将键值对移动到指定数据库</li><li>   <code>expire key second</code>：设置键值对的过期时间</li><li>   <code>type key</code>：查看value的数据类型</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys * <span class="comment"># 查看当前数据库所有key</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name qinjiang <span class="comment"># set key</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 20</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; move age 1 <span class="comment"># 将键值对移动到指定数据库</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; EXISTS age <span class="comment"># 判断键是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 不存在</span></span><br><span class="line">127.0.0.1:6379&gt; EXISTS name</span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 存在</span></span><br><span class="line">127.0.0.1:6379&gt; SELECT 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379[1]&gt; del age <span class="comment"># 删除键值对</span></span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 删除个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 20</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; EXPIRE age 15 <span class="comment"># 设置键值对的过期时间</span></span><br><span class="line"></span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 设置成功 开始计数</span></span><br><span class="line">127.0.0.1:6379&gt; ttl age <span class="comment"># 查看key的过期剩余时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 13</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -2 <span class="comment"># -2 表示key过期，-1表示key未设置过期时间</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get age <span class="comment"># 过期的key 会被自动delete</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> name <span class="comment"># 查看value的数据类型</span></span><br><span class="line">string</span><br></pre></td></tr></table></figure><p>关于<code>TTL</code>命令</p><p>Redis的key，通过TTL命令返回key的过期时间，一般来说有3种：</p><ol><li> 当前key没有设置过期时间，所以会返回-1.</li><li> 当前key有设置过期时间，而且key已经过期，所以会返回-2.</li><li> 当前key有设置过期时间，且key还没有过期，故会返回key的正常剩余时间.</li></ol><p>关于重命名<code>RENAME</code>和<code>RENAMENX</code></p><ul><li><code>RENAME key newkey</code>修改 key 的名称</li><li><code>RENAMENX key newkey</code>仅当 newkey 不存在时，将 key 改名为 newkey 。</li></ul><p>更多命令学习：<a href="https://www.redis.net.cn/order/">https://www.redis.net.cn/order/</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/image-20210624094631057.png"></p><h2 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h2><p>普通的set、get直接略过。</p><table><thead><tr><th>命令</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>APPEND key value</code></td><td>向指定的key的value后追加字符串</td><td>127.0.0.1:6379&gt; set msg hello OK 127.0.0.1:6379&gt; append msg “ world” (integer) 11 127.0.0.1:6379&gt; get msg “hello world”</td></tr><tr><td><code>DECR/INCR key</code></td><td>将指定key的value数值进行+1/-1(仅对于数字)</td><td>127.0.0.1:6379&gt; set age 20 OK 127.0.0.1:6379&gt; incr age (integer) 21 127.0.0.1:6379&gt; decr age (integer) 20</td></tr><tr><td><code>INCRBY/DECRBY key n</code></td><td>按指定的步长对数值进行加减</td><td>127.0.0.1:6379&gt; INCRBY age 5 (integer) 25 127.0.0.1:6379&gt; DECRBY age 10 (integer) 15</td></tr><tr><td><code>INCRBYFLOAT key n</code></td><td>为数值加上浮点型数值</td><td>127.0.0.1:6379&gt; INCRBYFLOAT age 5.2 “20.2”</td></tr><tr><td><code>STRLEN key</code></td><td>获取key保存值的字符串长度</td><td>127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; STRLEN msg (integer) 11</td></tr><tr><td><code>GETRANGE key start end</code></td><td>按起止位置获取字符串（闭区间，起止位置都取）</td><td>127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; GETRANGE msg 3 9 “lo worl”</td></tr><tr><td><code>SETRANGE key offset value</code></td><td>用指定的value 替换key中 offset开始的值</td><td>127.0.0.1:6379&gt; SETRANGE msg 2 hello (integer) 7 127.0.0.1:6379&gt; get msg “tehello”</td></tr><tr><td><code>GETSET key value</code></td><td>将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td><td>127.0.0.1:6379&gt; GETSET msg test “hello world”</td></tr><tr><td><code>SETNX key value</code></td><td>仅当key不存在时进行set</td><td>127.0.0.1:6379&gt; SETNX msg test (integer) 0 127.0.0.1:6379&gt; SETNX name sakura (integer) 1</td></tr><tr><td><code>SETEX key seconds value</code></td><td>set 键值对并设置过期时间</td><td>127.0.0.1:6379&gt; setex name 10 root OK 127.0.0.1:6379&gt; get name (nil)</td></tr><tr><td><code>MSET key1 value1 [key2 value2..]</code></td><td>批量set键值对</td><td>127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 OK</td></tr><tr><td><code>MSETNX key1 value1 [key2 value2..]</code></td><td>批量设置键值对，仅当参数中所有的key都不存在时执行</td><td>127.0.0.1:6379&gt; MSETNX k1 v1 k4 v4 (integer) 0</td></tr><tr><td><code>MGET key1 [key2..]</code></td><td>批量获取多个key保存的值</td><td>127.0.0.1:6379&gt; MGET k1 k2 k3 1) “v1” 2) “v2” 3) “v3”</td></tr><tr><td><code>PSETEX key milliseconds value</code></td><td>和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，</td><td></td></tr><tr><td><code>getset key value</code></td><td>如果不存在值，则返回nil，如果存在值，获取原来的值，并设置新的值</td><td></td></tr></tbody></table><p>String类似的使用场景：value除了是字符串还可以是数字，用途举例：</p><ul><li>计数器</li><li>统计多单位的数量：uid:123666：follow 0</li><li>粉丝数</li><li>对象存储缓存</li></ul><h2 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h2><blockquote><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p><p>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p></blockquote><p>首先我们列表，可以经过规则定义将其变为队列、栈、双端队列等</p><p><img src= "/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/20200820104440398.png"></p><p>正如图Redis中List是可以进行双端操作的，所以命令也就分为了LXXX和RLLL两类，有时候L也表示List例如LLEN</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>LPUSH/RPUSH key value1[value2..]</code></td><td>从左边/右边向列表中PUSH值(一个或者多个)。</td></tr><tr><td><code>LRANGE key start end</code></td><td>获取list 起止元素==（索引从左往右 递增）==</td></tr><tr><td><code>LPUSHX/RPUSHX key value</code></td><td>向已存在的列名中push值（一个或者多个）</td></tr><tr><td>`LINSERT key BEFORE</td><td>AFTER pivot value`</td></tr><tr><td><code>LLEN key</code></td><td>查看列表长度</td></tr><tr><td><code>LINDEX key index</code></td><td>通过索引获取列表元素</td></tr><tr><td><code>LSET key index value</code></td><td>通过索引为元素设值</td></tr><tr><td><code>LPOP/RPOP key</code></td><td>从最左边/最右边移除值 并返回</td></tr><tr><td><code>RPOPLPUSH source destination</code></td><td>将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部</td></tr><tr><td><code>LTRIM key start end</code></td><td>通过下标截取指定范围内的列表</td></tr><tr><td><code>LREM key count value</code></td><td>List中是允许value重复的 <code>count &gt; 0</code>：从头部开始搜索 然后删除指定的value 至多删除count个 <code>count &lt; 0</code>：从尾部开始搜索… <code>count = 0</code>：删除列表中所有的指定value。</td></tr><tr><td><code>BLPOP/BRPOP key1[key2] timout</code></td><td>移出并获取列表的第一个/最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td><code>BRPOPLPUSH source destination timeout</code></td><td>和<code>RPOPLPUSH</code>功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">---------------------------LPUSH---RPUSH---LRANGE--------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPUSH mylist k1 <span class="comment"># LPUSH mylist=&gt;&#123;1&#125;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH mylist k2 <span class="comment"># LPUSH mylist=&gt;&#123;2,1&#125;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist k3 <span class="comment"># RPUSH mylist=&gt;&#123;2,1,3&#125;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; get mylist <span class="comment"># 普通的get是无法获取list值的</span></span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 4 <span class="comment"># LRANGE 获取起止位置范围内的元素</span></span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">3) <span class="string">&quot;k3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 2</span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">3) <span class="string">&quot;k3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 1</span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1 <span class="comment"># 获取全部元素</span></span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">3) <span class="string">&quot;k3&quot;</span></span><br><span class="line"></span><br><span class="line">---------------------------LPUSHX---RPUSHX-----------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPUSHX list v1 <span class="comment"># list不存在 LPUSHX失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; LPUSHX list v1 v2  </span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; LPUSHX mylist k4 k5 <span class="comment"># 向mylist中 左边 PUSH k4 k5</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k5&quot;</span></span><br><span class="line">2) <span class="string">&quot;k4&quot;</span></span><br><span class="line">3) <span class="string">&quot;k2&quot;</span></span><br><span class="line">4) <span class="string">&quot;k1&quot;</span></span><br><span class="line">5) <span class="string">&quot;k3&quot;</span></span><br><span class="line"></span><br><span class="line">---------------------------LINSERT--LLEN--LINDEX--LSET----------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LINSERT mylist after k2 ins_key1 <span class="comment"># 在k2元素后 插入ins_key1</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k5&quot;</span></span><br><span class="line">2) <span class="string">&quot;k4&quot;</span></span><br><span class="line">3) <span class="string">&quot;k2&quot;</span></span><br><span class="line">4) <span class="string">&quot;ins_key1&quot;</span></span><br><span class="line">5) <span class="string">&quot;k1&quot;</span></span><br><span class="line">6) <span class="string">&quot;k3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LLEN mylist <span class="comment"># 查看mylist的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; LINDEX mylist 3 <span class="comment"># 获取下标为3的元素</span></span><br><span class="line"><span class="string">&quot;ins_key1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LINDEX mylist 0</span><br><span class="line"><span class="string">&quot;k5&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LSET mylist 3 k6 <span class="comment"># 将下标3的元素 set值为k6</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k5&quot;</span></span><br><span class="line">2) <span class="string">&quot;k4&quot;</span></span><br><span class="line">3) <span class="string">&quot;k2&quot;</span></span><br><span class="line">4) <span class="string">&quot;k6&quot;</span></span><br><span class="line">5) <span class="string">&quot;k1&quot;</span></span><br><span class="line">6) <span class="string">&quot;k3&quot;</span></span><br><span class="line"></span><br><span class="line">---------------------------LPOP--RPOP--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPOP mylist <span class="comment"># 左侧(头部)弹出</span></span><br><span class="line"><span class="string">&quot;k5&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; RPOP mylist <span class="comment"># 右侧(尾部)弹出</span></span><br><span class="line"><span class="string">&quot;k3&quot;</span></span><br><span class="line"></span><br><span class="line">---------------------------RPOPLPUSH--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k4&quot;</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">3) <span class="string">&quot;k6&quot;</span></span><br><span class="line">4) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; RPOPLPUSH mylist newlist <span class="comment"># 将mylist的最后一个值(k1)弹出，加入到newlist的头部</span></span><br><span class="line"><span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE newlist 0 -1</span><br><span class="line">1) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k4&quot;</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">3) <span class="string">&quot;k6&quot;</span></span><br><span class="line"></span><br><span class="line">---------------------------LTRIM--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LTRIM mylist 0 1 <span class="comment"># 截取mylist中的 0~1部分</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">&quot;k4&quot;</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始 mylist: k2,k2,k2,k2,k2,k2,k4,k2,k2,k2,k2</span></span><br><span class="line">---------------------------LREM--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LREM mylist 3 k2 <span class="comment"># 从头部开始搜索 至多删除3个 k2</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"><span class="comment"># 删除后：mylist: k2,k2,k2,k4,k2,k2,k2,k2</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LREM mylist -2 k2 <span class="comment">#从尾部开始搜索 至多删除2个 k2</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment"># 删除后：mylist: k2,k2,k2,k4,k2,k2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------BLPOP--BRPOP--------------------------</span><br><span class="line"></span><br><span class="line">mylist: k2,k2,k2,k4,k2,k2</span><br><span class="line">newlist: k1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist mylist 30 <span class="comment"># 从newlist中弹出第一个值，mylist作为候选</span></span><br><span class="line">1) <span class="string">&quot;newlist&quot;</span> <span class="comment"># 弹出</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist mylist 30</span><br><span class="line">1) <span class="string">&quot;mylist&quot;</span> <span class="comment"># 由于newlist空了 从mylist中弹出</span></span><br><span class="line">2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist 30</span><br><span class="line">(30.10s) <span class="comment"># 超时了</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist 30 <span class="comment"># 我们连接另一个客户端向newlist中push了test, 阻塞被解决。</span></span><br><span class="line">1) <span class="string">&quot;newlist&quot;</span></span><br><span class="line">2) <span class="string">&quot;test&quot;</span></span><br><span class="line">(12.54s)</span><br></pre></td></tr></table></figure><blockquote><p>小结</p></blockquote><ul><li><p>list实际上是一个链表，before Node after , left, right 都可以插入值</p></li><li><p><strong>如果key不存在，则创建新的链表</strong></p></li><li><p>如果key存在，新增内容</p></li><li><p>如果移除了所有值，空链表，也代表不存在</p></li><li><p>在两边插入或者改动值，效率最高！修改中间元素，效率相对较低</p></li></ul><p><strong>应用：</strong></p><p><strong>消息排队！消息队列（Lpush Rpop）,栈（Lpush Lpop）</strong></p><h2 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h2><blockquote><p>Redis的Set是<strong>string类型</strong>的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p><p>Redis 中 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>SADD key member1[member2..]</code></td><td>向集合中无序增加一个/多个成员</td></tr><tr><td><code>SCARD key</code></td><td>获取集合的成员数</td></tr><tr><td><code>SMEMBERS key</code></td><td>返回集合中所有的成员</td></tr><tr><td><code>SISMEMBER key member</code></td><td>查询member元素是否是集合的成员,结果是无序的</td></tr><tr><td><code>SRANDMEMBER key [count]</code></td><td>随机返回集合中count个成员，count缺省值为1</td></tr><tr><td><code>SPOP key [count]</code></td><td>随机移除并返回集合中count个成员，count缺省值为1</td></tr><tr><td><code>SMOVE source destination member</code></td><td>将source集合的成员member移动到destination集合</td></tr><tr><td><code>SREM key member1[member2..]</code></td><td>移除集合中一个/多个成员</td></tr><tr><td><code>SDIFF key1[key2..]</code></td><td>返回所有集合的差集 key1- key2 - …</td></tr><tr><td><code>SDIFFSTORE destination key1[key2..]</code></td><td>在SDIFF的基础上，将结果保存到集合中==(覆盖)==。不能保存到其他类型key噢！</td></tr><tr><td><code>SINTER key1 [key2..]</code></td><td>返回所有集合的交集</td></tr><tr><td><code>SINTERSTORE destination key1[key2..]</code></td><td>在SINTER的基础上，存储结果到集合中。覆盖</td></tr><tr><td><code>SUNION key1 [key2..]</code></td><td>返回所有集合的并集</td></tr><tr><td><code>SUNIONSTORE destination key1 [key2..]</code></td><td>在SUNION的基础上，存储结果到及和张。覆盖</td></tr><tr><td><code>SSCAN KEY [MATCH pattern] [COUNT count]</code></td><td>在大量数据环境下，使用此命令遍历集合中元素，每次遍历部分</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">---------------SADD--SCARD--SMEMBERS--SISMEMBER--------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SADD myset m1 m2 m3 m4 <span class="comment"># 向myset中增加成员 m1~m4</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; SCARD myset <span class="comment"># 获取集合的成员数目</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers myset <span class="comment"># 获取集合中所有成员</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line">4) <span class="string">&quot;m1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m5 <span class="comment"># 查询m5是否是myset的成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 不是，返回0</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m2</span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 是，返回1</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">---------------------SRANDMEMBER--SPOP----------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 3 <span class="comment"># 随机返回3个成员</span></span><br><span class="line">1) <span class="string">&quot;m2&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset <span class="comment"># 随机返回1个成员</span></span><br><span class="line"><span class="string">&quot;m3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SPOP myset 2 <span class="comment"># 随机移除并返回2个成员</span></span><br><span class="line">1) <span class="string">&quot;m1&quot;</span></span><br><span class="line">2) <span class="string">&quot;m4&quot;</span></span><br><span class="line"><span class="comment"># 将set还原到&#123;m1,m2,m3,m4&#125;</span></span><br><span class="line"></span><br><span class="line">---------------------SMOVE--SREM----------------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SMOVE myset newset m3 <span class="comment"># 将myset中m3成员移动到newset集合</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m2&quot;</span></span><br><span class="line">3) <span class="string">&quot;m1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS newset</span><br><span class="line">1) <span class="string">&quot;m3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SREM newset m3 <span class="comment"># 从newset中移除m3元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS newset</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面开始是多集合操作,多集合操作中若只有一个参数默认和自身进行运算</span></span><br><span class="line"><span class="comment"># setx=&gt;&#123;m1,m2,m4,m6&#125;, sety=&gt;&#123;m2,m5,m6&#125;, setz=&gt;&#123;m1,m3,m6&#125;</span></span><br><span class="line"></span><br><span class="line">-----------------------------SDIFF------------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SDIFF setx sety setz <span class="comment"># 等价于setx-sety-setz</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SDIFF setx sety <span class="comment"># setx - sety</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SDIFF sety setx <span class="comment"># sety - setx</span></span><br><span class="line">1) <span class="string">&quot;m5&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------------SINTER---------------------------------------</span><br><span class="line"><span class="comment"># 共同关注（交集）</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SINTER setx sety setz <span class="comment"># 求 setx、sety、setx的交集</span></span><br><span class="line">1) <span class="string">&quot;m6&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SINTER setx sety <span class="comment"># 求setx sety的交集</span></span><br><span class="line">1) <span class="string">&quot;m2&quot;</span></span><br><span class="line">2) <span class="string">&quot;m6&quot;</span></span><br><span class="line"></span><br><span class="line">-------------------------SUNION---------------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SUNION setx sety setz <span class="comment"># setx sety setz的并集</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m6&quot;</span></span><br><span class="line">3) <span class="string">&quot;m3&quot;</span></span><br><span class="line">4) <span class="string">&quot;m2&quot;</span></span><br><span class="line">5) <span class="string">&quot;m1&quot;</span></span><br><span class="line">6) <span class="string">&quot;m5&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; SUNION setx sety <span class="comment"># setx sety 并集</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m6&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line">4) <span class="string">&quot;m1&quot;</span></span><br><span class="line">5) <span class="string">&quot;m5&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h2><blockquote><p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p><p>Set就是一种简化的Hash,只变动key,而value使用默认值填充。可以将一个Hash表作为一个对象进行存储，表中存放对象的信息。</p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>HSET key field value</code></td><td>将哈希表 key 中的字段 field 的值设为 value 。重复设置同一个field会覆盖,返回0</td></tr><tr><td><code>HMSET key field1 value1 [field2 value2..]</code></td><td>同时将多个 field-value (域-值)对设置到哈希表 key 中。</td></tr><tr><td><code>HSETNX key field value</code></td><td>只有在字段 field 不存在时，设置哈希表字段的值。</td></tr><tr><td><code>HEXISTS key field</code></td><td>查看哈希表 key 中，指定的字段是否存在。</td></tr><tr><td><code>HGET key field value</code></td><td>获取存储在哈希表中指定字段的值</td></tr><tr><td><code>HMGET key field1 [field2..]</code></td><td>获取所有给定字段的值</td></tr><tr><td><code>HGETALL key</code></td><td>获取在哈希表key 的所有字段和值</td></tr><tr><td><code>HKEYS key</code></td><td>获取哈希表key中所有的字段</td></tr><tr><td><code>HLEN key</code></td><td>获取哈希表中字段的数量</td></tr><tr><td><code>HVALS key</code></td><td>获取哈希表中所有值</td></tr><tr><td><code>HDEL key field1 [field2..]</code></td><td>删除哈希表key中一个/多个field字段</td></tr><tr><td><code>HINCRBY key field n</code></td><td>为哈希表 key 中的指定字段的整数值加上增量n，并返回增量后结果 一样只适用于整数型字段</td></tr><tr><td><code>HINCRBYFLOAT key field n</code></td><td>为哈希表 key 中的指定字段的浮点数值加上增量 n。</td></tr><tr><td><code>HSCAN key cursor [MATCH pattern] [COUNT count]</code></td><td>迭代哈希表中的键值对。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">------------------------HSET--HMSET--HSETNX----------------</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx name sakura <span class="comment"># 将studentx哈希表作为一个对象，设置name为sakura</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx name gyc <span class="comment"># 重复设置field进行覆盖，并返回0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx age 20 <span class="comment"># 设置studentx的age为20</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HMSET studentx sex 1 tel 15623667886 <span class="comment"># 设置sex为1，tel为15623667886</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HSETNX studentx name gyc <span class="comment"># HSETNX 设置已存在的field</span></span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 失败</span></span><br><span class="line">127.0.0.1:6379&gt; HSETNX studentx email 12345@qq.com</span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 成功</span></span><br><span class="line"></span><br><span class="line">----------------------HEXISTS--------------------------------</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS studentx name <span class="comment"># name字段在studentx中是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 存在</span></span><br><span class="line">127.0.0.1:6379&gt; HEXISTS studentx addr</span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 不存在</span></span><br><span class="line"></span><br><span class="line">-------------------HGET--HMGET--HGETALL-----------</span><br><span class="line">127.0.0.1:6379&gt; HGET studentx name <span class="comment"># 获取studentx中name字段的value</span></span><br><span class="line"><span class="string">&quot;gyc&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HMGET studentx name age tel <span class="comment"># 获取studentx中name、age、tel字段的value</span></span><br><span class="line">1) <span class="string">&quot;gyc&quot;</span></span><br><span class="line">2) <span class="string">&quot;20&quot;</span></span><br><span class="line">3) <span class="string">&quot;15623667886&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HGETALL studentx <span class="comment"># 获取studentx中所有的field及其value</span></span><br><span class="line"> 1) <span class="string">&quot;name&quot;</span></span><br><span class="line"> 2) <span class="string">&quot;gyc&quot;</span></span><br><span class="line"> 3) <span class="string">&quot;age&quot;</span></span><br><span class="line"> 4) <span class="string">&quot;20&quot;</span></span><br><span class="line"> 5) <span class="string">&quot;sex&quot;</span></span><br><span class="line"> 6) <span class="string">&quot;1&quot;</span></span><br><span class="line"> 7) <span class="string">&quot;tel&quot;</span></span><br><span class="line"> 8) <span class="string">&quot;15623667886&quot;</span></span><br><span class="line"> 9) <span class="string">&quot;email&quot;</span></span><br><span class="line">10) <span class="string">&quot;12345@qq.com&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------HKEYS--HLEN--HVALS--------------</span><br><span class="line">127.0.0.1:6379&gt; HKEYS studentx <span class="comment"># 查看studentx中所有的field</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;age&quot;</span></span><br><span class="line">3) <span class="string">&quot;sex&quot;</span></span><br><span class="line">4) <span class="string">&quot;tel&quot;</span></span><br><span class="line">5) <span class="string">&quot;email&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; HLEN studentx <span class="comment"># 查看studentx中的字段数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; HVALS studentx <span class="comment"># 查看studentx中所有的value</span></span><br><span class="line">1) <span class="string">&quot;gyc&quot;</span></span><br><span class="line">2) <span class="string">&quot;20&quot;</span></span><br><span class="line">3) <span class="string">&quot;1&quot;</span></span><br><span class="line">4) <span class="string">&quot;15623667886&quot;</span></span><br><span class="line">5) <span class="string">&quot;12345@qq.com&quot;</span></span><br><span class="line"></span><br><span class="line">-------------------------HDEL--------------------------</span><br><span class="line">127.0.0.1:6379&gt; HDEL studentx sex tel <span class="comment"># 删除studentx 中的sex、tel字段</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; HKEYS studentx</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;age&quot;</span></span><br><span class="line">3) <span class="string">&quot;email&quot;</span></span><br><span class="line"></span><br><span class="line">-------------HINCRBY--HINCRBYFLOAT------------------------</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY studentx age 1 <span class="comment"># studentx的age字段数值+1</span></span><br><span class="line">(<span class="built_in">integer</span>) 21</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY studentx name 1 <span class="comment"># 非整数字型字段不可用</span></span><br><span class="line">(error) ERR <span class="built_in">hash</span> value is not an <span class="built_in">integer</span></span><br><span class="line">127.0.0.1:6379&gt; HINCRBYFLOAT studentx weight 0.6 <span class="comment"># weight字段增加0.6</span></span><br><span class="line"><span class="string">&quot;90.8&quot;</span></span><br></pre></td></tr></table></figure><p> Hash变更的数据user name age，尤其是用户信息之类的，经常变动的信息！<strong>Hash更适合于对象的存储，Sring更加适合字符串存储！</strong></p><h2 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h2><blockquote><p>不同的是每个元素都会关联一个double类型的分数（score）。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>score相同：按字典顺序排序</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。</p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>ZADD key score member1 [score2 member2]</code></td><td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td></tr><tr><td><code>ZCARD key</code></td><td>获取有序集合的成员数</td></tr><tr><td><code>ZCOUNT key min max</code></td><td>计算在有序集合中指定区间score的成员数</td></tr><tr><td><code>ZINCRBY key n member</code></td><td>有序集合中对指定成员的分数加上增量 n</td></tr><tr><td><code>ZSCORE key member</code></td><td>返回有序集中，成员的分数值</td></tr><tr><td><code>ZRANK key member</code></td><td>返回有序集合中指定成员的索引</td></tr><tr><td><code>ZRANGE key start end</code></td><td>通过索引区间返回有序集合成指定区间内的成员</td></tr><tr><td><code>ZRANGEBYLEX key min max</code></td><td>通过字典区间返回有序集合的成员</td></tr><tr><td><code>ZRANGEBYSCORE key min max</code></td><td>通过分数返回有序集合指定区间内的成员==-inf 和 +inf分别表示最小最大值，只支持开区间()==</td></tr><tr><td><code>ZLEXCOUNT key min max</code></td><td>在有序集合中计算指定字典区间内成员数量</td></tr><tr><td><code>ZREM key member1 [member2..]</code></td><td>移除有序集合中一个/多个成员</td></tr><tr><td><code>ZREMRANGEBYLEX key min max</code></td><td>移除有序集合中给定的字典区间的所有成员</td></tr><tr><td><code>ZREMRANGEBYRANK key start stop</code></td><td>移除有序集合中给定的排名区间的所有成员</td></tr><tr><td><code>ZREMRANGEBYSCORE key min max</code></td><td>移除有序集合中给定的分数区间的所有成员</td></tr><tr><td><code>ZREVRANGE key start end</code></td><td>返回有序集中指定区间内的成员，通过索引，分数从高到底</td></tr><tr><td><code>ZREVRANGEBYSCORRE key max min</code></td><td>返回有序集中指定分数区间内的成员，分数从高到低排序</td></tr><tr><td><code>ZREVRANGEBYLEX key max min</code></td><td>返回有序集中指定字典区间内的成员，按字典顺序倒序</td></tr><tr><td><code>ZREVRANK key member</code></td><td>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td></tr><tr><td><code>ZINTERSTORE destination numkeys key1 [key2 ..]</code></td><td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中，numkeys：表示参与运算的集合数，将score相加作为结果的score</td></tr><tr><td><code>ZUNIONSTORE destination numkeys key1 [key2..]</code></td><td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td></tr><tr><td><code>ZSCAN key cursor [MATCH pattern\] [COUNT count]</code></td><td>迭代有序集合中的元素（包括元素成员和元素分值）</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">-------------------ZADD--ZCARD--ZCOUNT--------------</span><br><span class="line">127.0.0.1:6379&gt; ZADD myzset 1 m1 2 m2 3 m3 <span class="comment"># 向有序集合myzset中添加成员m1 score=1 以及成员m2 score=2..</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZCARD myzset <span class="comment"># 获取有序集合的成员数</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myzset 0 1 <span class="comment"># 获取score在 [0,1]区间的成员数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myzset 0 2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">----------------ZINCRBY--ZSCORE--------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZINCRBY myzset 5 m2 <span class="comment"># 将成员m2的score +5</span></span><br><span class="line"><span class="string">&quot;7&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myzset m1 <span class="comment"># 获取成员m1的score</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myzset m2</span><br><span class="line"><span class="string">&quot;7&quot;</span></span><br><span class="line"></span><br><span class="line">--------------ZRANK--ZRANGE-----------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANK myzset m1 <span class="comment"># 获取成员m1的索引，索引按照score排序，score相同索引值按字典顺序顺序增加</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; ZRANK myzset m2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myzset 0 1 <span class="comment"># 获取索引在 0~1的成员</span></span><br><span class="line">1) <span class="string">&quot;m1&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myzset 0 -1 <span class="comment"># 获取全部成员</span></span><br><span class="line">1) <span class="string">&quot;m1&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#testset=&gt;&#123;abc,add,amaze,apple,back,java,redis&#125; score均为0</span></span><br><span class="line">------------------ZRANGEBYLEX---------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + <span class="comment"># 返回所有成员</span></span><br><span class="line">1) <span class="string">&quot;abc&quot;</span></span><br><span class="line">2) <span class="string">&quot;add&quot;</span></span><br><span class="line">3) <span class="string">&quot;amaze&quot;</span></span><br><span class="line">4) <span class="string">&quot;apple&quot;</span></span><br><span class="line">5) <span class="string">&quot;back&quot;</span></span><br><span class="line">6) <span class="string">&quot;java&quot;</span></span><br><span class="line">7) <span class="string">&quot;redis&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 0 3 <span class="comment"># 分页 按索引显示查询结果的 0,1,2条记录</span></span><br><span class="line">1) <span class="string">&quot;abc&quot;</span></span><br><span class="line">2) <span class="string">&quot;add&quot;</span></span><br><span class="line">3) <span class="string">&quot;amaze&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 3 3 <span class="comment"># 显示 3,4,5条记录</span></span><br><span class="line">1) <span class="string">&quot;apple&quot;</span></span><br><span class="line">2) <span class="string">&quot;back&quot;</span></span><br><span class="line">3) <span class="string">&quot;java&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset (- [apple <span class="comment"># 显示 (-,apple] 区间内的成员</span></span><br><span class="line">1) <span class="string">&quot;abc&quot;</span></span><br><span class="line">2) <span class="string">&quot;add&quot;</span></span><br><span class="line">3) <span class="string">&quot;amaze&quot;</span></span><br><span class="line">4) <span class="string">&quot;apple&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset [apple [java <span class="comment"># 显示 [apple,java]字典区间的成员</span></span><br><span class="line">1) <span class="string">&quot;apple&quot;</span></span><br><span class="line">2) <span class="string">&quot;back&quot;</span></span><br><span class="line">3) <span class="string">&quot;java&quot;</span></span><br><span class="line"></span><br><span class="line">-----------------------ZRANGEBYSCORE---------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 10 <span class="comment"># 返回score在 [1,10]之间的的成员</span></span><br><span class="line">1) <span class="string">&quot;m1&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 5</span><br><span class="line">1) <span class="string">&quot;m1&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line"></span><br><span class="line">--------------------ZLEXCOUNT-----------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZLEXCOUNT testset - +</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; ZLEXCOUNT testset [apple [java</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">------------------ZREM--ZREMRANGEBYLEX--ZREMRANGBYRANK--ZREMRANGEBYSCORE--------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZREM testset abc <span class="comment"># 移除成员abc</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYLEX testset [apple [java <span class="comment"># 移除字典区间[apple,java]中的所有成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYRANK testset 0 1 <span class="comment"># 移除排名0~1的所有成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYSCORE myzset 0 3 <span class="comment"># 移除score在 [0,3]的成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># testset=&gt; &#123;abc,add,apple,amaze,back,java,redis&#125; score均为0</span></span><br><span class="line"><span class="comment"># myzset=&gt; &#123;(m1,1),(m2,2),(m3,3),(m4,4),(m7,7),(m9,9)&#125;</span></span><br><span class="line">----------------ZREVRANGE--ZREVRANGEBYSCORE--ZREVRANGEBYLEX-----------</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE myzset 0 3 <span class="comment"># 按score递减排序，然后按索引，返回结果的 0~3</span></span><br><span class="line">1) <span class="string">&quot;m9&quot;</span></span><br><span class="line">2) <span class="string">&quot;m7&quot;</span></span><br><span class="line">3) <span class="string">&quot;m4&quot;</span></span><br><span class="line">4) <span class="string">&quot;m3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE myzset 2 4 <span class="comment"># 返回排序结果的 索引的2~4</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGEBYSCORE myzset 6 2 <span class="comment"># 按score递减顺序 返回集合中分数在[2,6]之间的成员</span></span><br><span class="line">1) <span class="string">&quot;m4&quot;</span></span><br><span class="line">2) <span class="string">&quot;m3&quot;</span></span><br><span class="line">3) <span class="string">&quot;m2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGEBYLEX testset [java (add <span class="comment"># 按字典倒序 返回集合中(add,java]字典区间的成员</span></span><br><span class="line">1) <span class="string">&quot;java&quot;</span></span><br><span class="line">2) <span class="string">&quot;back&quot;</span></span><br><span class="line">3) <span class="string">&quot;apple&quot;</span></span><br><span class="line">4) <span class="string">&quot;amaze&quot;</span></span><br><span class="line"></span><br><span class="line">-------------------------ZREVRANK------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK myzset m7 <span class="comment"># 按score递减顺序，返回成员m7索引</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK myzset m2</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># mathscore=&gt;&#123;(xm,90),(xh,95),(xg,87)&#125; 小明、小红、小刚的数学成绩</span></span><br><span class="line"><span class="comment"># enscore=&gt;&#123;(xm,70),(xh,93),(xg,90)&#125; 小明、小红、小刚的英语成绩</span></span><br><span class="line">-------------------ZINTERSTORE--ZUNIONSTORE-----------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZINTERSTORE sumscore 2 mathscore enscore <span class="comment"># 将mathscore enscore进行合并 结果存放到sumscore</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE sumscore 0 -1 withscores <span class="comment"># 合并后的score是之前集合中所有score的和</span></span><br><span class="line">1) <span class="string">&quot;xm&quot;</span></span><br><span class="line">2) <span class="string">&quot;160&quot;</span></span><br><span class="line">3) <span class="string">&quot;xg&quot;</span></span><br><span class="line">4) <span class="string">&quot;177&quot;</span></span><br><span class="line">5) <span class="string">&quot;xh&quot;</span></span><br><span class="line">6) <span class="string">&quot;188&quot;</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ZUNIONSTORE lowestscore 2 mathscore enscore AGGREGATE MIN <span class="comment"># 取两个集合的成员score最小值作为结果的</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE lowestscore 0 -1 withscores</span><br><span class="line">1) <span class="string">&quot;xm&quot;</span></span><br><span class="line">2) <span class="string">&quot;70&quot;</span></span><br><span class="line">3) <span class="string">&quot;xg&quot;</span></span><br><span class="line">4) <span class="string">&quot;87&quot;</span></span><br><span class="line">5) <span class="string">&quot;xh&quot;</span></span><br><span class="line">6) <span class="string">&quot;93&quot;</span></span><br></pre></td></tr></table></figure><p>应用案例：</p><ul><li>set排序 存储班级成绩表 工资表排序！</li><li>普通消息，1.重要消息 2.带权重进行判断</li><li>排行榜应用实现，取Top N测试</li></ul><h1 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h1><h2 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial(地理位置)"></a>Geospatial(地理位置)</h2><blockquote><p>使用经纬度定位地理坐标并用一个<strong>有序集合zset保存</strong>，所以zset命令也可以使用</p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>geoadd key longitud(经度) latitude(纬度) member [..]</code></td><td>将具体经纬度的坐标存入一个有序集合</td></tr><tr><td><code>geopos key member [member..]</code></td><td>获取集合中的一个/多个成员坐标</td></tr><tr><td><code>geodist key member1 member2 [unit]</code></td><td>返回两个给定位置之间的距离。默认以米作为单位。</td></tr><tr><td>`georadius key longitude latitude radius m</td><td>km</td></tr><tr><td><code>GEORADIUSBYMEMBER key member radius...</code></td><td>功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用结合中已有的成员作为中心点。</td></tr><tr><td><code>geohash key member1 [member2..]</code></td><td>返回一个或多个位置元素的Geohash表示。使用Geohash位置52点整数编码。</td></tr></tbody></table><p><strong>有效经纬度</strong></p><blockquote><ul><li>有效的经度从-180度到180度。</li><li>有效的纬度从-85.05112878度到85.05112878度。</li></ul></blockquote><p>指定单位的参数 <strong>unit</strong> 必须是以下单位的其中一个：</p><ul><li><p><strong>m</strong> 表示单位为米。</p></li><li><p><strong>km</strong> 表示单位为千米。</p></li><li><p><strong>mi</strong> 表示单位为英里。</p></li><li><p><strong>ft</strong> 表示单位为英尺。</p></li></ul><p><strong>关于GEORADIUS的参数</strong></p><blockquote><p>通过<code>georadius</code>就可以完成 <strong>附近的人</strong>功能</p><p>withcoord:带上坐标</p><p>withdist:带上距离，单位与半径单位相同</p><p>COUNT n : 只显示前n个(按距离递增排序)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">----------------georadius---------------------</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 120 30 500 km withcoord withdist <span class="comment"># 查询经纬度(120,30)坐标500km半径内的成员</span></span><br><span class="line">1) 1) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">   2) <span class="string">&quot;29.4151&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;120.20000249147415&quot;</span></span><br><span class="line">      2) <span class="string">&quot;30.199999888333501&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">   2) <span class="string">&quot;205.3611&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;121.40000134706497&quot;</span></span><br><span class="line">      2) <span class="string">&quot;31.400000253193539&quot;</span></span><br><span class="line">     </span><br><span class="line">------------geohash---------------------------</span><br><span class="line">127.0.0.1:6379&gt; geohash china:city yichang shanghai <span class="comment"># 获取成员经纬坐标的geohash表示</span></span><br><span class="line">1) <span class="string">&quot;wmrjwbr5250&quot;</span></span><br><span class="line">2) <span class="string">&quot;wtw6ds0y300&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Hyperloglog-基数统计"><a href="#Hyperloglog-基数统计" class="headerlink" title="Hyperloglog(基数统计)"></a>Hyperloglog(基数统计)</h2><blockquote><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。</p><p>因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p>其底层使用string数据类型</p></blockquote><p><strong>什么是基数？</strong></p><blockquote><p>数据集中不重复的元素的个数。</p></blockquote><p><strong>应用场景：</strong></p><p>网页的访问量（UV）：一个用户多次访问，也只能算作一个人。</p><blockquote><p>传统实现，存储用户的id,然后每次进行比较。当用户变多之后这种方式及其浪费空间，而我们的目的只是<strong>计数</strong>，Hyperloglog就能帮助我们利用最小的空间完成。</p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>PFADD key element1 [elememt2..]</code></td><td>添加指定元素到 HyperLogLog 中</td></tr><tr><td><code>PFCOUNT key [key]</code></td><td>返回给定 HyperLogLog 的基数估算值。</td></tr><tr><td><code>PFMERGE destkey sourcekey [sourcekey..]</code></td><td>将多个 HyperLogLog 合并为一个 HyperLogLog</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">----------PFADD--PFCOUNT---------------------</span><br><span class="line">127.0.0.1:6379&gt; PFADD myelemx a b c d e f g h i j k <span class="comment"># 添加元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> myelemx <span class="comment"># hyperloglog底层使用String</span></span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT myelemx <span class="comment"># 估算myelemx的基数</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; PFADD myelemy i j k z m c b v p q s</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT myelemy</span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line"></span><br><span class="line">----------------PFMERGE-----------------------</span><br><span class="line">127.0.0.1:6379&gt; PFMERGE myelemz myelemx myelemy <span class="comment"># 合并myelemx和myelemy 成为myelemz</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT myelemz <span class="comment"># 估算基数</span></span><br><span class="line">(<span class="built_in">integer</span>) 17</span><br></pre></td></tr></table></figure><p>如果允许容错，那么一定可以使用Hyperloglog !</p><p>如果不允许容错，就使用set或者自己的数据类型即可 ！</p><h2 id="BitMaps-位图"><a href="#BitMaps-位图" class="headerlink" title="BitMaps(位图)"></a>BitMaps(位图)</h2><blockquote><p>使用位存储，信息状态只有 0 和 1</p><p>Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。</p></blockquote><p><strong>应用场景</strong></p><p>签到统计、状态统计</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>setbit key offset value</code></td><td>为指定key的offset位设置值</td></tr><tr><td><code>getbit key offset</code></td><td>获取offset位的值</td></tr><tr><td><code>bitcount key [start end]</code></td><td>统计字符串被设置为1的bit数，也可以指定统计范围按字节</td></tr><tr><td><code>bitop operration destkey key[key..]</code></td><td>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</td></tr><tr><td><code>BITPOS key bit [start] [end]</code></td><td>返回字符串里面第一个被设置为1或者0的bit位。start和end只能按字节,不能按位</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">------------setbit--getbit--------------</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 0 1 <span class="comment"># 设置sign的第0位为 1 </span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 1 <span class="comment"># 设置sign的第2位为 1  不设置默认 是0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> sign</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; getbit sign 2 <span class="comment"># 获取第2位的数值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 4 <span class="comment"># 未设置默认是0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">-----------bitcount----------------------------</span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT sign <span class="comment"># 统计sign中为1的位数</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure><p>bitmaps是一串从左到右的二进制串</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在B站跟着狂神学习，真是个宝藏男孩，下面是狂神的笔记~&lt;/p&gt;
&lt;h1 id=&quot;Nosql概述&quot;&gt;&lt;a href=&quot;#Nosql概述&quot; class=&quot;headerlink&quot; title=&quot;Nosql概述&quot;&gt;&lt;/a&gt;Nosql概述&lt;/h1&gt;&lt;h2 id=&quot;为什么使用Nos</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://qwq3.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>PHP基础学习</title>
    <link href="https://qwq3.top/posts/c5b3.html"/>
    <id>https://qwq3.top/posts/c5b3.html</id>
    <published>2021-06-22T15:50:41.000Z</published>
    <updated>2021-11-18T04:02:22.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="php是什么？"><a href="#php是什么？" class="headerlink" title="php是什么？"></a>php是什么？</h2><p>PHP(PHP: Hypertext Preprocessor，超文本预处理器的缩写)，是一种被广泛应用的开放源代码的、基于服务器端的用于产生动态网页的、可嵌入HTML中的脚本程序语言，尤其适合 WEB 开发。</p><p>当客户端向服务器的程序提出请求时，web服务器根据请求响应对应的页面，当页面中含有php脚本时，服务器会交给PHP解释器进行解释执行，将生成的html代码再回传给客户端，客户端的浏览器解释html代码，最终形成网页格式的页面。</p><h2 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h2><p>PHP 代码被包含在特殊的起始符和结束符中，使得网页的脚本可以进出“PHP 模式”。其它用 C 或 Perl 语言写的脚本，需要用大量的命令来编写程序以输出 HTML ，而用PHP 编写一个 HTML 脚本，只需嵌入了一些代码来完成操作（例如，在本例中输出了一些文本）。 和客户端的 JavaScript 不同的是，PHP 代码是运行在服务端的。如果在服务器上建立了如上例类似的代码，则在运行该脚本后，客户端就能接收到其结果，但他们无法得知其背后的代码是如何运作的。甚至可以将 web 服务器设置成让 PHP 来处理所有的 HTML 文件，这么一来，用户就无法得知服务端到底做了什么。</p><h2 id="我的PHP运行环境"><a href="#我的PHP运行环境" class="headerlink" title="我的PHP运行环境"></a>我的PHP运行环境</h2><p>安装phpstudy_pro,使用VsCode进行编码，在本地进行测试</p><p>下载地址：</p><p>phpstudy_pro：<a href="https://www.xp.cn/">https://www.xp.cn/</a></p><p>VsCode: <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p><p>然后在VsCode中下载插件Open PHP/HTML/JS In Browser</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterChen520/Drawingbed/img/20210518104135.png"></p><p>通过 <code>Shift + F6</code>来启动</p><h2 id="C-S与B-S结构"><a href="#C-S与B-S结构" class="headerlink" title="C/S与B/S结构"></a>C/S与B/S结构</h2><p>C/S结构</p><p>C/S （Client/Server）结构，即大家熟知的客户机和服务器结构。它是软件系统体系结构，通过它可以充分利用两端硬件环境的优势，将任务合理分配到Client端和Server端来实现，降低了系统的通讯开销。目前大多数应用软件系统都是Client/Server形式的两层结构</p><p>B/S结构</p><p>B/S（Browser/Server）结构即浏览器和服务器结构。它是随着Internet技术的兴起，对C/S结构的一种变化或者改进的结构。在这种结构下，用户工作界面是通过WWW浏览器来实现，极少部分事务逻辑在前端（Browser）实现，但是主要事务逻辑在服务器端（Server）实现。这样就大大简化了客户端电脑载荷，减轻了系统维护与升级的成本和工作量，降低了用户的总体成本。</p><h2 id="PHP的标记风格"><a href="#PHP的标记风格" class="headerlink" title="PHP的标记风格"></a>PHP的标记风格</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">… … </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这是PHP推荐使用的标记风格。服务器管理员不能禁用这种风格的标记。</p><h2 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h2><p>PHP用分号来分隔简单的语句。复合语句用大括号来标记代码块，如条件测试或循环，在大括号后面不要用分号。和其他语言不一样的是，<code>在PHP中右括号(?&gt;)前的分号不是必选的。</code></p><h2 id="空白和换行符"><a href="#空白和换行符" class="headerlink" title="空白和换行符()"></a>空白和换行符()</h2><p>一般来说，空白符在PHP中无关紧要。可以将一个语句展开成任意行，或者将语句紧缩在一行。 可以利用这个灵活的格式来使代码更具有可读性（通过排列分配、缩进等）。一些懒惰的程序员利用这种自由的格式创建根本无法阅读的代码，这是不提倡的, 阅读性会很差。</p><h2 id="程序的注释"><a href="#程序的注释" class="headerlink" title="程序的注释"></a>程序的注释</h2><p>PHP支持C、C＋＋和Shell脚本风格的注释，如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="comment">/* ...*/</span>  多行注释         （注意：不能嵌套）</span><br><span class="line"><span class="comment"># 脚本注释</span></span><br></pre></td></tr></table></figure><h2 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h2><p><code>echo</code><br>输出一个或多个变量，他不是函数，不需要使用括号，如果输出多个请用逗号分隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1,2,3,4;</span><br></pre></td></tr></table></figure><p><code>var_dump</code><br>打印变量的相关信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var_dump(1234);</span><br></pre></td></tr></table></figure><blockquote><p>区别：echo 是直接输出，var_dump输出和带有变量类型</p></blockquote><h1 id="变量知识"><a href="#变量知识" class="headerlink" title="变量知识"></a>变量知识</h1><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>PHP是弱类型语言，不像其他语言需要对变量进行类型声明。PHP中以<code>$(美元)</code>作为前缀来定义变量，以<code>a~z（大小写）</code>或 <code>_ </code>下划线定义变量名。</p><p>下面是合法的变量名</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HF</span> =  <span class="string">&#x27;qwq3.top&#x27;</span>;</span><br><span class="line"><span class="variable">$_name</span> = <span class="string">&#x27;Violet&#x27;</span>;</span><br></pre></td></tr></table></figure><p>下面是非法的变量声明</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$<span class="number">0530</span> = <span class="string">&#x27;baidu.com&#x27;</span> </span><br><span class="line">$&amp;* = <span class="string">&#x27;blog.csdn.net&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="弱类型"><a href="#弱类型" class="headerlink" title="弱类型"></a>弱类型</h2><p>PHP是一种非常弱的类型语言。在大多数编程语言中，变量只能保持一种类型的数据，而且这个类型必须在使用变量前声明，例如C语言中。</p><p>而在PHP中，变量的类型通常不是由程序员设定的，确切地说，是根据该变量使用的上下文在运行时（即变量的值）决定的。</p><p>简单来说，<code>var = 1</code>;就是数字，<code>var2 = &#39;1&#39;</code>就是字符串，变量类型是由值决定的。</p><h2 id="传值与引用"><a href="#传值与引用" class="headerlink" title="传值与引用"></a>传值与引用</h2><p><code>传值赋值</code></p><p>直接使用 <code>=</code> 将变量的值赋值给另一个变量。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传值赋值</span></span><br><span class="line"><span class="variable">$a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable">$b</span> = <span class="variable">$a</span>;</span><br><span class="line"><span class="variable">$b</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br><span class="line"><span class="comment">// 输出13</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>将一个变量的内存地址赋值给另一个变量的行为即传址赋值。需要在 = 等号前加上 <code>&amp;</code> 引用符号，这样两个变量指向内存中的一个地址，任何一个变量的改变都影响到另一个变量，有点类似于快捷方式的概念。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//引用赋值(传址赋值)</span></span><br><span class="line"><span class="variable">$a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable">$b</span> = &amp;<span class="variable">$a</span>;</span><br><span class="line"><span class="variable">$b</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br><span class="line"><span class="comment">// 输出33</span></span><br><span class="line"><span class="keyword">echo</span>  <span class="string">&#x27;&lt;hr/&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$a</span> = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br><span class="line"><span class="comment">// 输出99</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h2><p>可以变量即使用一个变量的值，作为另一个变量名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a &#x3D; &#39;hello&#39;; &#x2F;&#x2F;普通变量</span><br><span class="line">$$a &#x3D; &#39;world&#39;; &#x2F;&#x2F;可变变量 等价于 $hello &#x3D; &#39;world&#39; </span><br><span class="line">echo $a;</span><br><span class="line">echo $$a;</span><br><span class="line">echo $hello;</span><br><span class="line">echo &quot;$a $&#123;$a&#125;&quot;; &#x2F;&#x2F;输出hello world</span><br><span class="line">echo &quot;$a $hello&quot;; &#x2F;&#x2F;输出hello world</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>变量作用域指变量在代码中可以访问的位置。</p><p><code>超全局变量</code></p><p>可以代码的任何位置都可以访问的变量</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">var_dump(<span class="variable">$_GET</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print_r(<span class="variable">$_GET</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">show();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">变量</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">$_GET</td><td align="left">地址栏GET提交</td></tr><tr><td align="left">$_POST</td><td align="left">表单POST提交</td></tr><tr><td align="left">$_FILES</td><td align="left">文件上传变量</td></tr><tr><td align="left">$_SESSION</td><td align="left">会话变量</td></tr><tr><td align="left">$_COOKIE</td><td align="left">cookie值变量</td></tr><tr><td align="left">$_GLOBALS</td><td align="left">全局变量</td></tr><tr><td align="left">$_REQUEST</td><td align="left">包含<code>$_GET</code>、<code>$_POST</code>、<code>$_COOKIE</code></td></tr><tr><td align="left">$_SERVER</td><td align="left">服务器环境变量</td></tr></tbody></table><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>全局声明（函数外声明）的变量会保存在<code>$_GLOBALS</code>中，函数内默认不能访问到全局变量，在函数中访问需要使用 global 关键字。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$name</span> = <span class="string">&#x27;Violet&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//echo $name ; 这时该普通变量就不在变量作用域无法访问</span></span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="comment">//利用global引入全局变量，但不推荐使用这种方法，会造成变量污染</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$GLOBALS</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">    <span class="comment">//使用全局数组$GLOBALS调⽤用全局变量。推荐使用这个方法 </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">show();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>也可以使用全局数组<code>$GLOBALS</code>调⽤用全局变量量。 如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$GLOBALS</span>[<span class="string">&#x27;name&#x27;</span>];</span><br></pre></td></tr></table></figure><h2 id="检测变量"><a href="#检测变量" class="headerlink" title="检测变量"></a>检测变量</h2><p>通过isset 函数可以检测变量是否定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$name &#x3D; &#39;Violet&#39;;</span><br><span class="line">var_dump(isset($name));</span><br><span class="line">&#x2F;&#x2F;检测变量若无则输出false若有则为true</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="变量销毁"><a href="#变量销毁" class="headerlink" title="变量销毁"></a>变量销毁</h2><p>php在全部代码执行结束后会删除所有变量，也使用 unset 函数可以在程序运行中删除变量。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$name</span> = <span class="string">&#x27;Violet&#x27;</span>;</span><br><span class="line"><span class="keyword">unset</span>(<span class="variable">$name</span>);</span><br><span class="line">var_dump(<span class="keyword">isset</span>(<span class="variable">$name</span>));</span><br><span class="line"><span class="comment">//输出false说明变量已经被删除了</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>全局变量不能在函数中删除</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$name</span> = <span class="string">&#x27;Violet&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">unset</span>(<span class="variable">$name</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$name</span>;</span><br><span class="line">&#125;</span><br><span class="line">show();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$name</span>;</span><br><span class="line"><span class="comment">//依然可以输出一个Violet,但是对于该函数内此变量被删除了。</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><p>PHP支持声明函数变量为<code>静态的</code>(static)。一个静态变量在所有对该函数的调用之间<code>共享</code>，并且仅在脚本的执行期间函数<code>第一次被调⽤时被初始化</code>。 要声明函数变量为静态的⽤关键字static。<code>通常静态变量的第一次使⽤用时赋予⼀个初始值</code>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculation</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$num</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="variable">$num</span> = <span class="variable">$num</span> + <span class="variable">$num</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$num</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> calculation();</span><br><span class="line"><span class="keyword">echo</span> calculation();</span><br><span class="line"><span class="keyword">echo</span> calculation();</span><br><span class="line"><span class="comment">//三次输出都是2</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculation</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static</span> <span class="variable">$num</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="variable">$num</span> = <span class="variable">$num</span> + <span class="variable">$num</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$num</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> calculation();</span><br><span class="line"><span class="keyword">echo</span> calculation();</span><br><span class="line"><span class="keyword">echo</span> calculation();</span><br><span class="line"><span class="comment">//三次输出分别为248，这样就实现了变量的循环调用</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>使用不同数据类型储存不同数据，就像我们家里面放衣服和放洗手液会使用用不同的容器一样。下面是常用PHP数据类型表：</p><table><thead><tr><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">integer</td><td align="left">整型</td></tr><tr><td align="left">float</td><td align="left">浮点型</td></tr><tr><td align="left">string</td><td align="left">字符串</td></tr><tr><td align="left">boolean</td><td align="left">布尔型</td></tr><tr><td align="left">array</td><td align="left">数组</td></tr><tr><td align="left">object</td><td align="left">对象</td></tr></tbody></table><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>整型可以是<code>十进制、八进制、十六进制</code>。</p><p>php函数可以轻松实现进位制的转化</p><p>如十六进制转化十进制函数<code>hexdc（）</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">    var_dump(hexdec(FFF);</span><br><span class="line">    <span class="comment">//输出int(4095)</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>其他进位制之间的转化函数如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bindec() <span class="comment">//二进制转换为十进制</span></span><br><span class="line"></span><br><span class="line">decbin() <span class="comment">//十进制转换为二进制</span></span><br><span class="line"></span><br><span class="line">dechex() <span class="comment">//十进制转换为十六进制</span></span><br><span class="line"></span><br><span class="line">decoct() <span class="comment">//十进制转换为八进制</span></span><br><span class="line"></span><br><span class="line">hexdec() <span class="comment">//十六进制转换为十进制</span></span><br><span class="line"></span><br><span class="line">octdec() <span class="comment">//八进制转换为十进制</span></span><br><span class="line">base_convert(number,frombase,tobase)<span class="comment">//任意进位制之间的转化</span></span><br></pre></td></tr></table></figure><p>任意进位制转化实例及其参数说明如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$oct</span> = <span class="string">&quot;0530&quot;</span>;</span><br><span class="line"><span class="variable">$dec</span> = base_convert(<span class="variable">$oct</span>,<span class="number">8</span>,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;八进制的 <span class="subst">$oct</span> 等于十进制的 <span class="subst">$dec</span>。&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">number</td><td align="left">必需，原始值</td></tr><tr><td align="left">frombase</td><td align="left">必需，原进制</td></tr><tr><td align="left">tobase</td><td align="left">必需，目标进制</td></tr></tbody></table><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>浮点数表示实数，可理解为有限或无限小数。</p><h2 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h2><p>当转换为 boolean 时，以下值被认为是FALSE</p><table><thead><tr><th align="left">布尔值</th><th align="left">FALSE</th></tr></thead><tbody><tr><td align="left">整型值</td><td align="left">0（零）</td></tr><tr><td align="left">浮点型值</td><td align="left">0.0（零）</td></tr><tr><td align="left">字符串</td><td align="left">空白字符串</td></tr><tr><td align="left">字符串</td><td align="left">“0”</td></tr><tr><td align="left">数组</td><td align="left">没有成员变量的数组</td></tr><tr><td align="left">特殊类型</td><td align="left">NULL（包括尚未设定的变量）</td></tr></tbody></table><blockquote><p>所有其它值都被认为是 TRUE</p></blockquote><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h3><p>字符串可以用双引号<code>&quot;&quot; </code>或 <code>&#39;&#39;</code> 号包含，区别是双引号中可以解析变量。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$string</span> = <span class="string">&quot;qwq3.top&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Violet的网站<span class="subst">&#123;$string&#125;</span>!&quot;</span></span><br><span class="line"><span class="comment">//双引号可以解析变量输出为Violet的网站qwq3.top！单引号则为qwq3.top的网站$string!用花括号可以避免变量错误，因为若变量后面有符合变量规范的字符会和被当作变量名</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>用花括号可以避免变量错误，因为若变量后面有符合变量规范的字符会和被当作变量名<br>      header响应头设置解决中文乱码问题</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">&#x27;Content-type:text/html;charset=utf-8&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="转义符"><a href="#转义符" class="headerlink" title="转义符\"></a>转义符<code>\</code></h3><p>转义是将有多种含义的字符进行转换，比如 $即是变量前缀也是美元符号，就需要转义在不同场景进行改变。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$string</span> = <span class="string">&quot;Violet \&quot;qwq3.top\&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$string</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;输出\\&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr/&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;定义变量方法\t\$string = &#x27;qwq3.top&#x27;&quot;</span>;<span class="comment">//输出定义变量方法$string = &#x27;qwq3.top&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="定界符-lt-lt-lt"><a href="#定界符-lt-lt-lt" class="headerlink" title="定界符&lt;&lt;&lt;"></a>定界符<code>&lt;&lt;&lt;</code></h3><p>文本表现的就和双引号字符串一样，在定界符文本中不需要转义引号，适合输入大量文本。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="variable">$str</span>=&lt;&lt;&lt;html</span><br><span class="line">&lt;h1 style=<span class="string">&quot;color:pink&quot;</span>&gt;qwq3.top&lt;/h1&gt; </span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.write(<span class="string">&#x27;Violet&#x27;</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">html;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>结束符必须从第一列开始，并且后面除了分号以外不能包含任何其他字符，空格也不可以。</p></blockquote><h3 id="连接符"><a href="#连接符" class="headerlink" title="连接符."></a>连接符<code>.</code></h3><p>多个字符串使用 . 符号连接</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$string1</span> = <span class="string">&#x27;Violet&#x27;</span>;</span><br><span class="line"><span class="variable">$string2</span> = <span class="string">&#x27;qwq3.top&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$string1</span>.<span class="string">&#x27;=&gt;&#x27;</span>.<span class="variable">$string2</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><p><code>strlen()</code> — 取得字符串长度传度的函数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="variable">$string</span> = <span class="string">&#x27;qwq3.top&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> strlen(<span class="variable">$string</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr/&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$string</span> = <span class="string">&#x27;彭于晏&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> mb_strlen(<span class="variable">$string</span>,utf8);</span><br><span class="line"><span class="comment">// 中文是宽字节一个汉字等于3个字节</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>需要使用函数时优先查找使用php文档里的提供的函数效率最高<br>      <code>trim</code> 截去字符串首尾的内容</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$string</span> = <span class="string">&#x27; qwq3.top  &#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> strlen(trim(<span class="variable">$string</span>,<span class="string">&#x27; pot&#x27;</span>));</span><br><span class="line"><span class="comment"># 从前后删除 pot和空格字符</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><code>rtrim</code>从右侧删除、<code>ltrim</code>从左侧删除</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$string</span> = <span class="string">&#x27; qwq3.top &#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> strlen(rtrim(<span class="variable">$string</span>,<span class="string">&#x27; pot&#x27;</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">函数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">strtolower</td><td align="left">字母转为小写</td></tr><tr><td align="left">strtoupper</td><td align="left">字母转大写</td></tr><tr><td align="left">ucfirst</td><td align="left">将字符串的首字母转换为大写</td></tr><tr><td align="left">ucwords</td><td align="left">将字符串中每个单词的首字母转换为大写</td></tr></tbody></table><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$string</span> = <span class="string">&#x27; qwq3.top &#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> strlen(<span class="variable">$string</span>);<span class="comment">//输出13</span></span><br><span class="line"><span class="keyword">echo</span> trim(<span class="variable">$string</span>,<span class="string">&#x27; pot.&#x27;</span>);<span class="comment">//输出qwq3</span></span><br><span class="line"><span class="keyword">echo</span> strtolower(<span class="string">&#x27;Hello World&#x27;</span>);<span class="comment">//输出hello world</span></span><br><span class="line"><span class="keyword">echo</span> strtoupper(<span class="string">&#x27;hello world&#x27;</span>);<span class="comment">//输出HELLO　ＷＯＲＬＤ</span></span><br><span class="line"><span class="keyword">echo</span> ucfirst(<span class="string">&#x27;hello world&#x27;</span>);<span class="comment">//输出Hello world</span></span><br><span class="line"><span class="keyword">echo</span> ucwords(<span class="string">&#x27;hello world&#x27;</span>);<span class="comment">//输出Hello World</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><code>md5</code>计算字符串的 MD5 散列值，以 32 字符十六进制数字形式返回<code>散列值</code>.</p><p>原来用于账户密码加密</p><p>现在可以用于存储用户信息</p><p>不要单纯理解为加密，他的特点是不可逆的生成一个<code>32位字符串</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$file</span> = <span class="string">&#x27;user-1-info&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> md5(<span class="variable">$file</span>).<span class="string">&#x27;.php&#x27;</span>;</span><br><span class="line"><span class="variable">$view</span> = <span class="string">&#x27;admin/master.php&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> md5(<span class="variable">$view</span>).<span class="string">&#x27;.php&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><code>explode</code> 使用一个字符串分割另一个字符串</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$arr</span> = (explode(<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;qwq3.top&#x27;</span>));</span><br><span class="line"><span class="keyword">echo</span>  <span class="variable">$arr</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr/&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span>  <span class="variable">$arr</span>[<span class="number">1</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>php 中有顺序时从0开始</p></blockquote><p>处理图像文件类型（后面会有更好的方式，仅用于举例）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$file &#x3D; &#39;card.jpg&#39;;</span><br><span class="line">$arr &#x3D;explode(&#39;.&#39;,$file);</span><br><span class="line">print_r($arr).&#39;&lt;hr&#x2F;&gt;&#39;;&#x2F;&#x2F;输出Array ( [0] &#x3D;&gt; card [1] &#x3D;&gt; jpg )</span><br><span class="line">echo $arr[1];&#x2F;&#x2F;这样就输出了文件格式jpg啦</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><code>implode</code>将一个一维数组的值转化为字符串</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"> <span class="variable">$arr</span> =[<span class="string">&#x27;email&#x27;</span>,<span class="string">&#x27;2268025923@qq.com&#x27;</span>];</span><br><span class="line"> <span class="keyword">echo</span> implode(<span class="string">&#x27;:&#x27;</span>,<span class="variable">$arr</span>);<span class="comment">//输出email：2268025923@qq.com完成合并</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><code>substr</code>返回字符串的子串,截取函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$file &#x3D; &#39;user.webp&#39;;</span><br><span class="line">echo substr($file,0,-5);&#x2F;&#x2F;输出user从第一个截到倒数五个</span><br><span class="line">$ad &#x3D; &#39;欢迎大家访问我的网站&#39;;</span><br><span class="line">echo mb_substr($ad,4,-4,&#39;utf-8&#39;);&#x2F;&#x2F;输出访问</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><code>strstr</code> 查找字符串的首次出现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$email  &#x3D; &#39;name@example.com&#39;;</span><br><span class="line">$domain &#x3D; strstr($email, &#39;@&#39;);</span><br><span class="line">echo $domain; &#x2F;&#x2F; 输出 @example.com</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><code>strrchr</code> 查找指定字符在字符串中的最后一次出现</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$file</span> = <span class="string">&#x27;user.jpg&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> strrchr(<span class="variable">$file</span>, <span class="string">&#x27;.&#x27;</span>); <span class="comment">// 输出.jpg</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><code>strpos</code> 查找字符串首次出现的位置，如果没找到，将返回 FALSE</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$name</span> =<span class="string">&#x27;Violet&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> strpos(<span class="variable">$name</span>, <span class="string">&#x27;a&#x27;</span>); <span class="comment">// 输出1</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><code>strrpos</code> 计算指定字符串在目标字符串中最后一次出现的位置</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$name</span> =<span class="string">&#x27;Violet&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> strrpos(<span class="variable">$name</span>, <span class="string">&#x27;a&#x27;</span>); <span class="comment">// 输出5</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><code>str_replace</code> 子字符串替换</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> str_replace(<span class="string">&#x27;qwq3&#x27;</span>, <span class="string">&#x27;blog.qwq3&#x27;</span>, <span class="string">&#x27;qwq3.top&#x27;</span>); <span class="comment">//输出qwq3.top</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> str_replace([<span class="string">&#x27;小猫&#x27;</span>,<span class="string">&#x27;小狗&#x27;</span>], <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;我家有一只可爱的小猫和小狗&#x27;</span>);<span class="comment">//输出我家有一只可爱的*和*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> str_replace([<span class="string">&#x27;小猫&#x27;</span>,<span class="string">&#x27;小狗&#x27;</span>], [<span class="string">&#x27;喵喵&#x27;</span>,<span class="string">&#x27;汪汪&#x27;</span>], <span class="string">&#x27;我家有一只可爱的小猫和小狗&#x27;</span>); <span class="comment">//输出我家有一只可爱的喵喵和汪汪</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h2><p>NULL数据类型只有一个值NULL。</p><ol><li>变量未被赋予任何值</li><li>变量被赋值为NULL</li><li>被unset()函数处理后的变量</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>;        <span class="comment">//变量 $a未被赋予任何变量，值为NULL</span></span><br><span class="line"><span class="variable">$b</span> = <span class="literal">NULL</span>;    <span class="comment">//变量 $b被赋值为NULL</span></span><br><span class="line"><span class="variable">$c</span> = <span class="number">10</span>;        </span><br><span class="line"></span><br><span class="line"><span class="keyword">unset</span>(<span class="variable">$c</span>);    </span><br><span class="line"><span class="comment">//使用unset()函数处理后，$c为NULL </span></span><br></pre></td></tr></table></figure><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><p><strong>getType()</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$num</span> = <span class="number">1234</span>; </span><br><span class="line"> <span class="variable">$type</span> = gettype( <span class="variable">$num</span>); </span><br><span class="line">var_dump( <span class="variable">$type</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$var</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="variable">$bool</span> = is_bool( <span class="variable">$var</span>);</span><br><span class="line">var_dump( <span class="variable">$bool</span>);</span><br><span class="line"><span class="comment">//检测是否为布尔型</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$int</span> = <span class="number">1234</span>; </span><br><span class="line"><span class="variable">$bool</span> = is_int(<span class="variable">$int</span>); </span><br><span class="line">var_dump(<span class="variable">$bool</span>);</span><br><span class="line"><span class="comment">//检测是否为整型</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$num</span> = <span class="number">1.1234</span>; </span><br><span class="line"><span class="variable">$bool</span> = is_float(<span class="variable">$num</span>); </span><br><span class="line">var_dump(<span class="variable">$bool</span>);</span><br><span class="line"><span class="comment">//检测是否为浮点数</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$string</span> = <span class="string">&#x27;Violet&#x27;</span>; </span><br><span class="line"><span class="variable">$bool</span> = is_string(<span class="variable">$string</span>); </span><br><span class="line">var_dump(<span class="variable">$bool</span>);</span><br><span class="line"><span class="comment">//检测是否为字符串</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$var</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="variable">$bool</span> = is_null(<span class="variable">$var</span>);</span><br><span class="line">var_dump(<span class="variable">$bool</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测是否为NULL</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>自动转换</p><p>PHP类型根据值，自动转换</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$num1</span> = <span class="string">&#x27;1&#x27;</span>; </span><br><span class="line"><span class="variable">$num2</span> = <span class="string">&#x27;2&#x27;</span>; </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$num1</span> + <span class="variable">$num2</span>; <span class="comment"># 字符串转为数字相加</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h1 id="常量使用"><a href="#常量使用" class="headerlink" title="常量使用"></a>常量使用</h1><p>常量是一个简单值的标识符（名字）。常量默认为大小写敏感。按照惯例常量标识符总是大写的。</p><h2 id="常量特性"><a href="#常量特性" class="headerlink" title="常量特性"></a><strong>常量特性</strong></h2><ul><li>常量前面没有美元符号（$）</li><li>常量只能用define() 函数定义，而不能通过赋值语句</li><li>常量一旦定义就不能被重新定义或者取消定义</li><li>常量的值用来定义 整型，浮点，字符串，布尔值，数组（PHP7新增）</li><li>常量可以不用理会变量范围的可以在任何位置访问</li></ul><h2 id="声明常量"><a href="#声明常量" class="headerlink" title="声明常量"></a><strong>声明常量</strong></h2><p>常量可以使用 const 和 define 定义。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">define(<span class="string">&#x27;NAME&#x27;</span>,<span class="string">&#x27;Violet&#x27;</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//define(&#x27;NAME&#x27;,&#x27;HSF&#x27;);//常量规范常量大写</span></span><br><span class="line"><span class="keyword">echo</span> NAME;</span><br><span class="line"><span class="keyword">const</span> URL  = <span class="string">&#x27;qwq3.top&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr/&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> URL;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> URL;</span><br><span class="line">    <span class="keyword">echo</span> NAme;</span><br><span class="line">&#125;</span><br><span class="line">show();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr/&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> PHP_VERSION;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr/&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> PHP_OS;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">__METHOD__</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">new</span> demo())-&gt;show();</span><br><span class="line">print_r(get_defined_constants(categorize:<span class="literal">true</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>const</code>是语言结构，在编译时要比<code>define</code>快,<code>define</code> 可以设置第三个参数为true，来定义不区分大小写的常量,类文件中定义常量也使用<code>const</code>，所以用<code>const</code>统一易读。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">&#x27;常量名&#x27;</span>,值); </span><br><span class="line">define(<span class="string">&#x27;WEBNAME&#x27;</span>,<span class="string">&#x27;qianduan&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> WEBNAME;</span><br></pre></td></tr></table></figure><h2 id="常量检测"><a href="#常量检测" class="headerlink" title="常量检测"></a><strong>常量检测</strong></h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$bool</span> = defined(<span class="string">&#x27;WEBNAME&#x27;</span>);</span><br><span class="line">var_dump(<span class="variable">$bool</span>); <span class="comment">// 结果是false</span></span><br></pre></td></tr></table></figure><h2 id="系统常量"><a href="#系统常量" class="headerlink" title="系统常量"></a><strong>系统常量</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__DIR__            文件所在目录</span><br><span class="line">__FILE__        文件路径</span><br><span class="line">__LINE__        程序代码行号</span><br><span class="line">PHP_VERSION     显示PHP版本</span><br><span class="line">PHP_OS           显示服务器的操作系统版本</span><br><span class="line">TRUE            boolean值真(true)支持小写常量</span><br><span class="line">FALSE             boolean值假(false)支持小写常量</span><br><span class="line">__FUNCTION__    函数名称</span><br><span class="line">__METHOD__        方法名称</span><br><span class="line">__CLASS__        类名称</span><br></pre></td></tr></table></figure><blockquote><p>使用函数 get_defined_constants(true) 可以获取当前可使用的所有常量。</p></blockquote><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$a</span> = <span class="number">3</span>;</span><br><span class="line"><span class="variable">$b</span> = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>%<span class="variable">$b</span>;<span class="comment">//输出3 </span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>++;<span class="comment">//输出3，后加后减时先赋值后加减，所以输出时还是原值，但还是进行了加减在输出$a则为4</span></span><br><span class="line"><span class="keyword">echo</span> --<span class="variable">$a</span>;<span class="comment">//输出2</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">运算符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">$a+$b</td><td align="left">加法 $a和$b的和</td></tr><tr><td align="left">$a-$b</td><td align="left">减法 $a和$b的差</td></tr><tr><td align="left">$a*$b</td><td align="left">乘法 $a和$b的积</td></tr><tr><td align="left">$a/$b</td><td align="left">除法 $a除以$b的商</td></tr><tr><td align="left">$a<code>%</code> $b</td><td align="left">取模 $a除以$b后的余</td></tr><tr><td align="left">++$a 前加 $a 的值先加一，然后进行操作</td><td align="left"></td></tr><tr><td align="left">$a++</td><td align="left">后加 $a 的值先进行操作，后加一</td></tr><tr><td align="left">–$a</td><td align="left">前减 $a 的值先减一，然后进行操作</td></tr><tr><td align="left">$a–</td><td align="left">后减 $a 的值先进行操作，后减一</td></tr></tbody></table><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span> *= <span class="variable">$b</span>;</span><br><span class="line">等价于</span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$a</span>*&amp;b ;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">运算符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">右边值赋值给左边变量</td></tr><tr><td align="left">+=</td><td align="left">左边值加上右边值赋值给左边变量</td></tr><tr><td align="left">-=</td><td align="left">左边值减掉右边值赋值给左边变量</td></tr><tr><td align="left">*=</td><td align="left">左边值乘以右边值赋值给左边变量</td></tr><tr><td align="left">/=</td><td align="left">左边值除以右边值赋值给左边变量</td></tr><tr><td align="left">.=</td><td align="left">左边字符串连接到右边变量后面</td></tr><tr><td align="left">%=</td><td align="left">左边值对右边值取余数后赋值给左边变量</td></tr></tbody></table><h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><table><thead><tr><th align="left">运算符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">.</td><td align="left">它返回其左右参数连接后的字符串</td></tr><tr><td align="left">.=</td><td align="left">左边字符串连接到右边变量后面</td></tr></tbody></table><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"> <span class="variable">$a</span> = <span class="number">0</span>;</span><br><span class="line"> <span class="variable">$b</span> = <span class="literal">false</span>;</span><br><span class="line"> var_dump(<span class="variable">$a</span> == <span class="variable">$b</span>);<span class="comment">//输出真，两个等号会进行转换，三个为假</span></span><br><span class="line"> <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">运算符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">$a==$b</td><td align="left">等于 TRUE，如果$a等于$b</td></tr><tr><td align="left">$a===$b</td><td align="left">全等于 TRUE，如果$a等于$b，并且类型也相同</td></tr><tr><td align="left">$a!=$b</td><td align="left">不等 TRUE，如果$a不等于$b</td></tr><tr><td align="left">$a&lt;&gt;$b</td><td align="left">不等 TRUE，如果$a不等于$b</td></tr><tr><td align="left">$a!==$b</td><td align="left">非全等 TRUE，如果$a不等于$b，或者类型不同</td></tr><tr><td align="left">$a&lt;$b</td><td align="left">小于 TRUE，如果$a严格小于$b</td></tr><tr><td align="left">$a&gt;$b</td><td align="left">大于 TRUE，如果$a严格$b</td></tr><tr><td align="left">$a&lt;=$b</td><td align="left">小于等于 TRUE，如果 $a 小于或者等于$b</td></tr><tr><td align="left">$a&gt;=$b</td><td align="left">大于等于 TRUE，如果 $a 大于或者等于$b</td></tr></tbody></table><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th align="left">运算符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">$a and $b</td><td align="left">逻辑与 TRUE，如果 $a 与 $b 都为 TRUE</td></tr><tr><td align="left">$a or $b</td><td align="left">逻辑或 TRUE，如果 $a 或 $b 任一为TRUE</td></tr><tr><td align="left">!$a</td><td align="left">逻辑非 TRUE，如果 $a 不为 TRUE</td></tr><tr><td align="left">$a &amp;&amp; $b</td><td align="left">逻辑与 TRUE，如果 $a 与 $b 都为TRUE</td></tr><tr><td align="left">$a 或 $b</td><td align="left">逻辑或 TRUE，如果 $a 或 $b 任一为TRUE</td></tr></tbody></table><blockquote><p><code>and</code>与<code>&amp;&amp;</code> 、<code>or</code>与<code>||</code>是同一逻辑运算符的两种写法，但优先级不同。这四个符号的优先允许从高到低是：<code>&amp;&amp;</code>、<code>||</code>、<code>AND</code>、<code>OR</code>。</p></blockquote><h2 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h2><p>变量=(表达式)？值1:值2; 当表达式的返回值为true时，$变量被赋予值1，否则被赋予值2</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$var</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable">$true</span> = <span class="string">&#x27;真&#x27;</span>;</span><br><span class="line"><span class="variable">$false</span> = <span class="string">&#x27;假&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$var</span>?<span class="variable">$true</span>:<span class="variable">$false</span>;</span><br><span class="line"><span class="comment">//通过第一个值的真假来控制输出第二个值还是第三个为真则二为假则三</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>PHP 7 新增加的 NULL 合并运算符（??）是用于执行isset()检测的三元运算的快捷方式。 ?: 只判断 true 或 false ，而 ?? 判断变量存在并且值不为null</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="variable">$var</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$var</span>??<span class="string">&#x27;no&#x27;</span>;<span class="comment">//输出no</span></span><br><span class="line"><span class="variable">$var</span> = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$var</span>??<span class="string">&#x27;no&#x27;</span>;<span class="comment">//输出1</span></span><br><span class="line"><span class="comment">/*若第一个值不存在或为null则输出第二个值反之存在则输出第一个值</span></span><br><span class="line"><span class="comment">*同时具有输出，和检测是否为空的功能</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//若用？：则要用isset函数检测如 </span></span><br><span class="line"><span class="comment">//echo $var?&#x27;yes&#x27;:&#x27;no&#x27;;若$var不存在会报错</span></span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">isset</span>(<span class="variable">$var</span>)?<span class="string">&#x27;yes&#x27;</span>:<span class="string">&#x27;no&#x27;</span>;<span class="comment">//这样就可以实现检测</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="屏蔽错误"><a href="#屏蔽错误" class="headerlink" title="屏蔽错误"></a>屏蔽错误</h2><p>@ 运算符用于屏蔽表达式警告错误</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@(<span class="number">20</span>/<span class="number">0</span>); </span><br></pre></td></tr></table></figure><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="if-else-elseif"><a href="#if-else-elseif" class="headerlink" title="if/else/elseif"></a>if/else/elseif</h2><p>当条件表达式的值为真（true）时，PHP将执行语句组，相反条件表达式的值为假（false）时，PHP将不执行语句组，忽略语句组执行下面的语句。</p><p><strong>花括号形式</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$status</span> = <span class="literal">false</span>;</span><br><span class="line"> <span class="keyword">if</span>(<span class="variable">$status</span>)&#123;</span><br><span class="line">     <span class="keyword">echo</span> <span class="string">&#x27;Violet&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="keyword">echo</span> <span class="string">&#x27;qwq3.top&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>简化形式适合夹套书写html</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$status</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$status</span>):  </span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">    &lt;h1&gt;真&lt;/h1&gt;</span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line"><span class="meta">?&gt;</span> f</span><br><span class="line">   &lt;h1&gt;假&lt;/h1&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">endif</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><strong>多条件的</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$age</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$age</span>&lt;<span class="number">15</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;儿童&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">elseif</span>(<span class="variable">$age</span>&lt;<span class="number">30</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;青年&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">elseif</span>(<span class="variable">$age</span>&lt;<span class="number">50</span>)&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;中年&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;老年&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$age</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$age</span>&lt;<span class="number">15</span>):</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;儿童&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">elseif</span>(<span class="variable">$age</span>&lt;<span class="number">30</span>):</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;青年&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">elseif</span>(<span class="variable">$age</span>&lt;<span class="number">50</span>):</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;中年&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;老年&#x27;</span>;</span><br><span class="line"><span class="keyword">endif</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>switch设置多个执行代码块，break指令终止向下执行，default为上面条件都不满足时执行的默认代码块。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">switch</span> (<span class="variable">$status</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;success&#x27;</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;成功&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;error&#x27;</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;错误&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;warning&#x27;</span>:</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;警告&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>也可以使用以下写法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">switch</span> (<span class="variable">$status</span>) :</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;success&#x27;</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;成功&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;error&#x27;</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;错误&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;warning&#x27;</span>:</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;警告&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">endswitch</span>;</span><br></pre></td></tr></table></figure><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>当while循环语句中表达式（循环控制语句）的结果为真时，程序将反复执行同一段程序：循环体（ while中的语句或语句序列），直到满足一定的条件（表达式的结果为假时）后才停止执行该段程序。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$num</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="variable">$num</span>&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="variable">$num</span>--).<span class="string">&#x27;&lt;br/&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以使用以下写法</span></span><br><span class="line"><span class="variable">$num</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="variable">$num</span>&gt;<span class="number">0</span>):</span><br><span class="line">    <span class="keyword">echo</span>(<span class="variable">$num</span>--).<span class="string">&#x27;&lt;br/&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">endwhile</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="do…while"><a href="#do…while" class="headerlink" title="do…while"></a>do…while</h2><p>与while的差别是条件后判断。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$num</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="variable">$num</span>--).<span class="string">&#x27;&lt;hr/&gt;&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="variable">$num</span>&gt;<span class="number">0</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>)&#123;</span><br><span class="line">    语句或语句序列;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 表达式1为循环初始条件；</span></span><br><span class="line"><span class="comment">// 表达式2为循环控制条件；</span></span><br><span class="line"><span class="comment">// 表达式3为控制变量递增；</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$num</span>=<span class="number">10</span>;<span class="variable">$num</span>&gt;<span class="number">0</span>;<span class="variable">$num</span>--) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$num</span>.<span class="string">&#x27;&lt;hr/&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以使用以下写法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$num</span>=<span class="number">10</span>;<span class="variable">$num</span>&gt;<span class="number">0</span>;<span class="variable">$num</span>--) :</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$num</span>.<span class="string">&#x27;&lt;hr/&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">endfor</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="break-与-continue"><a href="#break-与-continue" class="headerlink" title="break 与 continue"></a>break 与 continue</h2><p><strong>break</strong></p><p>我们之前在 switch 条件判断中已经使用过 break 关键字，它会使得程序流程离开 switch 本体中的语句，如果 break 使用在 for、while 或 do-while 循环结构中时，将会使得程序离开该层循环。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$num</span>)) &#123;</span><br><span class="line">        <span class="variable">$num</span>=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$num</span>==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="variable">$num</span>--).<span class="string">&#x27;&lt;hr/&gt;&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>break 在多层循环嵌套使用时，可以指定跳转出层数。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$num</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>):</span><br><span class="line">    <span class="variable">$num</span>++;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="variable">$num</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="variable">$num</span>%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$num</span>.<span class="string">&quot;&lt;hr/&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="variable">$num</span>%<span class="number">15</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$num</span>.<span class="string">&quot;&lt;hr/&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">endwhile</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>continue 的作用与 break 有点类似，continue 若使用在 for、while 或 do-while循环结构中，当程序执行至 continue 时，之后的语句将直接被略过，而直接执行下一次的循环动作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">for ($num&#x3D;10;$num&gt;0;$num--) &#123;</span><br><span class="line">    if(!($num%2))continue;</span><br><span class="line">    echo $num.&#39;&lt;hr&#x2F;&gt;&#39;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h1 id="文件引入"><a href="#文件引入" class="headerlink" title="文件引入"></a>文件引入</h1><p><strong>include &amp; require</strong></p><p>使用include和require 将文件导入，就像把该文件粘贴到使用函数的地方。</p><blockquote><p>include( )与require ( )区别在于错误处理方式，当引入产生错误时include( )产生一个警告而require( )则导致一个致命错误。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;./test.php&#x27;</span>; </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;test&#x27;</span>; <span class="comment">//如果test.php文件不存在会报一个warning错误，但是可以输出test</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>可以使用 @ 屏蔽incluce加载警告错误</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (!@<span class="keyword">include</span> <span class="string">&#x27;a.php&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;文件不存在&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>require 加载失败时将终止程序执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;./test.php&#x27;</span>; </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;test&#x27;</span>; <span class="comment">//如果test.php文件不存在会报一个fatal错误，不可以输出test</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h1&gt;&lt;h2 id=&quot;php是什么？&quot;&gt;&lt;a href=&quot;#php是什么？&quot; class=&quot;headerlink&quot; title=&quot;php</summary>
      
    
    
    
    
    <category term="PHP" scheme="https://qwq3.top/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>SASS学习</title>
    <link href="https://qwq3.top/posts/8b43.html"/>
    <id>https://qwq3.top/posts/8b43.html</id>
    <published>2021-06-08T09:13:37.000Z</published>
    <updated>2021-11-18T04:02:22.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量;"></a>使用变量;</h1><p>sass —&gt; scss</p><p><code>sass</code>让人们受益的一个重要特性就是它为<code>css</code>引入了变量。你可以把反复使用的<code>css</code>属性值 定义成变量，然后通过变量名来引用它们，而无需重复书写这一属性值。或者，对于仅使用过一 次的属性值，你可以赋予其一个易懂的变量名，让人一眼就知道这个属性值的用途。</p><p><code>sass</code>使用<code>$</code>符号来标识变量(老版本的<code>sass</code>使用<code>!</code>来标识变量。改成$是多半因为<code>!highlight-color</code>看起来太丑了。)，比如<code>$highlight-color</code>和<code>$sidebar-width</code>。为什么选择<code>$</code> 符号呢？因为它好认、更具美感，且在CSS中并无他用，不会导致与现存或未来的<code>css</code>语法冲突。</p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明;"></a>变量声明;</h2><p><code>sass</code>变量的声明和<code>css</code>属性的声明很像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$highlight-color: #F90;</span><br></pre></td></tr></table></figure><p>这意味着变量<code>$highlight-color</code>现在的值是<code>#F90</code>。任何可以用作<code>css</code>属性值的赋值都 可以用作<code>sass</code>的变量值，甚至是以空格分割的多个属性值，如<code>$basic-border: 1px solid black;</code>，或以逗号分割的多个属性值，如<code>$plain-font: &quot;Myriad Pro&quot;、Myriad、&quot;Helvetica Neue&quot;、Helvetica、&quot;Liberation Sans&quot;、Arial和sans-serif; sans-serif;</code>。这时变 量还没有生效，除非你引用这个变量——我们很快就会了解如何引用。</p><p>与<code>CSS</code>属性不同，变量可以在<code>css</code>规则块定义之外存在。当变量定义在<code>css</code>规则块内，那么该变量只能在此规则块内使用。如果它们出现在任何形式的<code>&#123;...&#125;</code>块中（如<code>@media</code>或者<code>@font-face</code>块），情况也是如此：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$nav-color: #F90;</span><br><span class="line">nav &#123;</span><br><span class="line">  $width: 100px;</span><br><span class="line">  width: $width;</span><br><span class="line">  color: $nav-color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;编译后</span><br><span class="line"></span><br><span class="line">nav &#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  color: #F90;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，<code>$nav-color</code>这个变量定义在了规则块外边，所以在这个样式表中都可以像 <code>nav</code>规则块那样引用它。<code>$width</code>这个变量定义在了<code>nav</code>的<code>&#123; &#125;</code>规则块内，所以它只能在<code>nav</code>规则块 内使用。这意味着是你可以在样式表的其他地方定义和使用<code>$width</code>变量，不会对这里造成影响。</p><p>只声明变量其实没啥用处，我们最终的目的还是使用它们。上例已介绍了如何使用 <code>$nav-color</code>和<code>$width</code>这两个变量，接下来我们将进一步探讨变量的使用方法。</p><h2 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用;"></a>变量引用;</h2><p>凡是<code>css</code>属性的标准值（比如说1px或者bold）可存在的地方，变量就可以使用。<code>css</code>生成时，变量会被它们的值所替代。之后，如果你需要一个不同的值，只需要改变这个变量的值，则所有引用此变量的地方生成的值都会随之改变。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$highlight-color: #F90;</span><br><span class="line"><span class="selector-class">.selected</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid $highlight-color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编译后</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.selected</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#F90</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上边示例中的<code>$highlight-color</code>变量，它被直接赋值给<code>border</code>属性，当这段代码被编译输出<code>css</code>时，<code>$highlight-color</code>会被<code>#F90</code>这一颜色值所替代。产生的效果就是给<code>selected</code>这个类一条1像素宽、实心且颜色值为<code>#F90</code>的边框。</p><p>在声明变量时，变量值也可以引用其他变量。当你通过粒度区分，为不同的值取不同名字时，这相当有用。下例在独立的颜色值粒度上定义了一个变量，且在另一个更复杂的边框值粒度上也定义了一个变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$highlight-color: #F90;</span><br><span class="line">$highlight-border: 1px solid $highlight-color;</span><br><span class="line">.selected &#123;</span><br><span class="line">  border: $highlight-border;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;编译后</span><br><span class="line"></span><br><span class="line">.selected &#123;</span><br><span class="line">  border: 1px solid #F90;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>$highlight-border</code>变量的声明中使用了<code>$highlight-color</code>这个变量。产生的效 果就跟你直接为<code>border</code>属性设置了一个<code>1px</code> <code>$highlight-color solid</code>的值是一样的。 最后，我们来了解一下变量命名的实用技巧，以结束关于变量的介绍。</p><h2 id="变量名用中划线还是下划线分隔"><a href="#变量名用中划线还是下划线分隔" class="headerlink" title="变量名用中划线还是下划线分隔;"></a>变量名用中划线还是下划线分隔;</h2><p><code>sass</code>的变量名可以与<code>css</code>中的属性名和选择器名称相同，包括中划线和下划线。这完全取决于个人的喜好，有些人喜欢使用中划线来分隔变量中的多个词（如<code>$highlight-color</code>），而有些人喜欢使用下划线（如<code>$highlight_color</code>）。使用中划线的方式更为普遍，这也是<code>compass</code>和本文都用的方式。</p><p>不过，<code>sass</code>并不想强迫任何人一定使用中划线或下划线，所以这两种用法相互兼容。用中划线声明的变量可以使用下划线的方式引用，反之亦然。这意味着即使<code>compass</code>选择用中划线的命名方式，这并不影响你在使用<code>compass</code>的样式中用下划线的命名方式进行引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$link-color: blue;</span><br><span class="line">a &#123;</span><br><span class="line">  color: $link_color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;编译后</span><br><span class="line"></span><br><span class="line">a &#123;</span><br><span class="line">  color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中，<code>$link-color</code>和<code>$link_color</code>其实指向的是同一个变量。实际上，在<code>sass</code>的大多数地方，中划线命名的内容和下划线命名的内容是互通的，除了变量，也包括对混合器和Sass函数的命名。但是在<code>sass</code>中纯<code>css</code>部分不互通，比如类名、ID或属性名。</p><p>尽管变量自身提供了很多有用的地方，但是<code>sass</code>基于变量提供的更为强大的工具才是我们关注的焦点。只有当变量与<code>sass</code>的其他特性一起使用时，才能发挥其全部的潜能。接下来，我们将探讨其中一个非常重要的特性，即规则嵌套。</p><h1 id="嵌套CSS-规则"><a href="#嵌套CSS-规则" class="headerlink" title="嵌套CSS 规则;"></a>嵌套CSS 规则;</h1><p><code>css</code>中重复写选择器是非常恼人的。如果要写一大串指向页面中同一块的样式时，往往需要 一遍又一遍地写同一个<code>ID</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#content</span> <span class="selector-tag">article</span> <span class="selector-tag">h1</span> &#123; <span class="attribute">color</span>: <span class="number">#333</span> &#125;</span><br><span class="line"><span class="selector-id">#content</span> <span class="selector-tag">article</span> <span class="selector-tag">p</span> &#123; <span class="attribute">margin-bottom</span>: <span class="number">1.4em</span> &#125;</span><br><span class="line"><span class="selector-id">#content</span> <span class="selector-tag">aside</span> &#123; <span class="attribute">background-color</span>: <span class="number">#EEE</span> &#125;</span><br></pre></td></tr></table></figure><p>像这种情况，<code>sass</code>可以让你只写一遍，且使样式可读性更高。在Sass中，你可以像俄罗斯套娃那样在规则块中嵌套规则块。<code>sass</code>在输出<code>css</code>时会帮你把这些嵌套规则处理好，避免你的重复书写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#content &#123;</span><br><span class="line">  article &#123;</span><br><span class="line">    h1 &#123; color: #333 &#125;</span><br><span class="line">    p &#123; margin-bottom: 1.4em &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  aside &#123; background-color: #EEE &#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#x2F;* 编译后 *&#x2F;</span><br><span class="line">#content article h1 &#123; color: #333 &#125;</span><br><span class="line">#content article p &#123; margin-bottom: 1.4em &#125;</span><br><span class="line">#content aside &#123; background-color: #EEE &#125;</span><br></pre></td></tr></table></figure><p>上边的例子，会在输出<code>css</code>时把它转换成跟你之前看到的一样的效果。这个过程中，<code>sass</code>用了两步，每一步都是像打开俄罗斯套娃那样把里边的嵌套规则块一个个打开。首先，把<code>#content</code>（父级）这个<code>id</code>放到<code>article</code>选择器（子级）和<code>aside</code>选择器（子级）的前边：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#content &#123;</span><br><span class="line">  article &#123;</span><br><span class="line">    h1 &#123; color: #333 &#125;</span><br><span class="line">    p &#123; margin-bottom: 1.4em &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  #content aside &#123; background-color: #EEE &#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#x2F;* 编译后 *&#x2F;</span><br><span class="line">#content article h1 &#123; color: #333 &#125;</span><br><span class="line">#content article p &#123; margin-bottom: 1.4em &#125;</span><br><span class="line">#content aside &#123; background-color: #EEE &#125;</span><br></pre></td></tr></table></figure><p>然后，<code>#content article</code>里边还有嵌套的规则，<code>sass</code>重复一遍上边的步骤，把新的选择器添加到内嵌的选择器前边。</p><p>一个给定的规则块，既可以像普通的CSS那样包含属性，又可以嵌套其他规则块。当你同时要为一个容器元素及其子元素编写特定样式时，这种能力就非常有用了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#content &#123;</span><br><span class="line">  background-color: #f5f5f5;</span><br><span class="line">  aside &#123; background-color: #eee &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器元素的样式规则会被单独抽离出来，而嵌套元素的样式规则会像容器元素没有包含任何属性时那样被抽离出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#content &#123; background-color: #f5f5f5 &#125;</span><br><span class="line">#content aside &#123; background-color: #eee &#125;</span><br></pre></td></tr></table></figure><p>大多数情况下这种简单的嵌套都没问题，但是有些场景下不行，比如你想要在嵌套的选择器 里边立刻应用一个类似于<code>：hover</code>的伪类。为了解决这种以及其他情况，<code>sass</code>提供了一个特殊结 构<code>&amp;</code>。</p><h2 id="父选择器的标识符-amp"><a href="#父选择器的标识符-amp" class="headerlink" title="父选择器的标识符&amp;;"></a>父选择器的标识符&amp;;</h2><p>一般情况下，<code>sass</code>在解开一个嵌套规则时就会把父选择器（<code>#content</code>）通过一个空格连接到子选择器的前边（<code>article</code>和<code>aside</code>）形成（<code>#content article</code>和<code>#content aside</code>）。这种在CSS里边被称为后代选择器，因为它选择ID为<code>content</code>的元素内所有命中选择器<code>article</code>和<code>aside</code>的元素。但在有些情况下你却不会希望<code>sass</code>使用这种后代选择器的方式生成这种连接。</p><p>最常见的一种情况是当你为链接之类的元素写<code>：hover</code>这种伪类时，你并不希望以后代选择器的方式连接。比如说，下面这种情况<code>sass</code>就无法正常工作：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="selector-pseudo">:hover</span> &#123; <span class="attribute">color</span>: red &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着<code>color: red</code>这条规则将会被应用到选择器<code>article a :hover</code>，<code>article</code>元素内链接的所有子元素在被<code>hover</code>时都会变成红色。这是不正确的！你想把这条规则应用到超链接自身，而后代选择器的方式无法帮你实现。</p><p>解决之道为使用一个特殊的<code>sass</code>选择器，即父选择器。在使用嵌套规则时，父选择器能对于嵌套规则如何解开提供更好的控制。它就是一个简单的<code>&amp;</code>符号，且可以放在任何一个选择器可出现的地方，比如<code>h1</code>放在哪，它就可以放在哪。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">article a &#123;</span><br><span class="line">  color: blue;</span><br><span class="line">  &amp;:hover &#123; color: red &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当包含父选择器标识符的嵌套规则被打开时，它不会像后代选择器那样进行拼接，而是<code>&amp;</code>被父选择器直接替换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">article a &#123; color: blue &#125;</span><br><span class="line">article a:hover &#123; color: red &#125;</span><br></pre></td></tr></table></figure><p>在为父级选择器添加<code>：hover</code>等伪类时，这种方式非常有用。同时父选择器标识符还有另外一种用法，你可以在父选择器之前添加选择器。举例来说，当用户在使用IE浏览器时，你会通过<code>JavaScript</code>在``标签上添加一个ie的类名，为这种情况编写特殊的样式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#content aside &#123;</span><br><span class="line">  color: red;</span><br><span class="line">  body.ie &amp; &#123; color: green &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*编译后*&#x2F;</span><br><span class="line">#content aside &#123;color: red&#125;;</span><br><span class="line">body.ie #content aside &#123; color: green &#125;</span><br></pre></td></tr></table></figure><p><code>sass</code>在选择器嵌套上是非常智能的，即使是带有父选择器的情况。当<code>sass</code>遇到群组选择器（由多个逗号分隔开的选择器形成）也能完美地处理这种嵌套。</p><h2 id="群组选择器的嵌套"><a href="#群组选择器的嵌套" class="headerlink" title="群组选择器的嵌套;"></a>群组选择器的嵌套;</h2><p>在<code>CSS</code>里边，选择器<code>h1``h2</code>和<code>h3</code>会同时命中h1元素、h2元素和h3元素。与此类似，<code>.button</code> <code>button</code>会命中button元素和类名为.button的元素。这种选择器称为群组选择器。群组选择器 的规则会对命中群组中任何一个选择器的元素生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.button, button &#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当看到上边这段代码时，你可能还没意识到会有重复性的工作。但会很快发现：如果你需要在一个特定的容器元素内对这样一个群组选择器进行修饰，情况就不同了。<code>css</code>的写法会让你在群组选择器中的每一个选择器前都重复一遍容器元素的选择器。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">h1</span>, <span class="selector-class">.container</span> <span class="selector-tag">h2</span>, <span class="selector-class">.container</span> <span class="selector-tag">h3</span> &#123; <span class="attribute">margin-bottom</span>: .<span class="number">8em</span> &#125;</span><br></pre></td></tr></table></figure><p>非常幸运，<code>sass</code>的嵌套特性在这种场景下也非常有用。当<code>sass</code>解开一个群组选择器规则内嵌的规则时，它会把每一个内嵌选择器的规则都正确地解出来：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span> &#123;<span class="attribute">margin-bottom</span>: .<span class="number">8em</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先<code>sass</code>将<code>.container</code>和<code>h1``.container</code>和<code>h2``.container</code>和<code>h3</code>分别组合，然后将三 者重新组合成一个群组选择器，生成你前边看到的普通<code>css</code>样式。对于内嵌在群组选择器内的嵌 套规则，处理方式也一样：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span>, <span class="selector-tag">aside</span> &#123;</span><br><span class="line">  <span class="selector-tag">a</span> &#123;<span class="attribute">color</span>: blue&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先<code>sass</code>将<code>nav</code>和<code>a``aside</code>和<code>a</code>分别组合，然后将二者重新组合成一个群组选择器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nav a, aside a &#123;color: blue&#125;</span><br></pre></td></tr></table></figure><p>处理这种群组选择器规则嵌套上的强大能力，正是<code>sass</code>在减少重复敲写方面的贡献之一。尤其在当嵌套级别达到两层甚至三层以上时，与普通的<code>css</code>编写方式相比，只写一遍群组选择器大大减少了工作量。</p><p>有利必有弊，你需要特别注意群组选择器的规则嵌套生成的<code>css</code>。虽然<code>sass</code>让你的样式表看上去很小，但实际生成的<code>css</code>却可能非常大，这会降低网站的速度。</p><p>关于选择器嵌套的最后一个方面，我们看看<code>sass</code>如何处理组合选择器，比如&gt;、+和~的使用。你将看到，这种场景下你甚至无需使用父选择器标识符。</p><h2 id="子组合选择器和同层组合选择器：-gt-、-和"><a href="#子组合选择器和同层组合选择器：-gt-、-和" class="headerlink" title="子组合选择器和同层组合选择器：&gt;、+和~;"></a>子组合选择器和同层组合选择器：&gt;、+和~;</h2><p>上边这三个组合选择器必须和其他选择器配合使用，以指定浏览器仅选择某种特定上下文中的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">article section &#123; margin: 5px &#125;</span><br><span class="line">article &gt; section &#123; border: 1px solid #ccc &#125;</span><br></pre></td></tr></table></figure><p>你可以用子组合选择器&gt;选择一个元素的直接子元素。上例中，第一个选择器会选择article下的所有命中section选择器的元素。第二个选择器只会选择article下紧跟着的子元素中命中section选择器的元素。</p><p>在下例中，你可以用同层相邻组合选择器<code>+</code>选择<code>header</code>元素后紧跟的<code>p</code>元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header + p &#123; font-size: 1.1em &#125;</span><br></pre></td></tr></table></figure><p>你也可以用同层全体组合选择器<code>~</code>，选择所有跟在<code>article</code>后的同层<code>article</code>元素，不管它们之间隔了多少其他元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">article ~ article &#123; border-top: 1px dashed #ccc &#125;</span><br></pre></td></tr></table></figure><p>这些组合选择器可以毫不费力地应用到<code>sass</code>的规则嵌套中。可以把它们放在外层选择器后边，或里层选择器前边：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">article &#123;</span><br><span class="line">  ~ article &#123; border-top: 1px dashed #ccc &#125;</span><br><span class="line">  &gt; section &#123; background: #eee &#125;</span><br><span class="line">  dl &gt; &#123;</span><br><span class="line">    dt &#123; color: #333 &#125;</span><br><span class="line">    dd &#123; color: #555 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  nav + &amp; &#123; margin-top: 0 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sass</code>会如你所愿地将这些嵌套规则一一解开组合在一起：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">article ~ article &#123; border-top: 1px dashed #ccc &#125;</span><br><span class="line">article &gt; footer &#123; background: #eee &#125;</span><br><span class="line">article dl &gt; dt &#123; color: #333 &#125;</span><br><span class="line">article dl &gt; dd &#123; color: #555 &#125;</span><br><span class="line">nav + article &#123; margin-top: 0 &#125;</span><br></pre></td></tr></table></figure><p>在<code>sass</code>中，不仅仅<code>css</code>规则可以嵌套，对属性进行嵌套也可以减少很多重复性的工作。</p><h2 id="嵌套属性"><a href="#嵌套属性" class="headerlink" title="嵌套属性;"></a>嵌套属性;</h2><p>在<code>sass</code>中，除了CSS选择器，属性也可以进行嵌套。尽管编写属性涉及的重复不像编写选择器那么糟糕，但是要反复写<code>border-style``border-width``border-color</code>以及<code>border-*</code>等也是非常烦人的。在<code>sass</code>中，你只需敲写一遍<code>border</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nav &#123;</span><br><span class="line">  border: &#123;</span><br><span class="line">  style: solid;</span><br><span class="line">  width: 1px;</span><br><span class="line">  color: #ccc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套属性的规则是这样的：把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个<code>&#123; &#125;</code>块，把子属性部分写在这个<code>&#123; &#125;</code>块中。就像<code>css</code>选择器嵌套一样，<code>sass</code>会把你的子属性一一解开，把根属性和子属性部分通过中划线-连接起来，最后生成的效果与你手动一遍遍写的<code>css</code>样式一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nav &#123;</span><br><span class="line">  border-style: solid;</span><br><span class="line">  border-width: 1px;</span><br><span class="line">  border-color: #ccc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于属性的缩写形式，你甚至可以像下边这样来嵌套，指明例外规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nav &#123;</span><br><span class="line">  border: 1px solid #ccc &#123;</span><br><span class="line">  left: 0px;</span><br><span class="line">  right: 0px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这比下边这种同等样式的写法要好：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nav &#123;</span><br><span class="line">  border: 1px solid #ccc;</span><br><span class="line">  border-left: 0px;</span><br><span class="line">  border-right: 0px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性和选择器嵌套是非常伟大的特性，因为它们不仅大大减少了你的编写量，而且通过视觉上的缩进使你编写的样式结构更加清晰，更易于阅读和开发。</p><p>即便如此，随着你的样式表变得越来越大，这种写法也很难保持结构清晰。有时，处理这种大量样式的唯一方法就是把它们分拆到多个文件中。<code>sass</code>通过对<code>css</code>原有<code>@import</code>规则的改进直接支持了这一特性。</p><h1 id="导入SASS文件"><a href="#导入SASS文件" class="headerlink" title="导入SASS文件;"></a>导入SASS文件;</h1><p><code>css</code>有一个特别不常用的特性，即<code>@import</code>规则，它允许在一个<code>css</code>文件中导入其他<code>css</code>文件。然而，后果是只有执行到<code>@import</code>时，浏览器才会去下载其他<code>css</code>文件，这导致页面加载起来特别慢。</p><p><code>sass</code>也有一个<code>@import</code>规则，但不同的是，<code>sass</code>的<code>@import</code>规则在生成<code>css</code>文件时就把相关文件导入进来。这意味着所有相关的样式被归纳到了同一个<code>css</code>文件中，而无需发起额外的下载请求。另外，所有在被导入文件中定义的变量和混合器（参见2.5节）均可在导入文件中使用。</p><p>使用<code>sass</code>的<code>@import</code>规则并不需要指明被导入文件的全名。你可以省略<code>.sass</code>或<code>.scss</code>文件后缀（见下图）。这样，在不修改样式表的前提下，你完全可以随意修改你或别人写的被导入的<code>sass</code>样式文件语法，在<code>sass</code>和<code>scss</code>语法之间随意切换。举例来说，<code>@import</code>“sidebar”;这条命令将把<code>sidebar.scss</code>文件中所有样式添加到当前样式表中。</p><p><img src= "/img/loading.gif" data-lazy-src="https://www.sass.hk/images/p1.png" alt="img"></p><p>本节将介绍如何使用<code>sass</code>的<code>@import</code>来处理多个<code>sass</code>文件。首先，我们将学习编写那些被导入的<code>sass</code>文件，因为在一个大型<code>sass</code>项目中，这样的文件是你最常编写的那一类。接着，了解集中导入<code>sass</code>文件的方法，使你的样式可重用性更高，包括声明可自定义的变量值，以及在某一个选择器范围内导入<code>sass</code>文件。最后，介绍如何在<code>sass</code>中使用<code>css</code>原生的<code>@import</code>命令。</p><p>通常，有些<code>sass</code>文件用于导入，你并不希望为每个这样的文件单独地生成一个<code>css</code>文件。对此，<code>sass</code>用一个特殊的约定来解决。</p><h2 id="使用SASS部分文件"><a href="#使用SASS部分文件" class="headerlink" title="使用SASS部分文件;"></a>使用SASS部分文件;</h2><p>当通过<code>@import</code>把<code>sass</code>样式分散到多个文件时，你通常只想生成少数几个<code>css</code>文件。那些专门为<code>@import</code>命令而编写的<code>sass</code>文件，并不需要生成对应的独立<code>css</code>文件，这样的<code>sass</code>文件称为局部文件。对此，<code>sass</code>有一个特殊的约定来命名这些文件。</p><p>此约定即，<code>sass</code>局部文件的文件名以下划线开头。这样，<code>sass</code>就不会在编译时单独编译这个文件输出<code>css</code>，而只把这个文件用作导入。当你<code>@import</code>一个局部文件时，还可以不写文件的全名，即省略文件名开头的下划线。举例来说，你想导入<code>themes/_night-sky.scss</code>这个局部文件里的变量，你只需在样式表中写<code>@import</code> <code>&quot;themes/night-sky&quot;;</code>。</p><p>局部文件可以被多个不同的文件引用。当一些样式需要在多个页面甚至多个项目中使用时，这非常有用。在这种情况下，有时需要在你的样式表中对导入的样式稍作修改，<code>sass</code>有一个功能刚好可以解决这个问题，即默认变量值。</p><h2 id="默认变量值"><a href="#默认变量值" class="headerlink" title="默认变量值;"></a>默认变量值;</h2><p>一般情况下，你反复声明一个变量，只有最后一处声明有效且它会覆盖前边的值。举例说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$link-color: blue;</span><br><span class="line">$link-color: red;</span><br><span class="line">a &#123;</span><br><span class="line">color: $link-color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上边的例子中，超链接的<code>color</code>会被设置为<code>red</code>。这可能并不是你想要的结果，假如你写了一个可被他人通过<code>@import</code>导入的<code>sass</code>库文件，你可能希望导入者可以定制修改<code>sass</code>库文件中的某些值。使用<code>sass</code>的<code>!default</code>标签可以实现这个目的。它很像<code>css</code>属性中<code>!important</code>标签的对立面，不同的是<code>!default</code>用于变量，含义是：如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$fancybox-width: 400px !default;</span><br><span class="line">.fancybox &#123;</span><br><span class="line">width: $fancybox-width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中，如果用户在导入你的<code>sass</code>局部文件之前声明了一个<code>$fancybox-width</code>变量，那么你的局部文件中对<code>$fancybox-width</code>赋值<code>400px</code>的操作就无效。如果用户没有做这样的声明，则<code>$fancybox-width</code>将默认为<code>400px</code>。</p><p>接下来我们将学习嵌套导入，它允许只在某一个选择器的范围内导入<code>sass</code>局部文件。</p><h2 id="嵌套导入"><a href="#嵌套导入" class="headerlink" title="嵌套导入;"></a>嵌套导入;</h2><p>跟原生的<code>css</code>不同，<code>sass</code>允许<code>@import</code>命令写在<code>css</code>规则内。这种导入方式下，生成对应的<code>css</code>文件时，局部文件会被直接插入到<code>css</code>规则内导入它的地方。举例说明，有一个名为<code>_blue-theme.scss</code>的局部文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aside &#123;</span><br><span class="line">  background: blue;</span><br><span class="line">  color: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把它导入到一个CSS规则内，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.blue-theme &#123;@import &quot;blue-theme&quot;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生成的结果跟你直接在.blue-theme选择器内写_blue-theme.scss文件的内容完全一样。</span><br><span class="line"></span><br><span class="line">.blue-theme &#123;</span><br><span class="line">  aside &#123;</span><br><span class="line">    background: blue;</span><br><span class="line">    color: #fff;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被导入的局部文件中定义的所有变量和混合器，也会在这个规则范围内生效。这些变量和混合器不会全局有效，这样我们就可以通过嵌套导入只对站点中某一特定区域运用某种颜色主题或其他通过变量配置的样式。</p><p>有时，可用<code>css</code>原生的<code>@import</code>机制，在浏览器中下载必需的<code>css</code>文件。<code>sass</code>也提供了几种方法来达成这种需求。</p><h2 id="原生的CSS导入"><a href="#原生的CSS导入" class="headerlink" title="原生的CSS导入;"></a>原生的CSS导入;</h2><p>由于<code>sass</code>兼容原生的<code>css</code>，所以它也支持原生的<code>CSS@import</code>。尽管通常在<code>sass</code>中使用<code>@import</code>时，<code>sass</code>会尝试找到对应的<code>sass</code>文件并导入进来，但在下列三种情况下会生成原生的<code>CSS@import</code>，尽管这会造成浏览器解析<code>css</code>时的额外下载：</p><ul><li>被导入文件的名字以<code>.css</code>结尾；</li><li>被导入文件的名字是一个URL地址（比如<a href="http://www.sass.hk/css/css.css%EF%BC%89%EF%BC%8C%E7%94%B1%E6%AD%A4%E5%8F%AF%E7%94%A8%E8%B0%B7%E6%AD%8C%E5%AD%97%E4%BD%93API%E6%8F%90%E4%BE%9B%E7%9A%84%E7%9B%B8%E5%BA%94%E6%9C%8D%E5%8A%A1%EF%BC%9B">http://www.sass.hk/css/css.css），由此可用谷歌字体API提供的相应服务；</a></li><li>被导入文件的名字是<code>CSS</code>的url()值。</li></ul><p>这就是说，你不能用<code>sass</code>的<code>@import</code>直接导入一个原始的<code>css</code>文件，因为<code>sass</code>会认为你想用<code>css</code>原生的<code>@import</code>。但是，因为<code>sass</code>的语法完全兼容<code>css</code>，所以你可以把原始的<code>css</code>文件改名为<code>.scss</code>后缀，即可直接导入了。</p><p>文件导入是保证<code>sass</code>的代码可维护性和可读性的重要一环。次之但亦非常重要的就是注释了。注释可以帮助样式作者记录写<code>sass</code>的过程中的想法。在原生的<code>css</code>中，注释对于其他人是直接可见的，但<code>sass</code>提供了一种方式可在生成的<code>css</code>文件中按需抹掉相应的注释。</p><h1 id="静默注释"><a href="#静默注释" class="headerlink" title="静默注释;"></a>静默注释;</h1><p><code>css</code>中注释的作用包括帮助你组织样式、以后你看自己的代码时明白为什么这样写，以及简单的样式说明。但是，你并不希望每个浏览网站源码的人都能看到所有注释。</p><p><code>sass</code>另外提供了一种不同于<code>css</code>标准注释格式<code>/* ... */</code>的注释语法，即静默注释，其内容不会出现在生成的<code>css</code>文件中。静默注释的语法跟<code>JavaScript``Java</code>等类<code>C</code>的语言中单行注释的语法相同，它们以<code>//</code>开头，注释内容直到行末。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  color: #333; &#x2F;&#x2F; 这种注释内容不会出现在生成的css文件中</span><br><span class="line">  padding: 0; &#x2F;* 这种注释内容会出现在生成的css文件中 *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，<code>css</code>的标准注释格式<code>/* ... */</code>内的注释内容亦可在生成的<code>css</code>文件中抹去。当注释出现在原生<code>css</code>不允许的地方，如在<code>css</code>属性或选择器中，<code>sass</code>将不知如何将其生成到对应<code>css</code>文件中的相应位置，于是这些注释被抹掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  color &#x2F;* 这块注释内容不会出现在生成的css中 *&#x2F;: #333;</span><br><span class="line">  padding: 1; &#x2F;* 这块注释内容也不会出现在生成的css中 *&#x2F; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你已经掌握了<code>sass</code>的静默注释，了解了保持<code>sass</code>条理性和可读性的最基本的三个方法：嵌套、导入和注释。现在，我们要进一步学习新特性，这样我们不但能保持条理性还能写出更好的样式。首先要介绍的内容是：使用混合器抽象你的相关样式。</p><h1 id="混合器"><a href="#混合器" class="headerlink" title="混合器;"></a>混合器;</h1><p>如果你的整个网站中有几处小小的样式类似（例如一致的颜色和字体），那么使用变量来统一处理这种情况是非常不错的选择。但是当你的样式变得越来越复杂，你需要大段大段的重用样式的代码，独立的变量就没办法应付这种情况了。你可以通过<code>sass</code>的混合器实现大段样式的重用。</p><p>混合器使用<code>@mixin</code>标识符定义。看上去很像其他的<code>CSS @</code>标识符，比如说<code>@media</code>或者<code>@font-face</code>。这个标识符给一大段样式赋予一个名字，这样你就可以轻易地通过引用这个名字重用这段样式。下边的这段<code>sass</code>代码，定义了一个非常简单的混合器，目的是添加跨浏览器的圆角边框。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@mixin rounded-corners &#123;</span><br><span class="line">  -moz-border-radius: 5px;</span><br><span class="line">  -webkit-border-radius: 5px;</span><br><span class="line">  border-radius: 5px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以在你的样式表中通过<code>@include</code>来使用这个混合器，放在你希望的任何地方。<code>@include</code>调用会把混合器中的所有样式提取出来放在<code>@include</code>被调用的地方。如果像下边这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">notice &#123;</span><br><span class="line">  background-color: green;</span><br><span class="line">  border: 2px solid #00aa00;</span><br><span class="line">  @include rounded-corners;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;sass最终生成：</span><br><span class="line">.notice &#123;</span><br><span class="line">  background-color: green;</span><br><span class="line">  border: 2px solid #00aa00;</span><br><span class="line">  -moz-border-radius: 5px;</span><br><span class="line">  -webkit-border-radius: 5px;</span><br><span class="line">  border-radius: 5px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>.notice</code>中的属性<code>border-radius``-moz-border-radius</code>和<code>-webkit-border-radius</code>全部来自<code>rounded-corners</code>这个混合器。这一节将介绍使用混合器来避免重复。通过使用参数，你可以使用混合器把你样式中的通用样式抽离出来，然后轻松地在其他地方重用。实际上，混合器太好用了，一不小心你可能会过度使用。大量的重用可能会导致生成的样式表过大，导致加载缓慢。所以，首先我们将讨论混合器的使用场景，避免滥用。</p><h2 id="何时使用混合器"><a href="#何时使用混合器" class="headerlink" title="何时使用混合器;"></a>何时使用混合器;</h2><p>利用混合器，可以很容易地在样式表的不同地方共享样式。如果你发现自己在不停地重复一段样式，那就应该把这段样式构造成优良的混合器，尤其是这段样式本身就是一个逻辑单元，比如说是一组放在一起有意义的属性。</p><p>判断一组属性是否应该组合成一个混合器，一条经验法则就是你能否为这个混合器想出一个好的名字。如果你能找到一个很好的短名字来描述这些属性修饰的样式，比如<code>rounded-corners``fancy-font</code>或者<code>no-bullets</code>，那么往往能够构造一个合适的混合器。如果你找不到，这时候构造一个混合器可能并不合适。</p><p>混合器在某些方面跟<code>css</code>类很像。都是让你给一大段样式命名，所以在选择使用哪个的时候可能会产生疑惑。最重要的区别就是类名是在<code>html</code>文件中应用的，而混合器是在样式表中应用的。这就意味着类名具有语义化含义，而不仅仅是一种展示性的描述：用来描述<code>html</code>元素的含义而不是<code>html</code>元素的外观。而另一方面，混合器是展示性的描述，用来描述一条<code>css</code>规则应用之后会产生怎样的效果。</p><p>在之前的例子中，<code>.notice</code>是一个有语义的类名。如果一个<code>html</code>元素有一个<code>notice</code>的类名，就表明了这个<code>html</code>元素的用途：向用户展示提醒信息。<code>rounded-corners</code>混合器是展示性的，它描述了包含它的<code>css</code>规则最终的视觉样式，尤其是边框角的视觉样式。混合器和类配合使用写出整洁的<code>html</code>和<code>css</code>，因为使用语义化的类名亦可以帮你避免重复使用混合器。为了保持你的<code>html</code>和<code>css</code>的易读性和可维护性，在写样式的过程中一定要铭记二者的区别。</p><p>有时候仅仅把属性放在混合器中还远远不够，可喜的是，<code>sass</code>同样允许你把<code>css</code>规则放在混合器中。</p><h2 id="混合器中的CSS规则"><a href="#混合器中的CSS规则" class="headerlink" title="混合器中的CSS规则;"></a>混合器中的CSS规则;</h2><p>混合器中不仅可以包含属性，也可以包含<code>css</code>规则，包含选择器和选择器中的属性，如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@mixin no-bullets &#123;</span><br><span class="line">  list-style: none;</span><br><span class="line">  li &#123;</span><br><span class="line">    list-style-image: none;</span><br><span class="line">    list-style-type: none;</span><br><span class="line">    margin-left: 0px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个包含<code>css</code>规则的混合器通过<code>@include</code>包含在一个父规则中时，在混合器中的规则最终会生成父规则中的嵌套规则。举个例子，看看下边的<code>sass</code>代码，这个例子中使用了<code>no-bullets</code>这个混合器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ul.plain &#123;</span><br><span class="line">  color: #444;</span><br><span class="line">  @include no-bullets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sass</code>的<code>@include</code>指令会将引入混合器的那行代码替换成混合器里边的内容。最终，上边的例子如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ul.plain &#123;</span><br><span class="line">  color: #444;</span><br><span class="line">  list-style: none;</span><br><span class="line">&#125;</span><br><span class="line">ul.plain li &#123;</span><br><span class="line">  list-style-image: none;</span><br><span class="line">  list-style-type: none;</span><br><span class="line">  margin-left: 0px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>混合器中的规则甚至可以使用<code>sass</code>的父选择器标识符<code>&amp;</code>。使用起来跟不用混合器时一样，<code>sass</code>解开嵌套规则时，用父规则中的选择器替代<code>&amp;</code>。</p><p>如果一个混合器只包含<code>css</code>规则，不包含属性，那么这个混合器就可以在文档的顶部调用，写在所有的<code>css</code>规则之外。如果你只是为自己写一些混合器，这并没有什么大的用途，但是当你使用一个类似于<code>Compass</code>的库时，你会发现，这是提供样式的好方法，原因在于你可以选择是否使用这些样式。</p><p>接下来你将学习如何通过给混合器传参数来让混合器变得更加灵活和可重用。</p><h2 id="给混合器传参"><a href="#给混合器传参" class="headerlink" title="给混合器传参;"></a>给混合器传参;</h2><p>混合器并不一定总得生成相同的样式。可以通过在<code>@include</code>混合器时给混合器传参，来定制混合器生成的精确样式。当<code>@include</code>混合器时，参数其实就是可以赋值给<code>css</code>属性值的变量。如果你写过<code>JavaScript</code>，这种方式跟<code>JavaScript</code>的<code>function</code>很像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@mixin link-colors($normal, $hover, $visited) &#123;</span><br><span class="line">  color: $normal;</span><br><span class="line">  &amp;:hover &#123; color: $hover; &#125;</span><br><span class="line">  &amp;:visited &#123; color: $visited; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当混合器被<code>@include</code>时，你可以把它当作一个<code>css</code>函数来传参。如果你像下边这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">  @include link-colors(blue, red, green);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Sass最终生成的是：</span><br><span class="line"></span><br><span class="line">a &#123; color: blue; &#125;</span><br><span class="line">a:hover &#123; color: red; &#125;</span><br><span class="line">a:visited &#123; color: green; &#125;</span><br></pre></td></tr></table></figure><p>当你@include混合器时，有时候可能会很难区分每个参数是什么意思，参数之间是一个什么样的顺序。为了解决这个问题，<code>sass</code>允许通过语法<code>$name: value</code>的形式指定每个参数的值。这种形式的传参，参数顺序就不必再在乎了，只需要保证没有漏掉参数即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">    @include link-colors(</span><br><span class="line">      $normal: blue,</span><br><span class="line">      $visited: green,</span><br><span class="line">      $hover: red</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管给混合器加参数来实现定制很好，但是有时有些参数我们没有定制的需要，这时候也需要赋值一个变量就变成很痛苦的事情了。所以<code>sass</code>允许混合器声明时给参数赋默认值。</p><h2 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值;"></a>默认参数值;</h2><p>为了在<code>@include</code>混合器时不必传入所有的参数，我们可以给参数指定一个默认值。参数默认值使用<code>$name: default-value</code>的声明形式，默认值可以是任何有效的<code>css</code>属性值，甚至是其他参数的引用，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@mixin link-colors(</span><br><span class="line">    $normal,</span><br><span class="line">    $hover: $normal,</span><br><span class="line">    $visited: $normal</span><br><span class="line">  )</span><br><span class="line">&#123;</span><br><span class="line">  color: $normal;</span><br><span class="line">  &amp;:hover &#123; color: $hover; &#125;</span><br><span class="line">  &amp;:visited &#123; color: $visited; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果像下边这样调用：<code>@include link-colors(red)</code> <code>$hover</code>和<code>$visited</code>也会被自动赋值为<code>red</code>。</p><p>混合器只是<code>sass</code>样式重用特性中的一个。我们已经了解到混合器主要用于样式展示层的重用，如果你想重用语义化的类呢？这就涉及<code>sass</code>的另一个重要的重用特性：选择器继承。</p><h1 id="使用选择器继承来精简CSS"><a href="#使用选择器继承来精简CSS" class="headerlink" title="使用选择器继承来精简CSS;"></a>使用选择器继承来精简CSS;</h1><p>使用<code>sass</code>的时候，最后一个减少重复的主要特性就是选择器继承。基于<code>Nicole Sullivan</code>面向对象的<code>css</code>的理念，选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过<code>@extend</code>语法实现，如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过选择器继承继承样式</span><br><span class="line">.error &#123;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">  background-color: #fdd;</span><br><span class="line">&#125;</span><br><span class="line">.seriousError &#123;</span><br><span class="line">  @extend .error;</span><br><span class="line">  border-width: 3px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上边的代码中，<code>.seriousError</code>将会继承样式表中任何位置处为<code>.error</code>定义的所有样式。以<code>class=&quot;seriousError&quot;</code> 修饰的<code>html</code>元素最终的展示效果就好像是<code>class=&quot;seriousError error&quot;</code>。相关元素不仅会拥有一个<code>3px</code>宽的边框，而且这个边框将变成红色的，这个元素同时还会有一个浅红色的背景，因为这些都是在<code>.error</code>里边定义的样式。</p><p><code>.seriousError</code>不仅会继承<code>.error</code>自身的所有样式，任何跟<code>.error</code>有关的组合选择器样式也会被<code>.seriousError</code>以组合选择器的形式继承，如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;.seriousError从.error继承样式</span><br><span class="line">.error a&#123;  &#x2F;&#x2F;应用到.seriousError a</span><br><span class="line">  color: red;</span><br><span class="line">  font-weight: 100;</span><br><span class="line">&#125;</span><br><span class="line">h1.error &#123; &#x2F;&#x2F;应用到hl.seriousError</span><br><span class="line">  font-size: 1.2rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，在<code>class=&quot;seriousError&quot;</code>的<code>html</code>元素内的超链接也会变成红色和粗体。</p><p>本节将介绍与混合器相比，哪种情况下更适合用继承。接下来在探索继承的工作细节之前，我们先了解一下继承的高级用法。最后，我们将看看使用继承可能会有哪些坑，学习如何避免这些坑。</p><h2 id="何时使用继承"><a href="#何时使用继承" class="headerlink" title="何时使用继承;"></a>何时使用继承;</h2><p>5-1节介绍了<a href="https://www.sass.hk/guide/">混合器</a>主要用于展示性样式的重用，而类名用于语义化样式的重用。因为继承是基于类的（有时是基于其他类型的选择器），所以继承应该是建立在语义化的关系上。当一个元素拥有的类（比如说<code>.seriousError</code>）表明它属于另一个类（比如说<code>.error</code>），这时使用继承再合适不过了。</p><p>这有点抽象，所以我们从几个方面来阐释一下。想象一下你正在编写一个页面，给<code>html</code>元素添加类名，你发现你的某个类（比如说<code>.seriousError</code>）另一个类（比如说<code>.error</code>）的细化。你会怎么做？</p><ul><li>你可以为这两个类分别写相同的样式，但是如果有大量的重复怎么办？使用<code>sass</code>时，我们提倡的就是不要做重复的工作。</li><li>你可以使用一个选择器组（比如说<code>.error``.seriousError</code>）给这两个选择器写相同的样式。如果.error的所有样式都在同一个地方，这种做法很好，但是如果是分散在样式表的不同地方呢？再这样做就困难多了。</li><li>你可以使用一个混合器为这两个类提供相同的样式，但当<code>.error</code>的样式修饰遍布样式表中各处时，这种做法面临着跟使用选择器组一样的问题。这两个类也不是恰好有相同的 样式。你应该更清晰地表达这种关系。</li><li>综上所述你应该使用<code>@extend</code>。让<code>.seriousError</code>从<code>.error</code>继承样式，使两者之间的关系非常清晰。更重要的是无论你在样式表的哪里使用<code>.error``.seriousError</code>都会继承其中的样式。</li></ul><p>现在你已经更好地掌握了何时使用继承，以及继承有哪些突出的优点，接下来我们看看一些高级用法。</p><h2 id="继承的高级用法"><a href="#继承的高级用法" class="headerlink" title="继承的高级用法;"></a>继承的高级用法;</h2><p>任何<code>css</code>规则都可以继承其他规则，几乎任何<code>css</code>规则也都可以被继承。大多数情况你可能只想对类使用继承，但是有些场合你可能想做得更多。最常用的一种高级用法是继承一个<code>html</code>元素的样式。尽管默认的浏览器样式不会被继承，因为它们不属于样式表中的样式，但是你对<code>html</code>元素添加的所有样式都会被继承。</p><p>接下来的这段代码定义了一个名为<code>disabled</code>的类，样式修饰使它看上去像一个灰掉的超链接。通过继承a这一超链接元素来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.disabled &#123;</span><br><span class="line">  color: gray;</span><br><span class="line">  @extend a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如一条样式规则继承了一个复杂的选择器，那么它只会继承这个复杂选择器命中的元素所应用的样式。举例来说， 如果<code>.seriousError``@extend``.important.error</code> ， 那么<code>.important.error</code> 和<code>h1.important.error</code> 的样式都会被<code>.seriousError</code>继承， 但是<code>.important</code>或者<code>.error下</code>的样式则不会被继承。这种情况下你很可能希望<code>.seriousError</code>能够分别继承<code>.important</code>或者<code>.error</code>下的样式。</p><p>如果一个选择器序列（<code>#main .seriousError</code>）<code>@extend</code>另一个选择器（<code>.error</code>），那么只有完全匹配<code>#main .seriousError</code>这个选择器的元素才会继承<code>.error</code>的样式，就像单个类 名继承那样。拥有<code>class=&quot;seriousError&quot;</code>的<code>#main</code>元素之外的元素不会受到影响。</p><p>像<code>#main .error</code>这种选择器序列是不能被继承的。这是因为从<code>#main .error</code>中继承的样式一般情况下会跟直接从<code>.error</code>中继承的样式基本一致，细微的区别往往使人迷惑。</p><p>现在你已经了解了通过继承能够做些什么事情，接下来我们将学习继承的工作细节，在生成对应<code>css</code>的时候，<code>sass</code>具体干了些什么事情。</p><h2 id="继承的工作细节"><a href="#继承的工作细节" class="headerlink" title="继承的工作细节;"></a>继承的工作细节;</h2><p>跟变量和混合器不同，继承不是仅仅用<code>css</code>样式替换@extend处的代码那么简单。为了不让你对生成的<code>css</code>感觉奇怪，对这背后的工作原理有一定了解是非常重要的。</p><p><code>@extend</code>背后最基本的想法是，如果<code>.seriousError @extend .error</code>， 那么样式表中的任何一处<code>.error</code>都用<code>.error``.seriousError</code>这一选择器组进行替换。这就意味着相关样式会如预期那样应用到<code>.error</code>和<code>.seriousError</code>。当<code>.error</code>出现在复杂的选择器中，比如说<code>h1.error``.error a</code>或者<code>#main .sidebar input.error[type=&quot;text&quot;]</code>，那情况就变得复杂多了，但是不用担心，<code>sass</code>已经为你考虑到了这些。</p><p>关于<code>@extend</code>有两个要点你应该知道。</p><ul><li>跟混合器相比，继承生成的<code>css</code>代码相对更少。因为继承仅仅是重复选择器，而不会重复属性，所以使用继承往往比混合器生成的<code>css</code>体积更小。如果你非常关心你站点的速度，请牢记这一点。</li><li>继承遵从<code>css</code>层叠的规则。当两个不同的<code>css</code>规则应用到同一个<code>html</code>元素上时，并且这两个不同的<code>css</code>规则对同一属性的修饰存在不同的值，<code>css</code>层叠规则会决定应用哪个样式。相当直观：通常权重更高的选择器胜出，如果权重相同，定义在后边的规则胜出。</li></ul><p>混合器本身不会引起<code>css</code>层叠的问题，因为混合器把样式直接放到了<code>css</code>规则中，而继承存在样式层叠的问题。被继承的样式会保持原有定义位置和选择器权重不变。通常来说这并不会引起什么问题，但是知道这点总没有坏处。</p><h2 id="使用继承的最佳实践"><a href="#使用继承的最佳实践" class="headerlink" title="使用继承的最佳实践;"></a>使用继承的最佳实践;</h2><p>通常使用继承会让你的<code>css</code>美观、整洁。因为继承只会在生成<code>css</code>时复制选择器，而不会复制大段的<code>css</code>属性。但是如果你不小心，可能会让生成的<code>css</code>中包含大量的选择器复制。</p><p>避免这种情况出现的最好方法就是不要在<code>css</code>规则中使用后代选择器（比如<code>.foo .bar</code>）去继承<code>css</code>规则。如果你这么做，同时被继承的<code>css</code>规则有通过后代选择器修饰的样式，生成<code>css</code>中的选择器的数量很快就会失控：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.foo .bar &#123; @extend .baz; &#125;</span><br><span class="line">.bip .baz &#123; a: b; &#125;</span><br></pre></td></tr></table></figure><p>在上边的例子中，<code>sass</code>必须保证应用到.baz的样式同时也要应用到<code>.foo .bar</code>（位于class=”foo”的元素内的class=”bar”的元素）。例子中有一条应用到<code>.bip .baz</code>（位于class=”bip”的元素内的class=”baz”的元素）的<code>css</code>规则。当这条规则应用到<code>.foo .bar</code>时，可能存在三种情况，如下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 继承可能迅速变复杂 --&gt;</span><br><span class="line">&lt;!-- Case 1 --&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;foo&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bip&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;bar&quot;&gt;...&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;!-- Case 2 --&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;bip&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;foo&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;bar&quot;&gt;...&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;!-- Case 3 --&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;foo bip&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bar&quot;&gt;...&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>为了应付这些情况，<code>sass</code>必须生成三种选择器组合（仅仅是.bip .foo .bar不能覆盖所有情况）。如果任何一条规则里边的后代选择器再长一点，<code>sass</code>需要考虑的情况就会更多。实际上<code>sass</code>并不总是会生成所有可能的选择器组合，即使是这样，选择器的个数依然可能会变得相当大，所以如果允许，尽可能避免这种用法。</p><p>值得一提的是，只要你想，你完全可以放心地继承有后代选择器修饰规则的选择器，不管后代选择器多长，但有一个前提就是，不要用后代选择器去继承。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结;"></a>小结;</h1><p>本文介绍了<code>sass</code>最基本部分,你可以轻松地使用<code>sass</code>编写清晰、无冗余、语义化的<code>css</code>。对于<code>sass</code>提供的工具你已经有了一个比较深入的了解，同时也掌握了何时使用这些工具的指导原则。</p><p>变量是<code>sass</code>提供的最基本的工具。通过变量可以让独立的<code>css</code>值变得可重用，无论是在一条单独的规则范围内还是在整个样式表中。变量、混合器的命名甚至<code>sass</code>的文件名，可以互换通用<code>_</code>和<code>-</code>。同样基础的是<code>sass</code>的嵌套机制。嵌套允许<code>css</code>规则内嵌套<code>css</code>规则，减少重复编写常用的选择器，同时让样式表的结构一眼望去更加清晰。<code>sass</code>同时提供了特殊的父选择器标识符<code>&amp;</code>，通过它可以构造出更高效的嵌套。</p><p>你也已经学到了<code>sass</code>的另一个重要特性，样式导入。通过样式导入可以把分散在多个<code>sass</code>文件中的内容合并生成到一个<code>css</code>文件，避免了项目中有大量的<code>css</code>文件通过原生的<code>css</code> <code>@import</code>带来的性能问题。通过嵌套导入和默认变量值，导入可以构建更强有力的、可定制的样式。混合器允许用户编写语义化样式的同时避免视觉层面上样式的重复。你不仅学到了如何使用混合器减少重复，同时学习到了如何使用混合器让你的<code>css</code>变得更加可维护和语义化。最后，我们学习了与混合器相辅相成的选择器继承。继承允许你声明类之间语义化的关系，通过这些关系可以保持你的<code>css</code>的整洁和可维护性。</p>]]></content>
    
    
    <summary type="html">sass, css, css3, scss学习</summary>
    
    
    
    
    <category term="CSS" scheme="https://qwq3.top/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC04：Ajax,拦截器,文件上传和下载</title>
    <link href="https://qwq3.top/posts/3777.html"/>
    <id>https://qwq3.top/posts/3777.html</id>
    <published>2021-06-04T17:26:17.000Z</published>
    <updated>2021-11-18T04:02:22.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ajax研究"><a href="#Ajax研究" class="headerlink" title="Ajax研究"></a>Ajax研究</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><p><strong>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</strong></p></li><li><p>AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p></li><li><p><strong>Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。</strong></p></li><li><p>在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。</p></li><li><p>Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。</p></li><li><p>就和国内百度的搜索框一样!</p></li><li><p>传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。</p></li><li><p>使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。</p></li><li><p>使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。</p></li></ul><h2 id="伪造Ajax"><a href="#伪造Ajax" class="headerlink" title="伪造Ajax"></a>伪造Ajax</h2><p>我们可以使用前端的一个标签来伪造一个ajax的样子。iframe标签</p><ol><li><p>新建一个module ：sspringmvc-06-ajax ， 导入web支持！</p></li><li><p>编写一个 ajax-frame.html 使用 iframe 测试，感受下效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>kuangshen<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">       <span class="keyword">var</span> myDate = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="javascript">       <span class="built_in">document</span>.getElementById(<span class="string">&#x27;currentTime&#x27;</span>).innerText = myDate.getTime();</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">   <span class="function"><span class="keyword">function</span> <span class="title">LoadPage</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">       <span class="keyword">var</span> targetUrl =  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;url&#x27;</span>).value;</span></span><br><span class="line"><span class="javascript">       <span class="built_in">console</span>.log(targetUrl);</span></span><br><span class="line"><span class="javascript">       <span class="built_in">document</span>.getElementById(<span class="string">&quot;iframePosition&quot;</span>).src = targetUrl;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>请输入要加载的地址：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;currentTime&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;url&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;https://www.baidu.com/&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;LoadPage()&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h3</span>&gt;</span>加载页面位置：<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;iframePosition&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%;height: 500px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用IDEA开浏览器测试一下！</p></li></ol><p><strong>利用AJAX可以做：</strong></p><ul><li>注册时，输入用户名自动检测用户是否已经存在。</li><li>登陆时，提示用户名密码错误</li><li>删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。</li><li>….等等</li></ul><h2 id="jQuery-ajax"><a href="#jQuery-ajax" class="headerlink" title="jQuery.ajax"></a>jQuery.ajax</h2><p>纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣的同学可以去了解下JS原生XMLHttpRequest ！</p><p>Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。</p><p>jQuery 提供多个与 AJAX 有关的方法。</p><p>通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。</p><p>jQuery 不是生产者，而是大自然搬运工。</p><p>jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax(...)</span><br><span class="line">      部分参数：</span><br><span class="line">            url：请求地址</span><br><span class="line">            type：请求方式，GET、POST（1.9.0之后用method）</span><br><span class="line">        headers：请求头</span><br><span class="line">            data：要发送的数据</span><br><span class="line">    contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8&quot;)</span><br><span class="line">          async：是否异步</span><br><span class="line">        timeout：设置请求超时时间（毫秒）</span><br><span class="line">      beforeSend：发送请求前执行的函数(全局)</span><br><span class="line">        complete：完成之后执行的回调函数(全局)</span><br><span class="line">        success：成功之后执行的回调函数(全局)</span><br><span class="line">          error：失败之后执行的回调函数(全局)</span><br><span class="line">        accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型</span><br><span class="line">        dataType：将服务器端返回的数据转换成指定类型</span><br><span class="line">          &quot;xml&quot;: 将服务器端返回的内容转换成xml格式</span><br><span class="line">          &quot;text&quot;: 将服务器端返回的内容转换成普通文本格式</span><br><span class="line">          &quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。</span><br><span class="line">        &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式</span><br><span class="line">          &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象</span><br><span class="line">        &quot;jsonp&quot;: JSONP 格式使用 JSONP 形式调用函数时，如 &quot;myurl?callback&#x3D;?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数</span><br></pre></td></tr></table></figure><p><strong>我们来个简单的测试，使用最原始的HttpServletResponse处理 , .最简单 , 最通用</strong></p><ol><li><p>配置web.xml 和 springmvc的配置文件，复制上面案例的即可 【记得静态资源过滤和注解驱动配置上】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kuang.controller&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写一个AjaxController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AjaxController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/a1&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ajax1</span><span class="params">(String name , HttpServletResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(name))&#123;</span><br><span class="line">           response.getWriter().print(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           response.getWriter().print(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>导入jquery ， 可以使用在线的CDN ， 也可以下载导入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写index.jsp测试</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">   &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">  &lt;%--&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;--%&gt;</span><br><span class="line">   &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script&gt;</span><br><span class="line">       <span class="function">function <span class="title">a1</span><span class="params">()</span></span>&#123;</span><br><span class="line">           $.post(&#123;</span><br><span class="line">               url:<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/a1&quot;</span>,</span><br><span class="line">               data:&#123;<span class="string">&#x27;name&#x27;</span>:$(<span class="string">&quot;#txtName&quot;</span>).val()&#125;,</span><br><span class="line">               success:function (data,status) &#123;</span><br><span class="line">                   alert(data);</span><br><span class="line">                   alert(status);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">   &lt;/script&gt;</span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--onblur：失去焦点触发事件--%&gt;</span><br><span class="line">用户名:&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;txtName&quot;</span> onblur=<span class="string">&quot;a1()&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>启动tomcat测试！打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！</p></li></ol><p><strong>Springmvc实现</strong></p><p>实体类user</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来获取一个集合对象，展示到前端页面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/a2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">ajax2</span><span class="params">()</span></span>&#123;</span><br><span class="line">   List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">   list.add(<span class="keyword">new</span> User(<span class="string">&quot;秦疆1号&quot;</span>,<span class="number">3</span>,<span class="string">&quot;男&quot;</span>));</span><br><span class="line">   list.add(<span class="keyword">new</span> User(<span class="string">&quot;秦疆2号&quot;</span>,<span class="number">3</span>,<span class="string">&quot;男&quot;</span>));</span><br><span class="line">   list.add(<span class="keyword">new</span> User(<span class="string">&quot;秦疆3号&quot;</span>,<span class="number">3</span>,<span class="string">&quot;男&quot;</span>));</span><br><span class="line">   <span class="keyword">return</span> list; <span class="comment">//由于@RestController注解，将list转成json格式返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端页面</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;btn&quot;</span> value=<span class="string">&quot;获取数据&quot;</span>/&gt;</span><br><span class="line">&lt;table width=<span class="string">&quot;80%&quot;</span> align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">   &lt;tr&gt;</span><br><span class="line">       &lt;td&gt;姓名&lt;/td&gt;</span><br><span class="line">       &lt;td&gt;年龄&lt;/td&gt;</span><br><span class="line">       &lt;td&gt;性别&lt;/td&gt;</span><br><span class="line">   &lt;/tr&gt;</span><br><span class="line">   &lt;tbody id=<span class="string">&quot;content&quot;</span>&gt;</span><br><span class="line">   &lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">   $(function () &#123;</span><br><span class="line">       $(<span class="string">&quot;#btn&quot;</span>).click(function () &#123;</span><br><span class="line">           $.post(<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/a2&quot;</span>,function (data) &#123;</span><br><span class="line">               console.log(data)</span><br><span class="line">               <span class="keyword">var</span> html=<span class="string">&quot;&quot;</span>;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;data.length ; i++) &#123;</span><br><span class="line">                   html+= <span class="string">&quot;&lt;tr&gt;&quot;</span> +</span><br><span class="line">                       <span class="string">&quot;&lt;td&gt;&quot;</span> + data[i].name + <span class="string">&quot;&lt;/td&gt;&quot;</span> +</span><br><span class="line">                       <span class="string">&quot;&lt;td&gt;&quot;</span> + data[i].age + <span class="string">&quot;&lt;/td&gt;&quot;</span> +</span><br><span class="line">                       <span class="string">&quot;&lt;td&gt;&quot;</span> + data[i].sex + <span class="string">&quot;&lt;/td&gt;&quot;</span> +</span><br><span class="line">                       <span class="string">&quot;&lt;/tr&gt;&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">               $(<span class="string">&quot;#content&quot;</span>).html(html);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>成功实现了数据回显！可以体会一下Ajax的好处！</strong></p><h2 id="注册提示效果"><a href="#注册提示效果" class="headerlink" title="注册提示效果"></a>注册提示效果</h2><p>我们再测试一个小Demo，思考一下我们平时注册时候，输入框后面的实时提示怎么做到的；如何优化</p><p>我们写一个Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/a3&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">ajax3</span><span class="params">(String name,String pwd)</span></span>&#123;</span><br><span class="line">   String msg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">   <span class="comment">//模拟数据库中存在数据</span></span><br><span class="line">   <span class="keyword">if</span> (name!=<span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(name))&#123;</span><br><span class="line">           msg = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           msg = <span class="string">&quot;用户名输入错误&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">if</span> (pwd!=<span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="string">&quot;123456&quot;</span>.equals(pwd))&#123;</span><br><span class="line">           msg = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           msg = <span class="string">&quot;密码输入有误&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">return</span> msg; <span class="comment">//由于@RestController注解，将msg转成json格式返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端页面 login.jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;ajax&lt;/title&gt;</span><br><span class="line">   &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/statics/js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;script&gt;</span><br><span class="line"></span><br><span class="line">       <span class="function">function <span class="title">a1</span><span class="params">()</span></span>&#123;</span><br><span class="line">           $.post(&#123;</span><br><span class="line">               url:<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;</span>,</span><br><span class="line">               data:&#123;<span class="string">&#x27;name&#x27;</span>:$(<span class="string">&quot;#name&quot;</span>).val()&#125;,</span><br><span class="line">               success:function (data) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (data.toString()==<span class="string">&#x27;OK&#x27;</span>)&#123;</span><br><span class="line">                       $(<span class="string">&quot;#userInfo&quot;</span>).css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;green&quot;</span>);</span><br><span class="line">                  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                       $(<span class="string">&quot;#userInfo&quot;</span>).css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                   $(<span class="string">&quot;#userInfo&quot;</span>).html(data);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="function">function <span class="title">a2</span><span class="params">()</span></span>&#123;</span><br><span class="line">           $.post(&#123;</span><br><span class="line">               url:<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;</span>,</span><br><span class="line">               data:&#123;<span class="string">&#x27;pwd&#x27;</span>:$(<span class="string">&quot;#pwd&quot;</span>).val()&#125;,</span><br><span class="line">               success:function (data) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (data.toString()==<span class="string">&#x27;OK&#x27;</span>)&#123;</span><br><span class="line">                       $(<span class="string">&quot;#pwdInfo&quot;</span>).css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;green&quot;</span>);</span><br><span class="line">                  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                       $(<span class="string">&quot;#pwdInfo&quot;</span>).css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                   $(<span class="string">&quot;#pwdInfo&quot;</span>).html(data);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">  用户名:&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;name&quot;</span> onblur=<span class="string">&quot;a1()&quot;</span>/&gt;</span><br><span class="line">   &lt;span id=&quot;userInfo&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">  密码:&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;pwd&quot;</span> onblur=<span class="string">&quot;a2()&quot;</span>/&gt;</span><br><span class="line">   &lt;span id=&quot;pwdInfo&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>【记得处理json乱码问题】</p><p>测试一下效果，动态请求响应，局部刷新，就是如此！</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterChen520/Drawingbed/img/20210604173342.png"></p><h2 id="获取baidu接口Demo"><a href="#获取baidu接口Demo" class="headerlink" title="获取baidu接口Demo"></a>获取baidu接口Demo</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>JSONP百度搜索<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">       #q&#123;</span><br><span class="line"><span class="css">           <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">           <span class="attribute">height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">           <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#ddd</span>;</span></span><br><span class="line"><span class="css">           <span class="attribute">line-height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">           <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="css">           <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">           <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">10px</span>;</span></span><br><span class="line"><span class="css">           <span class="attribute">font-size</span>: <span class="number">14px</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line">       #ul&#123;</span><br><span class="line"><span class="css">           <span class="attribute">width</span>: <span class="number">520px</span>;</span></span><br><span class="line"><span class="css">           <span class="attribute">list-style</span>: none;</span></span><br><span class="line"><span class="css">           <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">           <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">           <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#ddd</span>;</span></span><br><span class="line"><span class="css">           <span class="attribute">margin-top</span>: -<span class="number">1px</span>;</span></span><br><span class="line"><span class="css">           <span class="attribute">display</span>: none;</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">       <span class="selector-id">#ul</span> <span class="selector-tag">li</span>&#123;</span></span><br><span class="line"><span class="css">           <span class="attribute">line-height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">           <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">10px</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">       <span class="selector-id">#ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="css">           <span class="attribute">background-color</span>: <span class="number">#f60</span>;</span></span><br><span class="line"><span class="css">           <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">       <span class="comment">// 2.步骤二</span></span></span><br><span class="line"><span class="javascript">       <span class="comment">// 定义demo函数 (分析接口、数据)</span></span></span><br><span class="line"><span class="javascript">       <span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">           <span class="keyword">var</span> Ul = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;ul&#x27;</span>);</span></span><br><span class="line"><span class="javascript">           <span class="keyword">var</span> html = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="javascript">           <span class="comment">// 如果搜索数据存在 把内容添加进去</span></span></span><br><span class="line">           if (data.s.length) &#123;</span><br><span class="line"><span class="javascript">               <span class="comment">// 隐藏掉的ul显示出来</span></span></span><br><span class="line"><span class="javascript">               Ul.style.display = <span class="string">&#x27;block&#x27;</span>;</span></span><br><span class="line"><span class="javascript">               <span class="comment">// 搜索到的数据循环追加到li里</span></span></span><br><span class="line"><span class="javascript">               <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;data.s.length;i++)&#123;</span></span><br><span class="line"><span class="javascript">                   html += <span class="string">&#x27;&lt;li&gt;&#x27;</span>+data.s[i]+<span class="string">&#x27;&lt;/li&gt;&#x27;</span>;</span></span><br><span class="line">              &#125;</span><br><span class="line"><span class="javascript">               <span class="comment">// 循环的li写入ul</span></span></span><br><span class="line">               Ul.innerHTML = html;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">       <span class="comment">// 1.步骤一</span></span></span><br><span class="line"><span class="javascript">       <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">           <span class="comment">// 获取输入框和ul</span></span></span><br><span class="line"><span class="javascript">           <span class="keyword">var</span> Q = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;q&#x27;</span>);</span></span><br><span class="line"><span class="javascript">           <span class="keyword">var</span> Ul = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;ul&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">           <span class="comment">// 事件鼠标抬起时候</span></span></span><br><span class="line"><span class="javascript">           Q.onkeyup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">               <span class="comment">// 如果输入框不等于空</span></span></span><br><span class="line"><span class="javascript">               <span class="keyword">if</span> (<span class="built_in">this</span>.value != <span class="string">&#x27;&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">                   <span class="comment">// ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆JSONPz重点☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆</span></span></span><br><span class="line"><span class="javascript">                   <span class="comment">// 创建标签</span></span></span><br><span class="line"><span class="javascript">                   <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                   <span class="comment">//给定要跨域的地址 赋值给src</span></span></span><br><span class="line"><span class="javascript">                   <span class="comment">//这里是要请求的跨域的地址 我写的是百度搜索的跨域地址</span></span></span><br><span class="line"><span class="javascript">                   script.src = <span class="string">&#x27;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&#x27;</span>+<span class="built_in">this</span>.value+<span class="string">&#x27;&amp;cb=demo&#x27;</span>;</span></span><br><span class="line"><span class="javascript">                   <span class="comment">// 将组合好的带src的script标签追加到body里</span></span></span><br><span class="line"><span class="javascript">                   <span class="built_in">document</span>.body.appendChild(script);</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;q&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Ajax在我们开发中十分重要，一定要学会使用！</p><h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter,用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。</p><p><strong>过滤器与拦截器的区别：</strong>拦截器是AOP思想的具体应用。</p><p><strong>过滤器</strong></p><ul><li>servlet规范中的一部分，任何java web工程都可以使用</li><li>在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截</li></ul><p><strong>拦截器</strong> </p><ul><li>拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用</li><li>拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的</li></ul><h2 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h2><p>那如何实现拦截器呢？</p><p>想要自定义拦截器，必须实现 HandlerInterceptor 接口。</p><ol><li><p>新建一个Moudule ， springmvc-07-Interceptor  ， 添加web支持</p></li><li><p>配置web.xml 和 springmvc-servlet.xml 文件</p></li><li><p>编写一个拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//在请求处理的方法之前执行</span></span><br><span class="line">   <span class="comment">//如果返回true执行下一个拦截器</span></span><br><span class="line">   <span class="comment">//如果返回false就不执行下一个拦截器</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;------------处理前------------&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//在请求处理方法执行之后执行</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;------------处理后------------&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//在dispatcherServlet处理后执行,做清理工作.</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;------------清理------------&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在springmvc的配置文件中配置拦截器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--关于拦截器的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--/** 包括路径及其子路径--&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--/admin/** 拦截的是/admin/下的所有--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--bean配置的就是拦截器--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.interceptor.MyInterceptor&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写一个Controller，接收请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试拦截器的控制器</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/interceptor&quot;)</span></span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">testFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;控制器中的方法执行了&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>前端 index.jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/interceptor&quot;&gt;拦截器测试&lt;/a&gt;</span><br></pre></td></tr></table></figure></li><li><p>启动tomcat 测试一下！<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterChen520/Drawingbed/img/20210604173602.png"></p></li></ol><h2 id="验证用户是否登录-认证用户"><a href="#验证用户是否登录-认证用户" class="headerlink" title="验证用户是否登录 (认证用户)"></a>验证用户是否登录 (认证用户)</h2><p><strong>实现思路</strong></p><ol><li><p>有一个登陆页面，需要写一个controller访问页面。</p></li><li><p>登陆页面有一提交表单的动作。需要在controller中处理。判断用户名密码是否正确。如果正确，向session中写入用户信息。<em>返回登陆成功。</em></p></li><li><p>拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面</p></li></ol><p><strong>测试：</strong></p><ol><li><p>编写一个登陆页面  login.jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;登录页面&lt;/h1&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/user/login&quot;</span>&gt;</span><br><span class="line">  用户名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">  密码：&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;pwd&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">   &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写一个Controller处理请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//跳转到登陆页面</span></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/jumplogin&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">jumpLogin</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//跳转到成功页面</span></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/jumpSuccess&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">jumpSuccess</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//登陆提交</span></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(HttpSession session, String username, String pwd)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">// 向session记录用户身份信息</span></span><br><span class="line">       System.out.println(<span class="string">&quot;接收前端===&quot;</span>+username);</span><br><span class="line">       session.setAttribute(<span class="string">&quot;user&quot;</span>, username);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//退出登陆</span></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;logout&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">logout</span><span class="params">(HttpSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">// session 过期</span></span><br><span class="line">       session.invalidate();</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写一个登陆成功的页面 success.jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;登录成功页面&lt;/h1&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line"></span><br><span class="line">$&#123;user&#125;</span><br><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/logout&quot;&gt;注销&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>在 index 页面上测试跳转！启动Tomcat 测试，未登录也可以进入主页！</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;</span><br><span class="line">   &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line"> &lt;/head&gt;</span><br><span class="line"> &lt;body&gt;</span><br><span class="line"> &lt;h1&gt;首页&lt;/h1&gt;</span><br><span class="line"> &lt;hr&gt;</span><br><span class="line">&lt;%--登录--%&gt;</span><br><span class="line"> &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/jumplogin&quot;&gt;登录&lt;/a&gt;</span><br><span class="line"> &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/jumpSuccess&quot;&gt;成功页面&lt;/a&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写用户登录拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">       <span class="comment">// 如果是登陆页面则放行</span></span><br><span class="line">       System.out.println(<span class="string">&quot;uri: &quot;</span> + request.getRequestURI());</span><br><span class="line">       <span class="keyword">if</span> (request.getRequestURI().contains(<span class="string">&quot;login&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       HttpSession session = request.getSession();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果用户已登陆也放行</span></span><br><span class="line">       <span class="keyword">if</span>(session.getAttribute(<span class="string">&quot;user&quot;</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 用户没有登陆跳转到登陆页面</span></span><br><span class="line">       request.getRequestDispatcher(<span class="string">&quot;/WEB-INF/jsp/login.jsp&quot;</span>).forward(request, response);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Springmvc的配置文件中注册拦截器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--关于拦截器的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;loginInterceptor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.interceptor.LoginInterceptor&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>再次重启Tomcat测试！</p></li></ol><p><strong>OK，测试登录拦截功能无误.</strong></p><h1 id="文件上传和下载"><a href="#文件上传和下载" class="headerlink" title="文件上传和下载"></a>文件上传和下载</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>文件上传是项目开发中最常见的功能之一 ,springMVC 可以很好的支持文件上传，但是SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver。</p><p>前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器；</p><p><strong>对表单中的 enctype 属性做个详细的说明：</strong></p><ul><li>application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式。</li><li>multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码。</li><li>text/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一旦设置了enctype为multipart/form-data，浏览器即会采用二进制流的方式来处理表单数据，而对于文件上传的处理则涉及在服务器端解析原始的HTTP响应。在2003年，Apache Software Foundation发布了开源的Commons FileUpload组件，其很快成为Servlet/JSP程序员上传文件的最佳选择。</p><ul><li>Servlet3.0规范已经提供方法来处理文件上传，但这种上传需要在Servlet中完成。</li><li>而Spring MVC则提供了更简单的封装。</li><li>Spring MVC为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver实现的。</li><li>Spring MVC使用Apache Commons FileUpload技术实现了一个MultipartResolver实现类：</li><li>CommonsMultipartResolver。因此，SpringMVC的文件上传还需要依赖Apache Commons FileUpload的组件。</li></ul><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><ol><li><p>导入文件上传的jar包，commons-fileupload ， Maven会自动帮我们导入他的依赖包 commons-io包；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--文件上传--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--servlet-api导入高版本的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置bean：multipartResolver<br>【<strong>注意！！！这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！在这里栽过坑,教训！</strong>】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--文件上传配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10485760&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxInMemorySize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;40960&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CommonsMultipartFile 的 常用方法：</p><ul><li><strong>String getOriginalFilename()：获取上传文件的原名</strong></li><li><strong>InputStream getInputStream()：获取文件流</strong></li><li><strong>void transferTo(File dest)：将上传文件保存到一个目录文件中</strong></li></ul><p> 我们去实际测试一下</p></li><li><p>编写前端页面</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;/upload&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line"> &lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;file&quot;</span>/&gt;</span><br><span class="line"> &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;upload&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>Controller</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.commons.CommonsMultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileController</span> </span>&#123;</span><br><span class="line">   <span class="comment">//@RequestParam(&quot;file&quot;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象</span></span><br><span class="line">   <span class="comment">//批量上传CommonsMultipartFile则为数组即可</span></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/upload&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">fileUpload</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> CommonsMultipartFile file , HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取文件名 : file.getOriginalFilename();</span></span><br><span class="line">       String uploadFileName = file.getOriginalFilename();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//如果文件名为空，直接回到首页！</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(uploadFileName))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;上传文件名 : &quot;</span>+uploadFileName);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//上传路径保存设置</span></span><br><span class="line">       String path = request.getServletContext().getRealPath(<span class="string">&quot;/upload&quot;</span>);</span><br><span class="line">       <span class="comment">//如果路径不存在，创建一个</span></span><br><span class="line">       File realPath = <span class="keyword">new</span> File(path);</span><br><span class="line">       <span class="keyword">if</span> (!realPath.exists())&#123;</span><br><span class="line">           realPath.mkdir();</span><br><span class="line">      &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;上传文件保存地址：&quot;</span>+realPath);</span><br><span class="line"></span><br><span class="line">       InputStream is = file.getInputStream(); <span class="comment">//文件输入流</span></span><br><span class="line">       OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(realPath,uploadFileName)); <span class="comment">//文件输出流</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//读取写出</span></span><br><span class="line">       <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">       <span class="keyword">while</span> ((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">           os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">           os.flush();</span><br><span class="line">      &#125;</span><br><span class="line">       os.close();</span><br><span class="line">       is.close();</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试上传文件，OK！</p></li></ol><p><strong>采用file.Transto 来保存上传的文件</strong></p><ol><li><p>编写Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 采用file.Transto 来保存上传的文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/upload2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String  <span class="title">fileUpload2</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> CommonsMultipartFile file, HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//上传路径保存设置</span></span><br><span class="line">   String path = request.getServletContext().getRealPath(<span class="string">&quot;/upload&quot;</span>);</span><br><span class="line">   File realPath = <span class="keyword">new</span> File(path);</span><br><span class="line">   <span class="keyword">if</span> (!realPath.exists())&#123;</span><br><span class="line">       realPath.mkdir();</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">//上传文件地址</span></span><br><span class="line">   System.out.println(<span class="string">&quot;上传文件保存地址：&quot;</span>+realPath);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//通过CommonsMultipartFile的方法直接写文件（注意这个时候）</span></span><br><span class="line">   file.transferTo(<span class="keyword">new</span> File(realPath +<span class="string">&quot;/&quot;</span>+ file.getOriginalFilename()));</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>前端表单提交地址修改</p></li><li><p>访问提交测试，OK！</p></li></ol><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><p><strong>文件下载步骤：</strong></p><ol><li><p>设置 response 响应头</p></li><li><p>读取文件 – InputStream</p></li><li><p>写出文件 – OutputStream</p></li><li><p>执行操作</p></li><li><p>关闭流 （先开后关）</p></li></ol><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/download&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">downloads</span><span class="params">(HttpServletResponse response ,HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">   <span class="comment">//要下载的图片地址</span></span><br><span class="line">   String  path = request.getServletContext().getRealPath(<span class="string">&quot;/upload&quot;</span>);</span><br><span class="line">   String  fileName = <span class="string">&quot;基础语法.jpg&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//1、设置response 响应头</span></span><br><span class="line">   response.reset(); <span class="comment">//设置页面不缓存,清空buffer</span></span><br><span class="line">   response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">//字符编码</span></span><br><span class="line">   response.setContentType(<span class="string">&quot;multipart/form-data&quot;</span>); <span class="comment">//二进制传输数据</span></span><br><span class="line">   <span class="comment">//设置响应头</span></span><br><span class="line">   response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,</span><br><span class="line">           <span class="string">&quot;attachment;fileName=&quot;</span>+URLEncoder.encode(fileName, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line">   File file = <span class="keyword">new</span> File(path,fileName);</span><br><span class="line">   <span class="comment">//2、 读取文件--输入流</span></span><br><span class="line">   InputStream input=<span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">   <span class="comment">//3、 写出文件--输出流</span></span><br><span class="line">   OutputStream out = response.getOutputStream();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">byte</span>[] buff =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">   <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">   <span class="comment">//4、执行 写出操作</span></span><br><span class="line">   <span class="keyword">while</span>((index= input.read(buff))!= -<span class="number">1</span>)&#123;</span><br><span class="line">       out.write(buff, <span class="number">0</span>, index);</span><br><span class="line">       out.flush();</span><br><span class="line">  &#125;</span><br><span class="line">   out.close();</span><br><span class="line">   input.close();</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/download&quot;</span>&gt;</span>点击下载<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试，文件下载OK，大家可以和我们之前学习的JavaWeb原生的方式对比一下，就可以知道这个便捷多了!</p><p>拦截器及文件操作在我们开发中十分重要，一定要学会使用！</p>]]></content>
    
    
    <summary type="html">Spring,Ajax,MVC,SSM,SPRING,拦截器,文件上传和下载</summary>
    
    
    
    
    <category term="SpringMVC" scheme="https://qwq3.top/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC03：整合SSM</title>
    <link href="https://qwq3.top/posts/3816.html"/>
    <id>https://qwq3.top/posts/3816.html</id>
    <published>2021-06-03T18:29:57.000Z</published>
    <updated>2021-11-18T04:02:22.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整合SSM"><a href="#整合SSM" class="headerlink" title="整合SSM"></a>整合SSM</h1><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><p>环境：</p><ul><li>IDEA</li><li>MySQL 5.7.19</li><li>Tomcat 9</li><li>Maven 3.6</li></ul><p> 要求：</p><ul><li>需要熟练掌握MySQL数据库，Spring，JavaWeb及MyBatis知识，简单的前端知识；</li></ul><h2 id="数据库环境"><a href="#数据库环境" class="headerlink" title="数据库环境"></a>数据库环境</h2><p>创建一个存放书籍数据的数据库表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `ssmbuild`;</span><br><span class="line"></span><br><span class="line">USE `ssmbuild`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `books`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `books` (</span><br><span class="line">`bookID` <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;书id&#x27;</span>,</span><br><span class="line">`bookName` <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;书名&#x27;</span>,</span><br><span class="line">`bookCounts` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;数量&#x27;</span>,</span><br><span class="line">`detail` <span class="type">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;描述&#x27;</span>,</span><br><span class="line">KEY `bookID` (`bookID`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span>  <span class="keyword">INTO</span> `books`(`bookID`,`bookName`,`bookCounts`,`detail`)<span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;Java&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;从入门到放弃&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;MySQL&#x27;</span>,<span class="number">10</span>,<span class="string">&#x27;从删库到跑路&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>,<span class="string">&#x27;Linux&#x27;</span>,<span class="number">5</span>,<span class="string">&#x27;从进门到进牢&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="基本环境搭建"><a href="#基本环境搭建" class="headerlink" title="基本环境搭建"></a>基本环境搭建</h2><ol><li><p>新建一Maven项目！ssmbuild ， 添加web的支持</p></li><li><p>导入相关的pom依赖！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--Junit--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--数据库驱动--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--Servlet - JSP --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--Mybatis--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--Spring--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Maven资源过滤设置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>建立基本结构和配置框架！</p><ul><li><p>com.kuang.pojo</p></li><li><p>com.kuang.dao</p></li><li><p>com.kuang.service</p></li><li><p>com.kuang.controller</p></li><li><p>mybatis-config.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">       <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="Mybatis层编写"><a href="#Mybatis层编写" class="headerlink" title="Mybatis层编写"></a>Mybatis层编写</h2><ol><li><p>数据库配置文件 <strong>database.properties</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/ssmbuild?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure></li><li><p>IDEA关联数据库</p></li><li><p>编写MyBatis的核心配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">       <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.kuang.pojo&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/kuang/dao/BookMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写数据库对应的实体类 com.kuang.pojo.Books<br>使用lombok插件！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Books</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> bookID;</span><br><span class="line">   <span class="keyword">private</span> String bookName;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> bookCounts;</span><br><span class="line">   <span class="keyword">private</span> String detail;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Dao层的 Mapper接口！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.kuang.pojo.Books;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//增加一个Book</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">addBook</span><span class="params">(Books book)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//根据id删除一个Book</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">deleteBookById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//更新Book</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">updateBook</span><span class="params">(Books books)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//根据id查询,返回一个Book</span></span><br><span class="line">   <span class="function">Books <span class="title">queryBookById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//查询全部Book,返回list集合</span></span><br><span class="line">   <span class="function">List&lt;Books&gt; <span class="title">queryAllBook</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写接口对应的 Mapper.xml 文件。需要导入MyBatis的包；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">       <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.kuang.dao.BookMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--增加一个Book--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addBook&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Books&quot;</span>&gt;</span></span><br><span class="line">      insert into ssmbuild.books(bookName,bookCounts,detail)</span><br><span class="line">      values (#&#123;bookName&#125;, #&#123;bookCounts&#125;, #&#123;detail&#125;)</span><br><span class="line">   <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--根据id删除一个Book--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteBookById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">      delete from ssmbuild.books where bookID=#&#123;bookID&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--更新Book--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateBook&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Books&quot;</span>&gt;</span></span><br><span class="line">      update ssmbuild.books</span><br><span class="line">      set bookName = #&#123;bookName&#125;,bookCounts = #&#123;bookCounts&#125;,detail = #&#123;detail&#125;</span><br><span class="line">      where bookID = #&#123;bookID&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--根据id查询,返回一个Book--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBookById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Books&quot;</span>&gt;</span></span><br><span class="line">      select * from ssmbuild.books</span><br><span class="line">      where bookID = #&#123;bookID&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--查询全部Book--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryAllBook&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Books&quot;</span>&gt;</span></span><br><span class="line">      SELECT * from ssmbuild.books</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写Service层的接口和实现类</p></li></ol><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.kuang.pojo.Books;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BookService:底下需要去实现,调用dao层</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">   <span class="comment">//增加一个Book</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">addBook</span><span class="params">(Books book)</span></span>;</span><br><span class="line">   <span class="comment">//根据id删除一个Book</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">deleteBookById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">   <span class="comment">//更新Book</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">updateBook</span><span class="params">(Books books)</span></span>;</span><br><span class="line">   <span class="comment">//根据id查询,返回一个Book</span></span><br><span class="line">   <span class="function">Books <span class="title">queryBookById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">   <span class="comment">//查询全部Book,返回list集合</span></span><br><span class="line">   <span class="function">List&lt;Books&gt; <span class="title">queryAllBook</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.kuang.dao.BookMapper;</span><br><span class="line"><span class="keyword">import</span> com.kuang.pojo.Books;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//调用dao层的操作，设置一个set接口，方便Spring管理</span></span><br><span class="line">   <span class="keyword">private</span> BookMapper bookMapper;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBookMapper</span><span class="params">(BookMapper bookMapper)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.bookMapper = bookMapper;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addBook</span><span class="params">(Books book)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> bookMapper.addBook(book);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteBookById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> bookMapper.deleteBookById(id);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateBook</span><span class="params">(Books books)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> bookMapper.updateBook(books);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Books <span class="title">queryBookById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> bookMapper.queryBookById(id);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Books&gt; <span class="title">queryAllBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> bookMapper.queryAllBook();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>OK，到此，底层需求操作编写完毕！</strong></p><h2 id="Spring层"><a href="#Spring层" class="headerlink" title="Spring层"></a>Spring层</h2><ol><li><p>配置<strong>Spring整合MyBatis</strong>，我们这里数据源使用c3p0连接池；</p></li><li><p>我们去编写Spring整合Mybatis的相关的配置文件；spring-dao.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 配置整合mybatis --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 1.关联数据库文件 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:database.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 2.数据库连接池 --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--数据库连接池</span></span><br><span class="line"><span class="comment">       dbcp 半自动化操作 不能自动连接</span></span><br><span class="line"><span class="comment">       c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面）</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置连接池属性 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!-- c3p0连接池的私有属性 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;minPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 关闭连接后不自动commit --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;autoCommitOnClose&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 获取连接超时时间 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;checkoutTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 当获取连接失败重试次数 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;acquireRetryAttempts&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 3.配置SqlSessionFactory对象 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 注入数据库连接池 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 注入sqlSessionFactory --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 给出需要扫描Dao接口包 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.kuang.dao&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Spring整合service层</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 扫描service相关的bean --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kuang.service&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--BookServiceImpl注入到IOC容器中--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;BookServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.service.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookMapper&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookMapper&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 注入数据库连接池 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>Spring层搞定！再次理解一下，Spring就是一个大杂烩，一个容器！对吧！</p><h2 id="SpringMVC层"><a href="#SpringMVC层" class="headerlink" title="SpringMVC层"></a>SpringMVC层</h2><ol><li><p><strong>web.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--DispatcherServlet--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--encodingFilter--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span></span><br><span class="line">          org.springframework.web.filter.CharacterEncodingFilter</span><br><span class="line">       <span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">&lt;!--Session过期时间--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>15<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>spring-mvc.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">   https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 配置SpringMVC --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 1.开启SpringMVC注解驱动 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 2.静态资源默认servlet配置--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;viewClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 4.扫描web相关的bean --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kuang.controller&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Spring配置整合文件，applicationContext.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;spring-dao.xml&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;spring-service.xml&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;spring-mvc.xml&quot;</span>/&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>配置文件，暂时结束！</strong></p><h2 id="Controller-和-视图层编写"><a href="#Controller-和-视图层编写" class="headerlink" title="Controller 和 视图层编写"></a><strong>Controller 和 视图层编写</strong></h2><ol><li><p>BookController 类编写 ， 方法一：查询全部书籍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/book&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="meta">@Qualifier(&quot;BookServiceImpl&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> BookService bookService;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/allBook&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">       List&lt;Books&gt; list = bookService.queryAllBook();</span><br><span class="line">       model.addAttribute(<span class="string">&quot;list&quot;</span>, list);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;allBook&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写首页 <strong>index.jsp</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">   &lt;style type=<span class="string">&quot;text/css&quot;</span>&gt;</span><br><span class="line">       a &#123;</span><br><span class="line">           text-decoration: none;</span><br><span class="line">           color: black;</span><br><span class="line">           font-size: 18px;</span><br><span class="line">      &#125;</span><br><span class="line">       h3 &#123;</span><br><span class="line">           width: 180px;</span><br><span class="line">           height: 38px;</span><br><span class="line">           margin: 100px auto;</span><br><span class="line">           text-align: center;</span><br><span class="line">           line-height: 38px;</span><br><span class="line">           background: deepskyblue;</span><br><span class="line">           border-radius: 4px;</span><br><span class="line">      &#125;</span><br><span class="line">   &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;</span><br><span class="line">   &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/allBook&quot;&gt;点击进入列表页&lt;/a&gt;</span><br><span class="line">&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>书籍列表页面 <strong>allbook.jsp</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;书籍列表&lt;/title&gt;</span><br><span class="line">   &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">   &lt;!-- 引入 Bootstrap --&gt;</span><br><span class="line">   &lt;link href=<span class="string">&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">   &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;row clearfix&quot;</span>&gt;</span><br><span class="line">       &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;col-md-12 column&quot;</span>&gt;</span><br><span class="line">           &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;page-header&quot;</span>&gt;</span><br><span class="line">               &lt;h1&gt;</span><br><span class="line">                   &lt;small&gt;书籍列表 —— 显示所有书籍&lt;/small&gt;</span><br><span class="line">               &lt;/h1&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">   &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;row&quot;</span>&gt;</span><br><span class="line">       &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;col-md-4 column&quot;</span>&gt;</span><br><span class="line">           &lt;a class=&quot;btn btn-primary&quot; href=&quot;$&#123;pageContext.request.contextPath&#125;/book/toAddBook&quot;&gt;新增&lt;/a&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">   &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;row clearfix&quot;</span>&gt;</span><br><span class="line">       &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;col-md-12 column&quot;</span>&gt;</span><br><span class="line">           &lt;table <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;table table-hover table-striped&quot;</span>&gt;</span><br><span class="line">               &lt;thead&gt;</span><br><span class="line">               &lt;tr&gt;</span><br><span class="line">                   &lt;th&gt;书籍编号&lt;/th&gt;</span><br><span class="line">                   &lt;th&gt;书籍名字&lt;/th&gt;</span><br><span class="line">                   &lt;th&gt;书籍数量&lt;/th&gt;</span><br><span class="line">                   &lt;th&gt;书籍详情&lt;/th&gt;</span><br><span class="line">                   &lt;th&gt;操作&lt;/th&gt;</span><br><span class="line">               &lt;/tr&gt;</span><br><span class="line">               &lt;/thead&gt;</span><br><span class="line"></span><br><span class="line">               &lt;tbody&gt;</span><br><span class="line">               &lt;c:forEach <span class="keyword">var</span>=<span class="string">&quot;book&quot;</span> items=<span class="string">&quot;$&#123;requestScope.get(&#x27;list&#x27;)&#125;&quot;</span>&gt;</span><br><span class="line">                   &lt;tr&gt;</span><br><span class="line">                       &lt;td&gt;$&#123;book.getBookID()&#125;&lt;/td&gt;</span><br><span class="line">                       &lt;td&gt;$&#123;book.getBookName()&#125;&lt;/td&gt;</span><br><span class="line">                       &lt;td&gt;$&#123;book.getBookCounts()&#125;&lt;/td&gt;</span><br><span class="line">                       &lt;td&gt;$&#123;book.getDetail()&#125;&lt;/td&gt;</span><br><span class="line">                       &lt;td&gt;</span><br><span class="line">                           &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/toUpdateBook?id=$&#123;book.getBookID()&#125;&quot;&gt;更改&lt;/a&gt; |</span><br><span class="line">                           &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/del/$&#123;book.getBookID()&#125;&quot;&gt;删除&lt;/a&gt;</span><br><span class="line">                       &lt;/td&gt;</span><br><span class="line">                   &lt;/tr&gt;</span><br><span class="line">               &lt;/c:forEach&gt;</span><br><span class="line">               &lt;/tbody&gt;</span><br><span class="line">           &lt;/table&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>BookController 类编写 ， 方法二：添加书籍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toAddBook&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toAddPaper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;addBook&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/addBook&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addPaper</span><span class="params">(Books books)</span> </span>&#123;</span><br><span class="line">   System.out.println(books);</span><br><span class="line">   bookService.addBook(books);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;redirect:/book/allBook&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加书籍页面：<strong>addBook.jsp</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;新增书籍&lt;/title&gt;</span><br><span class="line">   &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">   &lt;!-- 引入 Bootstrap --&gt;</span><br><span class="line">   &lt;link href=<span class="string">&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">   &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;row clearfix&quot;</span>&gt;</span><br><span class="line">       &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;col-md-12 column&quot;</span>&gt;</span><br><span class="line">           &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;page-header&quot;</span>&gt;</span><br><span class="line">               &lt;h1&gt;</span><br><span class="line">                   &lt;small&gt;新增书籍&lt;/small&gt;</span><br><span class="line">               &lt;/h1&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">   &lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/book/addBook&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">      书籍名称：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;bookName&quot;</span>&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">      书籍数量：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;bookCounts&quot;</span>&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">      书籍详情：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;detail&quot;</span>&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</span><br><span class="line">       &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;添加&quot;</span>&gt;</span><br><span class="line">   &lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>BookController 类编写 ， 方法三：修改书籍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/toUpdateBook&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpdateBook</span><span class="params">(Model model, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">   Books books = bookService.queryBookById(id);</span><br><span class="line">   System.out.println(books);</span><br><span class="line">   model.addAttribute(<span class="string">&quot;book&quot;</span>,books );</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;updateBook&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/updateBook&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">updateBook</span><span class="params">(Model model, Books book)</span> </span>&#123;</span><br><span class="line">   System.out.println(book);</span><br><span class="line">   bookService.updateBook(book);</span><br><span class="line">   Books books = bookService.queryBookById(book.getBookID());</span><br><span class="line">   model.addAttribute(<span class="string">&quot;books&quot;</span>, books);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;redirect:/book/allBook&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改书籍页面  <strong>updateBook.jsp</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;修改信息&lt;/title&gt;</span><br><span class="line">   &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">   &lt;!-- 引入 Bootstrap --&gt;</span><br><span class="line">   &lt;link href=<span class="string">&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">   &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;row clearfix&quot;</span>&gt;</span><br><span class="line">       &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;col-md-12 column&quot;</span>&gt;</span><br><span class="line">           &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;page-header&quot;</span>&gt;</span><br><span class="line">               &lt;h1&gt;</span><br><span class="line">                   &lt;small&gt;修改信息&lt;/small&gt;</span><br><span class="line">               &lt;/h1&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">   &lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/book/updateBook&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">       &lt;input type=<span class="string">&quot;hidden&quot;</span> name=<span class="string">&quot;bookID&quot;</span> value=<span class="string">&quot;$&#123;book.getBookID()&#125;&quot;</span>/&gt;</span><br><span class="line">      书籍名称：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;bookName&quot;</span> value=<span class="string">&quot;$&#123;book.getBookName()&#125;&quot;</span>/&gt;</span><br><span class="line">      书籍数量：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;bookCounts&quot;</span> value=<span class="string">&quot;$&#123;book.getBookCounts()&#125;&quot;</span>/&gt;</span><br><span class="line">      书籍详情：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;detail&quot;</span> value=<span class="string">&quot;$&#123;book.getDetail() &#125;&quot;</span>/&gt;</span><br><span class="line">       &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>/&gt;</span><br><span class="line">   &lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>BookController 类编写 ， 方法四：删除书籍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/del/&#123;bookId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deleteBook</span><span class="params">(<span class="meta">@PathVariable(&quot;bookId&quot;)</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">   bookService.deleteBookById(id);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;redirect:/book/allBook&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>配置Tomcat，进行运行！</strong></p><p>到目前为止，这个SSM项目整合已经完全的OK了，可以直接运行进行测试！这个练习十分的重要，大家需要保证，不看任何东西，自己也可以完整的实现出来！</p><p><strong>项目结构图</strong> </p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterChen520/Drawingbed/img/20210604172016.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterChen520/Drawingbed/img/20210604172024.png"></p><h2 id="小结及展望"><a href="#小结及展望" class="headerlink" title="小结及展望"></a>小结及展望</h2><p>第一个SSM整合案例，一定要烂熟于心！</p><p>SSM框架的重要程度是不言而喻的，学到这里，大家已经可以进行基本网站的单独开发。但是这只是增删改查的基本操作。可以说学到这里，大家才算是真正的步入了后台开发的门。也就是能找一个后台相关工作的底线。</p><p>或许很多人，工作就做这些事情，但是对于个人的提高来说，还远远不够！</p><p>我们后面还要学习一些 SpringMVC 的知识！</p><ul><li>Ajax  和  Json</li><li>文件上传和下载</li><li>拦截器</li></ul><p>前路漫漫，认真坚持最重要！</p><h1 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h1><h2 id="什么是JSON？"><a href="#什么是JSON？" class="headerlink" title="什么是JSON？"></a>什么是JSON？</h2><ul><li>JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。</li><li>采用完全独立于编程语言的<strong>文本格式</strong>来存储和表示数据。</li><li>简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。</li><li>易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</li></ul><p>在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式：</p><ul><li>对象表示为键值对，数据由逗号分隔</li><li>花括号保存对象</li><li>方括号保存数组</li></ul><p><strong>JSON 键值对</strong>是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;: &quot;QinJiang&quot;&#125;</span><br><span class="line">&#123;&quot;age&quot;: &quot;3&quot;&#125;</span><br><span class="line">&#123;&quot;sex&quot;: &quot;男&quot;&#125;</span><br></pre></td></tr></table></figure><p>很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解：</p><p>JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;a: &#39;Hello&#39;, b: &#39;World&#39;&#125;; &#x2F;&#x2F;这是一个对象，注意键名也是可以使用引号包裹的</span><br><span class="line">var json &#x3D; &#39;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#39;; &#x2F;&#x2F;这是一个 JSON 字符串，本质是一个字符串</span><br></pre></td></tr></table></figure><h2 id="JSON-和-JavaScript-对象互转"><a href="#JSON-和-JavaScript-对象互转" class="headerlink" title="JSON 和 JavaScript 对象互转"></a><strong>JSON 和 JavaScript 对象互转</strong></h2><p>要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;</span>);</span><br><span class="line"><span class="comment">//结果是 &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="built_in">JSON</span>.stringify(&#123;<span class="attr">a</span>: <span class="string">&#x27;Hello&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;World&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">//结果是 &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>代码测试</strong></p><ol><li><p>新建一个module ，springmvc-05-json ， 添加web的支持</p></li><li><p>在web目录下新建一个 json-1.html ， 编写测试内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>JSON_秦疆<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="comment">//编写一个js的对象</span></span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> user = &#123;</span></span><br><span class="line"><span class="javascript">       name:<span class="string">&quot;秦疆&quot;</span>,</span></span><br><span class="line">       age:3,</span><br><span class="line"><span class="javascript">       sex:<span class="string">&quot;男&quot;</span></span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="javascript">   <span class="comment">//将js对象转换成json字符串</span></span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> str = <span class="built_in">JSON</span>.stringify(user);</span></span><br><span class="line"><span class="javascript">   <span class="built_in">console</span>.log(str);</span></span><br><span class="line">   </span><br><span class="line"><span class="javascript">   <span class="comment">//将json字符串转换为js对象</span></span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> user2 = <span class="built_in">JSON</span>.parse(str);</span></span><br><span class="line"><span class="javascript">   <span class="built_in">console</span>.log(user2.age,user2.name,user2.sex);</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在IDEA中使用浏览器打开，查看控制台输出！</p></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterChen520/Drawingbed/img/20210604172249.png"></p><h2 id="Controller返回JSON数据"><a href="#Controller返回JSON数据" class="headerlink" title="Controller返回JSON数据"></a>Controller返回JSON数据</h2><p>Jackson应该是目前比较好的json解析工具了</p><p>当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。</p><p>我们这里使用Jackson，使用它需要导入它的jar包；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置SpringMVC需要的配置</p><p>web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--1.注册servlet--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 启动顺序，数字越小，启动越早 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--所有请求都会被springmvc拦截 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>springmvc-servlet.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">       https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kuang.controller&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们随便编写一个User的实体类，然后我们去编写我们的测试Controller；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要导入lombok</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="keyword">private</span> String sex;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们需要两个新东西，一个是@ResponseBody，一个是ObjectMapper对象，我们看下具体的用法</p><p>编写一个Controller；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/json1&quot;)</span></span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">json1</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">       <span class="comment">//创建一个jackson的对象映射器，用来解析数据</span></span><br><span class="line">       ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">       <span class="comment">//创建一个对象</span></span><br><span class="line">       User user = <span class="keyword">new</span> User(<span class="string">&quot;秦疆1号&quot;</span>, <span class="number">3</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">       <span class="comment">//将我们的对象解析成为json格式</span></span><br><span class="line">       String str = mapper.writeValueAsString(user);</span><br><span class="line">       <span class="comment">//由于@ResponseBody注解，这里会将str转成json格式返回；十分方便</span></span><br><span class="line">       <span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置Tomcat ， 启动测试一下！</p><p><a href="http://localhost:8080/json1">http://localhost:8080/json1</a></p><p><img src= "/img/loading.gif" data-lazy-src="image/image-20210604172342628.png"></p><p>发现出现了乱码问题，我们需要设置一下他的编码格式为utf-8，以及它返回的类型；</p><p>通过@RequestMaping的produces属性来实现，修改下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//produces:指定响应体返回类型和编码</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;)</span></span><br></pre></td></tr></table></figure><p>再次测试， <a href="http://localhost:8080/json1">http://localhost:8080/json1</a> ， 乱码问题OK！</p><p><img src= "/img/loading.gif" data-lazy-src="image/image-20210604172413314.png"></p><p>【注意：使用json记得处理乱码问题】</p><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p><strong>乱码统一解决</strong></p><p>上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！</p><p>我们可以在springmvc的配置文件上添加一段消息StringHttpMessageConverter转换配置！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;objectMapper&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;failOnEmptyBeans&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>返回json字符串统一解决</strong></p><p>在类上直接使用 <strong>@RestController</strong> ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//produces:指定响应体返回类型和编码</span></span><br><span class="line">   <span class="meta">@RequestMapping(value = &quot;/json1&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">json1</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">       <span class="comment">//创建一个jackson的对象映射器，用来解析数据</span></span><br><span class="line">       ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">       <span class="comment">//创建一个对象</span></span><br><span class="line">       User user = <span class="keyword">new</span> User(<span class="string">&quot;秦疆1号&quot;</span>, <span class="number">3</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">       <span class="comment">//将我们的对象解析成为json格式</span></span><br><span class="line">       String str = mapper.writeValueAsString(user);</span><br><span class="line">       <span class="comment">//由于@ResponseBody注解，这里会将str转成json格式返回；十分方便</span></span><br><span class="line">       <span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动tomcat测试，结果都正常输出！</p><h2 id="测试集合输出"><a href="#测试集合输出" class="headerlink" title="测试集合输出"></a>测试集合输出</h2><p>增加一个新的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/json2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">json2</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建一个jackson的对象映射器，用来解析数据</span></span><br><span class="line">   ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">   <span class="comment">//创建一个对象</span></span><br><span class="line">   User user1 = <span class="keyword">new</span> User(<span class="string">&quot;秦疆1号&quot;</span>, <span class="number">3</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">   User user2 = <span class="keyword">new</span> User(<span class="string">&quot;秦疆2号&quot;</span>, <span class="number">3</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">   User user3 = <span class="keyword">new</span> User(<span class="string">&quot;秦疆3号&quot;</span>, <span class="number">3</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">   User user4 = <span class="keyword">new</span> User(<span class="string">&quot;秦疆4号&quot;</span>, <span class="number">3</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">   List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">   list.add(user1);</span><br><span class="line">   list.add(user2);</span><br><span class="line">   list.add(user3);</span><br><span class="line">   list.add(user4);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//将我们的对象解析成为json格式</span></span><br><span class="line">   String str = mapper.writeValueAsString(list);</span><br><span class="line">   <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果 : 十分完美，没有任何问题！</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterChen520/Drawingbed/img/20210604172524.png"></p><h2 id="输出时间对象"><a href="#输出时间对象" class="headerlink" title="输出时间对象"></a>输出时间对象</h2><p>增加一个新的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/json3&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">json3</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line"></span><br><span class="line">   ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建时间一个对象，java.util.Date</span></span><br><span class="line">   Date date = <span class="keyword">new</span> Date();</span><br><span class="line">   <span class="comment">//将我们的对象解析成为json格式</span></span><br><span class="line">   String str = mapper.writeValueAsString(date);</span><br><span class="line">   <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果 :<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterChen520/Drawingbed/img/20210604172557.png"></p><ul><li>默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！</li><li>Jackson 默认是会把时间转成timestamps形式</li></ul><p><strong>解决方案：取消timestamps形式 ， 自定义时间格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/json4&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">json4</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line"></span><br><span class="line">   ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//不使用时间戳的方式</span></span><br><span class="line">   mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, <span class="keyword">false</span>);</span><br><span class="line">   <span class="comment">//自定义日期格式对象</span></span><br><span class="line">   SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">   <span class="comment">//指定日期格式</span></span><br><span class="line">   mapper.setDateFormat(sdf);</span><br><span class="line"></span><br><span class="line">   Date date = <span class="keyword">new</span> Date();</span><br><span class="line">   String str = mapper.writeValueAsString(date);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果 : 成功的输出了时间！</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterChen520/Drawingbed/img/20210604172625.png"></p><h2 id="抽取为工具类"><a href="#抽取为工具类" class="headerlink" title="抽取为工具类"></a>抽取为工具类</h2><p><strong>如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中；我们去编写下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.SerializationFeature;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtils</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getJson</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> getJson(object,<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getJson</span><span class="params">(Object object,String dateFormat)</span> </span>&#123;</span><br><span class="line">       ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">       <span class="comment">//不使用时间差的方式</span></span><br><span class="line">       mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, <span class="keyword">false</span>);</span><br><span class="line">       <span class="comment">//自定义日期格式对象</span></span><br><span class="line">       SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(dateFormat);</span><br><span class="line">       <span class="comment">//指定日期格式</span></span><br><span class="line">       mapper.setDateFormat(sdf);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> mapper.writeValueAsString(object);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用工具类，代码就更加简洁了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/json5&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">json5</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">   Date date = <span class="keyword">new</span> Date();</span><br><span class="line">   String json = JsonUtils.getJson(date);</span><br><span class="line">   <span class="keyword">return</span> json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大功告成！完美！</p><h2 id="FastJson"><a href="#FastJson" class="headerlink" title="FastJson"></a>FastJson</h2><p>fastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的。</p><p>fastjson 的 pom依赖！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.60<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>fastjson 三个主要的类：</p><p><strong>JSONObject  代表 json 对象</strong> </p><ul><li>JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。</li><li>JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。</li></ul><p><strong>JSONArray  代表 json 对象数组</strong></p><ul><li>内部是有List接口中的方法来完成操作的。</li></ul><p><strong>JSON代表 JSONObject和JSONArray的转化</strong></p><ul><li>JSON类源码分析与使用</li><li>仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化。</li></ul><p><strong>代码测试，我们新建一个FastJsonDemo 类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.kuang.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastJsonDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//创建一个对象</span></span><br><span class="line">       User user1 = <span class="keyword">new</span> User(<span class="string">&quot;秦疆1号&quot;</span>, <span class="number">3</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">       User user2 = <span class="keyword">new</span> User(<span class="string">&quot;秦疆2号&quot;</span>, <span class="number">3</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">       User user3 = <span class="keyword">new</span> User(<span class="string">&quot;秦疆3号&quot;</span>, <span class="number">3</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">       User user4 = <span class="keyword">new</span> User(<span class="string">&quot;秦疆4号&quot;</span>, <span class="number">3</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">       List&lt;User&gt; list = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">       list.add(user1);</span><br><span class="line">       list.add(user2);</span><br><span class="line">       list.add(user3);</span><br><span class="line">       list.add(user4);</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;*******Java对象 转 JSON字符串*******&quot;</span>);</span><br><span class="line">       String str1 = JSON.toJSONString(list);</span><br><span class="line">       System.out.println(<span class="string">&quot;JSON.toJSONString(list)==&gt;&quot;</span>+str1);</span><br><span class="line">       String str2 = JSON.toJSONString(user1);</span><br><span class="line">       System.out.println(<span class="string">&quot;JSON.toJSONString(user1)==&gt;&quot;</span>+str2);</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;\n****** JSON字符串 转 Java对象*******&quot;</span>);</span><br><span class="line">       User jp_user1=JSON.parseObject(str2,User.class);</span><br><span class="line">       System.out.println(<span class="string">&quot;JSON.parseObject(str2,User.class)==&gt;&quot;</span>+jp_user1);</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;\n****** Java对象 转 JSON对象 ******&quot;</span>);</span><br><span class="line">       JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2);</span><br><span class="line">       System.out.println(<span class="string">&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;</span>+jsonObject1.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">&quot;\n****** JSON对象 转 Java对象 ******&quot;</span>);</span><br><span class="line">       User to_java_user = JSON.toJavaObject(jsonObject1, User.class);</span><br><span class="line">       System.out.println(<span class="string">&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;</span>+to_java_user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种工具类，我们只需要掌握使用就好了，在使用的时候在根据具体的业务去找对应的实现。和以前的commons-io那种工具包一样，拿来用就好了！</p><p>Json在我们数据传输中十分重要，一定要学会使用！</p>]]></content>
    
    
    <summary type="html">Spring,整合SSM,MVC,SSM,SPRING,JSON</summary>
    
    
    
    
    <category term="SpringMVC" scheme="https://qwq3.top/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC02：RestFul和控制器</title>
    <link href="https://qwq3.top/posts/6c09.html"/>
    <id>https://qwq3.top/posts/6c09.html</id>
    <published>2021-06-02T08:24:57.000Z</published>
    <updated>2021-11-18T04:02:22.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="控制器Controller"><a href="#控制器Controller" class="headerlink" title="控制器Controller"></a>控制器Controller</h1><ul><li><p>控制器复杂提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现。</p></li><li><p>控制器负责解析用户的请求并将其转换为一个模型。</p></li><li><p>在Spring MVC中一个控制器类可以包含多个方法</p></li><li><p>在Spring MVC中，对于Controller的配置方式有很多种</p></li></ul><h1 id="实现Controller接口"><a href="#实现Controller接口" class="headerlink" title="实现Controller接口"></a>实现Controller接口</h1><p>Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现该接口的类获得控制器功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">   <span class="comment">//处理请求且返回一个模型与视图对象</span></span><br><span class="line">   <span class="function">ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest var1, HttpServletResponse var2)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试</strong></p><ol><li><p>新建一个Moudle，springmvc-04-controller 。将刚才的03 拷贝一份, 我们进行操作！</p><p>删掉HelloController</p><p>mvc的配置文件只留下 视图解析器！</p></li><li><p>编写一个Controller类，ControllerTest1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义控制器</span></span><br><span class="line"><span class="comment">//注意点：不要导错包，实现Controller接口，重写方法；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest1</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//返回一个模型视图对象</span></span><br><span class="line">       ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">       mv.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;Test1Controller&quot;</span>);</span><br><span class="line">       mv.setViewName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> mv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写完毕后，去Spring配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;/t1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.controller.ControllerTest1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写前端test.jsp，注意在WEB-INF/jsp目录下编写，对应我们的视图解析器</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;Kuangshen&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">$&#123;msg&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置Tomcat运行测试，我这里没有项目发布名配置的就是一个 / ，所以请求不用加项目名，OK！</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterChen520/Drawingbed/img/20210602204643.png" alt="image-20210602204633838"></p></li></ol><p><strong>说明：</strong></p><ul><li><p>实现接口Controller定义控制器是较老的办法</p></li><li><p>缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦；</p></li></ul><h1 id="使用注解-Controller"><a href="#使用注解-Controller" class="headerlink" title="使用注解@Controller"></a>使用注解@Controller</h1><ul><li><p>@Controller注解类型用于声明Spring类的实例是一个控制器（在讲IOC时还提到了另外3个注解）；</p></li><li><p>Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kuang.controller&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>增加一个ControllerTest2类，使用注解实现；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Controller注解的类会自动添加到Spring上下文中</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest2</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//映射访问路径</span></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/t2&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">       <span class="comment">//Spring MVC会自动实例化一个Model对象用于向视图中传值</span></span><br><span class="line">       model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;ControllerTest2&quot;</span>);</span><br><span class="line">       <span class="comment">//返回视图位置</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行tomcat测试</p></li><li><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterChen520/Drawingbed/img/20210602205026.png" alt="image-20210602205024571"></p></li></ul><p><strong>可以发现，我们的两个请求都可以指向一个视图，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系。</strong></p><p><code>注解方式是平时使用的最多的方式！</code></p><h1 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h1><p><strong>@RequestMapping</strong></p><ul><li><p>@RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p></li><li><p>为了测试结论更加准确，我们可以加上一个项目名测试 myweb</p></li><li><p>只注解在方法上面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/h1&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问路径：<a href="http://localhost:8080/">http://localhost:8080</a> / 项目名 / h1</p></li><li><p>同时注解类与方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/h1&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问路径：<a href="http://localhost:8080/">http://localhost:8080</a> / 项目名/ admin /h1  , 需要先指定类的路径再指定方法的路径；</p></li></ul><h1 id="RestFul-风格"><a href="#RestFul-风格" class="headerlink" title="RestFul 风格"></a>RestFul 风格</h1><p><strong>概念</strong></p><p>Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><p><strong>功能</strong></p><p>资源：互联网所有的事物都可以被抽象为资源</p><p>资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。</p><p>分别对应 添加、 删除、修改、查询。</p><p><strong>传统方式操作资源</strong>  ：通过不同的参数来实现不同的效果！方法单一，post 和 get</p><p>​    <a href="http://127.0.0.1/item/queryItem.action?id=1">http://127.0.0.1/item/queryItem.action?id=1</a> 查询,GET</p><p>​    <a href="http://127.0.0.1/item/saveItem.action">http://127.0.0.1/item/saveItem.action</a> 新增,POST</p><p>​    <a href="http://127.0.0.1/item/updateItem.action">http://127.0.0.1/item/updateItem.action</a> 更新,POST</p><p>​    <a href="http://127.0.0.1/item/deleteItem.action?id=1">http://127.0.0.1/item/deleteItem.action?id=1</a> 删除,GET或POST</p><p><strong>使用RESTful操作资源</strong> ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！</p><p>​    <a href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 查询,GET</p><p>​    <a href="http://127.0.0.1/item">http://127.0.0.1/item</a> 新增,POST</p><p>​    <a href="http://127.0.0.1/item">http://127.0.0.1/item</a> 更新,PUT</p><p>​    <a href="http://127.0.0.1/item/1">http://127.0.0.1/item/1</a> 删除,DELETE</p><p><strong>学习测试</strong></p><ol><li><p>在新建一个类 RestFulController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestFulController</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Spring MVC中可以使用  @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestFulController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//映射访问路径</span></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/commit/&#123;p1&#125;/&#123;p2&#125;&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> p1, <span class="meta">@PathVariable</span> <span class="keyword">int</span> p2, Model model)</span></span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> result = p1+p2;</span><br><span class="line">       <span class="comment">//Spring MVC会自动实例化一个Model对象用于向视图中传值</span></span><br><span class="line">       model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;结果：&quot;</span>+result);</span><br><span class="line">       <span class="comment">//返回视图位置</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们来测试请求查看下</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterChen520/Drawingbed/img/20210602204734.png"></p></li><li><p>思考：使用路径变量的好处？</p><ul><li><p>使路径变得更加简洁；</p></li><li><p>获得参数更加方便，框架会自动进行类型转换。</p></li><li><p>通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/commit/1/a，则路径与方法不匹配，而不会是参数转换失败。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterChen520/Drawingbed/img/20210602212354.png" alt="image-20210602212353507"></p></li></ul></li><li><p>我们来修改下对应的参数类型，再次测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射访问路径</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/commit/&#123;p1&#125;/&#123;p2&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> p1, <span class="meta">@PathVariable</span> String p2, Model model)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   String result = p1+p2;</span><br><span class="line">   <span class="comment">//Spring MVC会自动实例化一个Model对象用于向视图中传值</span></span><br><span class="line">   model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;结果：&quot;</span>+result);</span><br><span class="line">   <span class="comment">//返回视图位置</span></span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterChen520/Drawingbed/img/20210602212449.png" alt="image-20210602212448588"></p></li></ol><p><strong>使用method属性指定请求类型</strong></p><p>用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等</p><p>我们来测试一下：</p><ul><li><p>增加一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射访问路径,必须是POST请求</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/hello&quot;,method = &#123;RequestMethod.POST&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index2</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">   model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们使用浏览器地址栏进行访问默认是Get请求，会报错405：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterChen520/Drawingbed/img/20210602212516.png" alt="image-20210602212515666"></p></li><li><p>如果将POST修改为GET则正常了；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射访问路径,必须是Get请求</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/hello&quot;,method = &#123;RequestMethod.GET&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index2</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">   model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterChen520/Drawingbed/img/20210602212548.png" alt="image-20210602212547296"></p></li></ul><p><strong>小结：</strong></p><p>Spring MVC 的 @RequestMapping 注解能够处理 HTTP 请求的方法, 比如 GET, PUT, POST, DELETE 以及 PATCH。</p><p><strong>所有的地址栏请求默认都会是 HTTP GET 类型的。</strong></p><p>方法级别的注解变体有如下几个：组合注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping</span><br><span class="line">@PostMapping</span><br><span class="line">@PutMapping</span><br><span class="line">@DeleteMapping</span><br><span class="line">@PatchMapping</span><br></pre></td></tr></table></figure><p>@GetMapping 是一个组合注解，平时使用的会比较多！</p><p>它所扮演的是 @RequestMapping(method =RequestMethod.GET) 的一个快捷方式。</p><h1 id="扩展：小黄鸭调试法"><a href="#扩展：小黄鸭调试法" class="headerlink" title="扩展：小黄鸭调试法"></a>扩展：小黄鸭调试法</h1><p>场景一：<em>我们都有过向别人（甚至可能向完全不会编程的人）提问及解释编程问题的经历，但是很多时候就在我们解释的过程中自己却想到了问题的解决方案，然后对方却一脸茫然。</em></p><p>场景二：你的同行跑来问你一个问题，但是当他自己把问题说完，或说到一半的时候就想出答案走了，留下一脸茫然的你。</p><p>其实上面两种场景现象就是所谓的小黄鸭调试法（Rubber Duck Debuging），又称橡皮鸭调试法，它是我们软件工程中最常使用调试方法之一。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterChen520/Drawingbed/img/20210602212609.png" alt="image-20210602212607633"></p><p>此概念据说来自《程序员修炼之道》书中的一个故事，传说程序大师随身携带一只小黄鸭，在调试代码的时候会在桌上放上这只小黄鸭，然后详细地向鸭子解释每行代码，然后很快就将问题定位修复了。</p><p>下面我们准备研究下参数接受和结果跳转！</p><h1 id="结果跳转方式"><a href="#结果跳转方式" class="headerlink" title="结果跳转方式"></a>结果跳转方式</h1><h2 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h2><p>设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 .</p><p>页面 : {视图解析器前缀} + viewName +{视图解析器后缀}</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的controller类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest1</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//返回一个模型视图对象</span></span><br><span class="line">       ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">       mv.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;ControllerTest1&quot;</span>);</span><br><span class="line">       mv.setViewName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> mv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ServletAPI"><a href="#ServletAPI" class="headerlink" title="ServletAPI"></a>ServletAPI</h2><p>通过设置ServletAPI , 不需要视图解析器 .</p><p>1、通过HttpServletResponse进行输出</p><p>2、通过HttpServletResponse实现重定向</p><p>3、通过HttpServletResponse实现转发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultGo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/result/t1&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       rsp.getWriter().println(<span class="string">&quot;Hello,Spring BY servlet API&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/result/t2&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       rsp.sendRedirect(<span class="string">&quot;/index.jsp&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/result/t3&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">(HttpServletRequest req, HttpServletResponse rsp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//转发</span></span><br><span class="line">       req.setAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;/result/t3&quot;</span>);</span><br><span class="line">       req.getRequestDispatcher(<span class="string">&quot;/WEB-INF/jsp/test.jsp&quot;</span>).forward(req,rsp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p><strong>通过SpringMVC来实现转发和重定向 - 无需视图解析器；</strong></p><p>测试前，需要将视图解析器注释掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultSpringMVC</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/rsm/t1&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//转发</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/rsm/t2&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//转发二</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;forward:/index.jsp&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/rsm/t3&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//重定向</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过SpringMVC来实现转发和重定向 - 有视图解析器；</strong></p><p>重定向 , 不需要视图解析器 , 本质就是重新请求一个新地方嘛 , 所以注意路径问题.</p><p>可以重定向到另外一个请求实现 .</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultSpringMVC2</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/rsm2/t1&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//转发</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/rsm2/t2&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//重定向</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;redirect:/index.jsp&quot;</span>;</span><br><span class="line">       <span class="comment">//return &quot;redirect:hello.do&quot;; //hello.do为另一个请求/</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h2 id="处理提交数据"><a href="#处理提交数据" class="headerlink" title="处理提交数据"></a>处理提交数据</h2><p><strong>1、提交的域名称和处理方法的参数名一致</strong></p><p>提交数据 : <a href="http://localhost:8080/hello?name=kuangshen">http://localhost:8080/hello?name=kuangshen</a></p><p>处理方法 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台输出 : kuangshen</p><p><strong>2、提交的域名称和处理方法的参数名不一致</strong></p><p>提交数据 : <a href="http://localhost:8080/hello?username=kuangshen">http://localhost:8080/hello?username=kuangshen</a></p><p>处理方法 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@RequestParam(&quot;username&quot;) : username提交的域的名称 .</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name)</span></span>&#123;</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台输出 : kuangshen</p><p><strong>3、提交的是一个对象</strong></p><p>要求提交的表单域和对象的属性名一致  , 参数使用对象即可</p><p>1、实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">   <span class="comment">//构造</span></span><br><span class="line">   <span class="comment">//get/set</span></span><br><span class="line">   <span class="comment">//tostring()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、提交数据 : <a href="http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15">http://localhost:8080/mvc04/user?name=kuangshen&amp;id=1&amp;age=15</a></p><p>3、处理方法 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">user</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">   System.out.println(user);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台输出 : User { id=1, name=’kuangshen’, age=15 }</p><p>说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null。</p><h2 id="数据显示到前端"><a href="#数据显示到前端" class="headerlink" title="数据显示到前端"></a>数据显示到前端</h2><p><strong>第一种 : 通过ModelAndView</strong></p><p>我们前面一直都是如此 . 就不过多解释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerTest1</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//返回一个模型视图对象</span></span><br><span class="line">       ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">       mv.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;ControllerTest1&quot;</span>);</span><br><span class="line">       mv.setViewName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> mv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种 : 通过ModelMap</strong></p><p>ModelMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name, ModelMap model)</span></span>&#123;</span><br><span class="line">   <span class="comment">//封装要显示到视图中的数据</span></span><br><span class="line">   <span class="comment">//相当于req.setAttribute(&quot;name&quot;,name);</span></span><br><span class="line">   model.addAttribute(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三种 : 通过Model</strong></p><p>Model</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/ct2/hello&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name, Model model)</span></span>&#123;</span><br><span class="line">   <span class="comment">//封装要显示到视图中的数据</span></span><br><span class="line">   <span class="comment">//相当于req.setAttribute(&quot;name&quot;,name);</span></span><br><span class="line">   model.addAttribute(<span class="string">&quot;msg&quot;</span>,name);</span><br><span class="line">   System.out.println(name);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>就对于新手而言简单来说使用区别就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解；</span><br><span class="line"></span><br><span class="line">ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性；</span><br><span class="line"></span><br><span class="line">ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。</span><br></pre></td></tr></table></figure><p>当然更多的以后开发考虑的更多的是性能和优化，就不能单单仅限于此的了解。</p><p><strong>请使用80%的时间打好扎实的基础，剩下18%的时间研究框架，2%的时间去学点英文，框架的官方文档永远是最好的教程。</strong></p><h2 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h2><p>测试步骤：</p><p>1、我们可以在首页编写一个提交的表单</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/e/t&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、后台编写对应的处理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Encoding</span> </span>&#123;</span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/e/t&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(Model model,String name)</span></span>&#123;</span><br><span class="line">       model.addAttribute(<span class="string">&quot;msg&quot;</span>,name); <span class="comment">//获取表单提交的值</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>; <span class="comment">//跳转到test页面显示输入的值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、输入中文测试，发现乱码</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/WaterChen520/Drawingbed/img/20210604160756.png"></p><p>不得不说，乱码问题是在我们开发中十分常见的问题，也是让我们程序猿比较头大的问题！</p><p>以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 .</p><p>修改了xml文件需要重启服务器！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是我们发现 , 有些极端情况下.这个过滤器对get的支持不好 .</p><p>处理方法 :</p><p>1、修改tomcat配置文件 ：设置编码！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">URIEncoding</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>2、自定义过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 解决get和post请求 全部乱码的过滤器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEncodingFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">       <span class="comment">//处理response的字符编码</span></span><br><span class="line">       HttpServletResponse myResponse=(HttpServletResponse) response;</span><br><span class="line">       myResponse.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 转型为与协议相关对象</span></span><br><span class="line">       HttpServletRequest httpServletRequest = (HttpServletRequest) request;</span><br><span class="line">       <span class="comment">// 对request包装增强</span></span><br><span class="line">       HttpServletRequest myrequest = <span class="keyword">new</span> MyRequest(httpServletRequest);</span><br><span class="line">       chain.doFilter(myrequest, response);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义request对象，HttpServletRequest的包装类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRequest</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line">   <span class="comment">//是否编码的标记</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> hasEncode;</span><br><span class="line">   <span class="comment">//定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(request);<span class="comment">// super必须写</span></span><br><span class="line">       <span class="keyword">this</span>.request = request;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 对需要增强方法 进行覆盖</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Map <span class="title">getParameterMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 先获得请求方式</span></span><br><span class="line">       String method = request.getMethod();</span><br><span class="line">       <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">&quot;post&quot;</span>)) &#123;</span><br><span class="line">           <span class="comment">// post请求</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 处理post乱码</span></span><br><span class="line">               request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span> request.getParameterMap();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">&quot;get&quot;</span>)) &#123;</span><br><span class="line">           <span class="comment">// get请求</span></span><br><span class="line">           Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">           <span class="keyword">if</span> (!hasEncode) &#123; <span class="comment">// 确保get手动编码逻辑只运行一次</span></span><br><span class="line">               <span class="keyword">for</span> (String parameterName : parameterMap.keySet()) &#123;</span><br><span class="line">                   String[] values = parameterMap.get(parameterName);</span><br><span class="line">                   <span class="keyword">if</span> (values != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               <span class="comment">// 处理get乱码</span></span><br><span class="line">                               values[i] = <span class="keyword">new</span> String(values[i]</span><br><span class="line">                                      .getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                          &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                               e.printStackTrace();</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">               hasEncode = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">           <span class="keyword">return</span> parameterMap;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.getParameterMap();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//取一个值</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">       Map&lt;String, String[]&gt; parameterMap = getParameterMap();</span><br><span class="line">       String[] values = parameterMap.get(name);</span><br><span class="line">       <span class="keyword">if</span> (values == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">return</span> values[<span class="number">0</span>]; <span class="comment">// 取回参数的第一个值</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//取所有值</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line">       Map&lt;String, String[]&gt; parameterMap = getParameterMap();</span><br><span class="line">       String[] values = parameterMap.get(name);</span><br><span class="line">       <span class="keyword">return</span> values;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个也是我在网上找的一些大神写的，一般情况下，SpringMVC默认的乱码处理就已经能够很好的解决了！</p><p><strong>然后在web.xml中配置这个过滤器即可！</strong></p><p>乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！</p><p>有了这些知识，我们马上就可以进行SSM整合了！</p>]]></content>
    
    
    <summary type="html">Spring,RestFul和控制器,MVC,SSM,SPRING,控制器,RestFul, 结果跳转方式,数据处理及跳转</summary>
    
    
    
    
    <category term="SpringMVC" scheme="https://qwq3.top/tags/SpringMVC/"/>
    
  </entry>
  
</feed>
