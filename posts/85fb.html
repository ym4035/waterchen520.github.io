<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>TypeScript的基本使用 | Violet`Blog</title><meta name="keywords" content="VUE,vue,Vue,vue3,前端,学习,TypeScript"><meta name="author" content="Violet,2268025923@qq.com"><meta name="copyright" content="Violet"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TypeScript的基本使用"><meta property="og:type" content="article"><meta property="og:title" content="TypeScript的基本使用"><meta property="og:url" content="https://qwq3.top/posts/85fb.html"><meta property="og:site_name" content="Violet&#96;Blog"><meta property="og:description" content="TypeScript的基本使用"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191510330.jpg"><meta property="article:published_time" content="2021-11-07T12:48:59.000Z"><meta property="article:modified_time" content="2021-12-10T05:35:56.976Z"><meta property="article:author" content="Violet"><meta property="article:tag" content="TypeScript"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191510330.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://qwq3.top/posts/85fb"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//hexo-circle-of-friends-api-gray-eight.vercel.app"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="wQg9NEaZT7S17k67-8yTQ6t8Cl80Ox2_3_fhRsrILek"><meta name="msvalidate.01" content="6B596F49E73BA7596BE416B718D67F76"><meta name="baidu-site-verification" content="code-oLxYlsQOY7"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="#49b1f5"><link rel="apple-touch-icon" sizes="180x180" href="/images/pwaicons/128.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/pwaicons/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/pwaicons/16.png"><link rel="mask-icon" href="/images/pwaicons/128.png" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/waterchen520/asset@1.0/animate.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:230},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"mediumZoom",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#121212",position:"top-right"},source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-12-10 05:35:56"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=saveToLocal.get("global-font-size");void 0!==n&&document.documentElement.style.setProperty("--global-font-size",n+"px")})(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><meta name="google-site-verification" content="O3IfnYL5-UZO2tb5j7cvrQyGIQs5L48Iyv-QmAnGjFQ"><link rel="stylesheet" href="/css/badge.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_2508400_xe8j12uijki.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Violet`Blog" type="application/atom+xml"></head><body><a href="javascript:void(0);" rel="external nofollow noreferrer" onclick="preloader.endLoading()" title="施展咒语跳过动画！"><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><img class="load-image" src="https://cdn.jsdelivr.net/gh/WaterChen520/vuecdn/img/vue120210423234612.gif" alt=""></div></a><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/waterchen520/cdn@5.0/qiqi/img/23.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">54</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw fas fa-home faa-tada"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw fas fa-archive faa-tada"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/"><i class="fa-fw fas fa-music faa-tada"></i> <span>音乐馆</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/special/"><i class="fa-fw fas fa-rocket faa-tada"></i> <span>特效</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/fcircle/"><i class="fa-fw fab fa-artstation faa-tada"></i> <span>朋友圈</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw fas fa-envelope faa-tada"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw fas fa-link faa-tada"></i> <span>友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/hpptalk/"><i class="fa-fw fas fa-comment-dots faa-tada"></i> <span>闲言碎语</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/bangumis/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili1"></use></svg> <span>追番</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhifeiji"></use></svg> <span>关于</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191510330.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Violet`Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw fas fa-home faa-tada"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw fas fa-archive faa-tada"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/music/"><i class="fa-fw fas fa-music faa-tada"></i> <span>音乐馆</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/special/"><i class="fa-fw fas fa-rocket faa-tada"></i> <span>特效</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/fcircle/"><i class="fa-fw fab fa-artstation faa-tada"></i> <span>朋友圈</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw fas fa-envelope faa-tada"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/link/"><i class="fa-fw fas fa-link faa-tada"></i> <span>友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/hpptalk/"><i class="fa-fw fas fa-comment-dots faa-tada"></i> <span>闲言碎语</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/bangumis/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili1"></use></svg> <span>追番</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-zhifeiji"></use></svg> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">TypeScript的基本使用</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-07T12:48:59.000Z" title="发表于 2021-11-07 12:48:59">2021-11-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-10T05:35:56.976Z" title="更新于 2021-12-10 05:35:56">2021-12-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="TypeScript的基本使用"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/85fb.html#post-comment"><span id="twikoo-count"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p><strong>TypeScript</strong></p></blockquote><p><strong>JavaScript 一门优秀的语言</strong></p><p><strong>我始终相信：任何新技术的出现都是为了解决原有技术的某个痛点。</strong></p><p><strong>JavaScript 是一门优秀的编程语言吗？</strong></p><blockquote><p>每个人可能观点并不完全一致，但是从很多角度来看，JavaScript 是一门<code>非常优秀的编程语言</code>；</p><p>而且，可以说在很长一段时间内<code>这个语言不会被代替</code>，并且会在<code>更多的领域</code>被大家广泛使用；</p></blockquote><p><strong>著名的 Atwood 定律：</strong></p><ul><li>Stack Overflow 的创立者之一的 <strong>Jeff Atwood</strong> 在 2007 年提出了著名的 <strong>Atwood 定律</strong>。</li><li>any application that can be written in JavaScript, will eventually be written in JavaScript.</li><li>任何可以使用 JavaScript 来实现的应用都最终都会使用 JavaScript 实现</li></ul><p>其实我们已经看到了，这句话正在一步步被应验：</p><p><code>Web端</code>的开发我们一直都是使用 JavaScript；</p><p><code>移动端</code>开发可以借助于 ReactNative、Weex、Uniapp 等框架实现跨平台开发；</p><p><code>小程序端</code>的开发也是离不开 JavaScript；</p><p><code>桌面端</code>应用程序我们可以借助于 Electron 来开发；</p><p><code>服务器端</code>开发可以借助于 Node 环境使用 JavaScript 来开发。</p><h3 id="JavaScript-的痛点"><a href="#JavaScript-的痛点" class="headerlink" title="JavaScript 的痛点"></a>JavaScript 的痛点</h3><p>并且随着近几年前端领域的快速发展，让 JavaScript 迅速<code>被普及和受广大开发者的喜爱</code>，借助于<code>JavaScript本身的强大</code>，也让<code>使用JavaScript开发的人员越来越多</code>。</p><blockquote><p><strong>优秀的 JavaScript 没有缺点吗？</strong></p></blockquote><p>其实上由于各种历史因素，JavaScript 语言本身<code>存在很多的缺点</code>；</p><p>比如 ES5 以及之前的<code>使用的var关键字关于作用域</code>的问题；</p><p>比如最初 JavaScript 设计的<code>数组类型并不是连续的内存空间</code>；</p><p>比如直到今天<code>JavaScript也没有加入类型检测</code>这一机制；</p><h3 id="JavaScript-正在慢慢变好"><a href="#JavaScript-正在慢慢变好" class="headerlink" title="JavaScript 正在慢慢变好"></a>JavaScript 正在慢慢变好</h3><p>不可否认的是，JavaScript 正在慢慢变得越来越好，无论是从底层设计还是应用层面。</p><p>ES6、7、8 等的推出，每次都会让这门语言<code>更加现代、更加安全、更加方便</code>。</p><p>但是知道今天，JavaScript 在<code>类型检测上依然是毫无进展</code>（为什么类型检测如此重要，我后面会聊到）</p><h3 id="类型带来的问题"><a href="#类型带来的问题" class="headerlink" title="类型带来的问题"></a>类型带来的问题</h3><p>首先你需要知道，编程开发中我们有一个共识：<strong>错误出现的越早越好</strong></p><ul><li><p>能在<strong>写代码的时候</strong>发现错误，就不要在<strong>代码编译时</strong>再发现（IDE 的优势就是在代码编写过程中帮助我们发现错误）。</p></li><li><p>能在<strong>代码编译期间</strong>发现错误，就不要在<strong>代码运行期间</strong>再发现（类型检测就可以很好的帮助我们做到这一点）。</p></li><li><p>能在开发阶段发现错误，就不要在测试期间发现错误，能在测试期间发现错误，就不要在上线后发现错误。</p></li></ul><p>现在我们想探究的就是如何在 <strong>代码编译期间</strong> 发现代码的错误：</p><p>JavaScript 可以做到吗？不可以，我们来看下面这段经常可能出现的代码问题。</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191515526.png" alt="image-20211019151511796"></p><h3 id="类型错误"><a href="#类型错误" class="headerlink" title="类型错误"></a>类型错误</h3><p><strong>这是我们一个非常常见的错误：</strong></p><p>这个错误很大的原因就是因为 JavaScript 没有对我们<code>传入的参数进行任何的限制</code>，只能等到<code>运行期间才发现这个错误</code>；</p><p>并且当这个错误产生时，会影响后续代码的继续执行，也就是整个项目都因为<code>一个小小的错误而深入崩溃</code>；</p><p><strong>当然，你可能会想：我怎么可能犯这样低级的错误呢？</strong></p><p>当我们写像我们上面这样的简单的 demo 时，这样的错误很容易避免，并且当出现错误时，也很容易检查出来；</p><p>但是当我们开发一个<code>大型项目</code>时呢？你能保证自己<code>一定不会出现这样的问题</code>吗？而且如果我们是调用别人的类</p><p>库，又如何知道让我们传入的到底是什么样的参数呢？</p><blockquote><p>但是，如果我们可以给<code>JavaScript加上很多限制</code>，在开发中就可以很好的<code>避免这样的问题</code>了：</p></blockquote><p>比如我们的 getLength 函数中 str 是一个<code>必传的类型</code>，没有调用者没有传编译期间就会报错；</p><p>比如我们要求它的必须是一个<code>String类型</code>，传入其他类型就直接报错；</p><p>那么就可以知道很多的错误问题在<code>编译期间</code>就被发现，而不是等到运行时再去发现和修改；</p><h3 id="类型思维的缺失"><a href="#类型思维的缺失" class="headerlink" title="类型思维的缺失"></a>类型思维的缺失</h3><p>我们已经简单体会到没有类型检查带来的一些问题，JavaScript 因为从设计之初就没有考虑类型的约束问题，所以造成了前端开发人员关于<strong>类型思维的缺失</strong>：</p><ul><li><strong>前端开发人员</strong>通常不关心变量或者参数是什么类型的，如果在必须确定类型时，我们往往需要使用各种判断验证；</li><li>从其他方向转到前端的人员，也会因为没有类型约束，而总是担心自己的<code>代码不安全，不够健壮</code>；</li></ul><p>所以我们经常会说 JavaScript<strong>不适合开发大型项目</strong>，因为当项目一旦庞大起来，这种宽松的类型约束会带来非常多的安全隐患，多人员开发它们之间也没有<strong>良好的类型契约</strong></p><ul><li>比如当我们去实现一个核心类库时，如果没有类型约束，那么需要对别人传入的参数进行各种验证来保证我们代码的健壮性；</li><li>比如我们去调用别人的函数，对方没有对函数进行任何的注释，我们只能去看里面的逻辑来理解这个函数需要<code>传入什么参数，返回值是什么类型</code>；</li></ul><h3 id="JavaScript-添加类型约束"><a href="#JavaScript-添加类型约束" class="headerlink" title="JavaScript 添加类型约束"></a>JavaScript 添加类型约束</h3><p><strong>为了弥补 JavaScript 类型约束上的缺陷，增加类型约束，很多公司推出了自己的方案：</strong></p><ul><li>2014 年，Facebook 推出了<code>flow</code>来对 JavaScript 进行类型检查；</li><li>同年，Microsoft 微软也推出了<code>TypeScript1.0</code>版本；</li><li>他们都致力于为 JavaScript 提供类型检查；</li></ul><p>而现在，无疑<strong>TypeScript 已经完全胜出</strong>：</p><ul><li>Vue2.x 的时候采用的就是 flow 来做类型检查；</li><li>Vue3.x 已经全线转向 TypeScript，98.3%使用 TypeScript 进行了重构；</li><li>而 Angular 在很早期就使用 TypeScript 进行了项目重构并且需要使用 TypeScript 来进行开发；</li><li>而甚至 Facebook 公司一些自己的产品也在使用 TypeScript；</li></ul><p>学习 TypeScript 不仅仅可以为我们的代码增加类型约束，而且可以培养我们前端程序员具备类型思维。</p><h3 id="认识-TypeScript"><a href="#认识-TypeScript" class="headerlink" title="认识 TypeScript"></a>认识 TypeScript</h3><p>虽然我们已经知道 TypeScript 是干什么的了，也知道它解决了什么样的问题，但是我们还是需要全面的来认识一下 TypeScript 到底是什么？</p><p><strong>我们来看一下 TypeScript 在 GitHub 和官方上对自己的定义：</strong></p><ul><li>GitHub 说法：TypeScript is a superset of JavaScript that compiles to clean JavaScript output.</li><li>TypeScript 官网：TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.</li><li>翻译一下：TypeScript 是拥有类型的<code>JavaScript超级</code>，它可以编译成<code>普通、干净、完整的</code>JavaScript 代码。</li></ul><blockquote><p>怎么理解上面的话呢？</p></blockquote><ul><li>我们可以将 TypeScript 理解成<code>加强版的JavaScript</code>。</li><li>JavaScript 所拥有的特性，TypeScript 全部都是支持的，并且它紧随 ECMAScript 的标准，所以 ES6、ES7、ES8 等新语法标准，它都是支持的；</li><li>并且在语言层面上，不仅仅增加了类型约束，而且包括一些语法的扩展，比如枚举类型（Enum）、元组类型（Tuple）等；</li><li>TypeScript 在实现新特性的同时，总是保持和 ES 标准的同步甚至是领先；</li><li>并且 TypeScript 最终会被编译成 JavaScript 代码，所以你并不需要担心它的兼容性问题，在编译时也不需要借助于 Babel 这样的工具；</li></ul><p>所以，我们可以把 TypeScript 理解成更加强大的 JavaScript，不仅让 JavaScript 更加安全，而且给它带来了诸多好用的好用特性；</p><h4 id="TypeScript-的特点"><a href="#TypeScript-的特点" class="headerlink" title="TypeScript 的特点"></a>TypeScript 的特点</h4><p>官方对 TypeScript 有几段特点的描述，我觉得非常到位（虽然有些官方，了解一下），我们一起来分享一下：</p><p><strong>始于 JavaScript，归于 JavaScript</strong></p><ul><li>TypeScript 从今天数以百万计的 JavaScript 开发者所熟悉的语法和语义开始。使用现有的 JavaScript 代码，包括流行的 JavaScript 库，并从 JavaScript 代码中调用 TypeScript 代码；</li><li>TypeScript 可以编译出纯净、 简洁的 JavaScript 代码，并且可以运行在任何浏览器上、Node.js 环境中和任何支持 ECMAScript 3（或更高版本）的 JavaScript 引擎中；</li></ul><p><strong>TypeScript 是一个强大的工具，用于构建大型项目</strong></p><ul><li>类型允许 JavaScript 开发者在开发 JavaScript 应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构；</li><li>类型是可选的，类型推断让一些类型的注释使你的代码的静态验证有很大的不同。类型让你定义软件组件之间的接口和洞察现有 JavaScript 库的行为；</li></ul><p><strong>拥有先进的 JavaScript</strong></p><ul><li>TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件；</li><li>这些特性为高可信应用程序开发时是可用的，但是会被编译成简洁的 ECMAScript3（或更新版本）的 JavaScript；</li></ul><h4 id="众多项目采用-TypeScript"><a href="#众多项目采用-TypeScript" class="headerlink" title="众多项目采用 TypeScript"></a>众多项目采用 TypeScript</h4><p>正是因为有这些特性，TypeScript 目前已经在很多地方被应用：</p><ul><li>Angular 源码在很早就使用 TypeScript 来进行了重写，并且开发 Angular 也需要掌握 TypeScript；</li><li>Vue3 源码也采用了 TypeScript 进行重写，在前面阅读源码时我们看到大量 TypeScript 的语法；</li><li>包括目前已经变成最流行的编辑器 VSCode 也是使用 TypeScript 来完成的；</li><li>包括在 React 中已经使用的 ant-design 的 UI 库，也大量使用 TypeScript 来编写；</li><li>目前公司非常流行 Vue3+TypeScript、React+TypeScript 的开发模式；</li><li>包括小程序开发，也是支持 TypeScript 的；</li></ul><h3 id="TypeScript-的编译环境"><a href="#TypeScript-的编译环境" class="headerlink" title="TypeScript 的编译环境"></a>TypeScript 的编译环境</h3><p>在前面我们提到过，TypeScript 最终会被编译成 JavaScript 来运行，所以我们需要搭建对应的环境：</p><p>我们需要在电脑上安装 TypeScript，这样就可以通过 TypeScript 的 Compiler 将其编译成 JavaScript；</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191523558.png" alt="image-20211019152342131"></p><p>所以，我们需要先可以先进行全局的安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装命令</span></span><br><span class="line">npm install typescript -g</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line">tsc --version</span><br></pre></td></tr></table></figure><h3 id="TypeScript-的运行环境"><a href="#TypeScript-的运行环境" class="headerlink" title="TypeScript 的运行环境"></a>TypeScript 的运行环境</h3><blockquote><p>如果我们每次为了查看 TypeScript 代码的运行效果，都通过经过两个步骤的话就太繁琐了：</p></blockquote><ol><li>第一步：通过 tsc 编译 TypeScript 到 JavaScript 代码；</li><li>第二步：在浏览器或者 Node 环境下运行 JavaScript 代码；</li></ol><blockquote><p>是否可以简化这样的步骤呢？</p></blockquote><p>比如编写了 TypeScript 之后可以直接运行在浏览器上？</p><p>比如编写了 TypeScript 之后，直接通过 node 的命令来执行？</p><blockquote><p>上面我提到的两种方式，可以通过两个解决方案来完成：</p></blockquote><p>方式一：通过 webpack，配置本地的 TypeScript 编译环境和开启一个本地服务，可以直接运行在浏览器上；</p><p>方式二：通过 ts-node 库，为 TypeScript 的运行提供执行环境；</p><blockquote><p>方式一：webpack 配置</p></blockquote><p>方式一在之前的 TypeScript 文章中我已经有写过，如果需要可以自行查看对应的文章；</p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://mp.weixin.qq.com/s/wnL1l-ERjTDykWM76l4Ajw%EF%BC%9B">https://mp.weixin.qq.com/s/wnL1l-ERjTDykWM76l4Ajw；</a></p><blockquote><p>方式二：安装 ts-node</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install ts-node -g</span><br></pre></td></tr></table></figure><p>另外 ts-node 需要依赖 tslib 和 @types/node 两个包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install tslib @types/node -g</span><br></pre></td></tr></table></figure><p>现在，我们可以直接通过 ts-node 来运行 TypeScript 的代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ts-node math.ts</span><br></pre></td></tr></table></figure><h3 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h3><p>我们已经强调过很多次，在 TypeScript 中定义变量需要指定 <strong>标识符</strong> 的类型。</p><p>所以完整的声明格式如下：</p><ul><li><p>声明了类型后 TypeScript 就会进行<code>类型检测</code>，声明的类型可以称之为<code>类型注解</code>；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var/let/const 标识符: 数据类型 = 赋值;</span><br></pre></td></tr></table></figure></li></ul><p>比如我们声明一个 message，完整的写法如下：</p><p>注意：这里的 string 是小写的，和 String 是有区别的</p><p>string 是 TypeScript 中定义的字符串类型，String 是 ECMAScript 中定义的一个类</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191526006.png" alt="image-20211019152642919"></p><p>如果我们给 message 赋值其他类型的值，那么就会报错：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191527058.png" alt="image-20211019152659321"></p><h4 id="声明变量的关键字"><a href="#声明变量的关键字" class="headerlink" title="声明变量的关键字"></a>声明变量的关键字</h4><p>在 TypeScript 定义变量（标识符）和 ES6 之后一致，可以使用 var、let、const 来定义。</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191527300.png" alt="image-20211019152717677"></p><p>当然，在 tslint 中并不推荐使用 var 来声明变量：</p><p>可见，在 TypeScript 中并不建议再使用 var 关键字了，主要原因和 ES6 升级后 let 和 var 的区别是一样的，var 是没有块级作用域的，会引起很多的问题，这里不再展开探讨。</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191527282.png" alt="image-20211019152738496"></p><h4 id="变量的类型推导（推断）"><a href="#变量的类型推导（推断）" class="headerlink" title="变量的类型推导（推断）"></a>变量的类型推导（推断）</h4><p>在开发中，有时候为了方便起见我们并不会在声明每一个变量时都写上对应的数据类型，我们更希望可以通过 TypeScript 本身的特性帮助我们推断出对应的变量类型：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191528073.png" alt="image-20211019152759421"></p><p>如果我们给 message 赋值 123：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191528508.png" alt="image-20211019152812950"></p><p>这是因为在一个变量第一次赋值时，会根据后面的赋值内容的类型，来推断出变量的类型：</p><p>上面的 message 就是因为后面赋值的是一个 string 类型，所以 message 虽然没有明确的说明，但是依然是一个 string 类型；</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191528245.png" alt="image-20211019152829474"></p><h3 id="JavaScript-和-TypeScript-的数据类型"><a href="#JavaScript-和-TypeScript-的数据类型" class="headerlink" title="JavaScript 和 TypeScript 的数据类型"></a>JavaScript 和 TypeScript 的数据类型</h3><p>我们经常说 TypeScript 是 JavaScript 的一个超级：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191528374.png" alt="image-20211019152845493"></p><h4 id="JavaScript-类型-–-number-类型"><a href="#JavaScript-类型-–-number-类型" class="headerlink" title="JavaScript 类型 – number 类型"></a>JavaScript 类型 – number 类型</h4><p>数字类型是我们开发中经常使用的类型，TypeScript 和 JavaScript 一样，不区分整数类型（int）和浮点型（double），统一为 number 类型。</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191529278.png" alt="image-20211019152945617"></p><p>如果你学习过 ES6 应该知道，ES6 新增了二进制和八进制的表示方法，而 TypeScript 也是支持二进制、八进制、十</p><p>六进制的表示：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191530214.png" alt="image-20211019153005506"></p><h4 id="JavaScript-类型-–-boolean-类型"><a href="#JavaScript-类型-–-boolean-类型" class="headerlink" title="JavaScript 类型 – boolean 类型"></a>JavaScript 类型 – boolean 类型</h4><p>boolean 类型只有两个取值：true 和 false，非常简单</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191530544.png" alt="image-20211019153026854"></p><h4 id="JavaScript-类型-–-string-类型"><a href="#JavaScript-类型-–-string-类型" class="headerlink" title="JavaScript 类型 – string 类型"></a>JavaScript 类型 – string 类型</h4><p>string 类型是字符串类型，可以使用单引号或者双引号表示：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191530781.png" alt="image-20211019153050126"></p><p>同时也支持 ES6 的模板字符串来拼接变量和字符串：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191531789.png"></p><h4 id="JavaScript-类型-–-Array-类型"><a href="#JavaScript-类型-–-Array-类型" class="headerlink" title="JavaScript 类型 – Array 类型"></a>JavaScript 类型 – Array 类型</h4><p>数组类型的定义也非常简单，有两种方式：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191531934.png"></p><p>如果添加其他类型到数组中，那么会报错：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191531902.png"></p><h4 id="JavaScript-类型-–-Object-类型"><a href="#JavaScript-类型-–-Object-类型" class="headerlink" title="JavaScript 类型 – Object 类型"></a>JavaScript 类型 – Object 类型</h4><p>object 对象类型可以用于描述一个对象：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191532372.png"></p><p>但是从 myinfo 中我们不能获取数据，也不能设置数据：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191532815.png"></p><h4 id="JavaScript-类型-–-Symbol-类型"><a href="#JavaScript-类型-–-Symbol-类型" class="headerlink" title="JavaScript 类型 – Symbol 类型"></a>JavaScript 类型 – Symbol 类型</h4><p>在 ES5 中，如果我们是不可以在对象中添加相同的属性名称的，比如下面的做法：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191532194.png"></p><p>通常我们的做法是定义两个不同的属性名字：比如 identity1 和 identity2。</p><p>但是我们也可以通过 symbol 来定义相同的名称，因为 Symbol 函数返回的是不同的值：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191533097.png" alt="image-20211019153308428"></p><h4 id="JavaScript-类型-–-null-和-undefined-类型"><a href="#JavaScript-类型-–-null-和-undefined-类型" class="headerlink" title="JavaScript 类型 – null 和 undefined 类型"></a>JavaScript 类型 – null 和 undefined 类型</h4><p>在 JavaScript 中，undefined 和 null 是两个基本数据类型。</p><p>在 TypeScript 中，它们各自的类型也是 undefined 和 null，也就意味着它们既是实际的值，也是自己的类型：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191533202.png" alt="image-20211019153333633"></p><h4 id="TypeScript-类型-any-类型"><a href="#TypeScript-类型-any-类型" class="headerlink" title="TypeScript 类型 - any 类型"></a>TypeScript 类型 - any 类型</h4><p>在某些情况下，我们确实无法确定一个变量的类型，并且可能它会发生一些变化，这个时候我们可以使用 any 类型（类似于 Dart 语言中的 dynamic 类型）any 类型有点像一种讨巧的 TypeScript 手段：</p><ul><li>我们可以对 any 类型的变量进行任何的操作，包括获取不存在的属性、方法；</li><li>我们给一个 any 类型的变量赋值任何的值，比如数字、字符串的值；</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191534337.png" alt="image-20211019153418103"></p><p>如果对于某些情况的处理过于繁琐不希望添加规定的类型注解，或者在引入一些第三方库时，缺失了类型注解，这个时候我们可以使用 any：包括在 Vue 源码中，也会使用到 any 来进行某些类型的适配；</p><h4 id="TypeScript-类型-unknown-类型"><a href="#TypeScript-类型-unknown-类型" class="headerlink" title="TypeScript 类型 - unknown 类型"></a>TypeScript 类型 - unknown 类型</h4><p>unknown 是 TypeScript 中比较特殊的一种类型，它用于描述类型不确定的变量</p><p>什么意思呢？我们来看下面的场景：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191535141.png"></p><h4 id="TypeScript-类型-void-类型"><a href="#TypeScript-类型-void-类型" class="headerlink" title="TypeScript 类型 - void 类型"></a>TypeScript 类型 - void 类型</h4><p>void 通常用来指定一个函数是没有返回值的，那么它的返回值就是 void 类型</p><p>我们可以将 null 和 undefined 赋值给 void 类型，也就是函数可以返回 null 或者 undefined<br><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191535398.png"></p><p>这个函数我们没有写任何类型，那么它默认返回值的类型就是 void 的，我们也可以显示的来指定返回值是 void：<br><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191536746.png"></p><h4 id="TypeScript-类型-never-类型"><a href="#TypeScript-类型-never-类型" class="headerlink" title="TypeScript 类型 - never 类型"></a>TypeScript 类型 - never 类型</h4><p>never 表示永远不会发生值的类型，比如一个函数：</p><p>如果一个函数中是一个死循环或者抛出一个异常，那么这个函数会返回东西吗？</p><p>不会，那么写 void 类型或者其他类型作为返回值类型都不合适，我们就可以使用 never 类型；</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191536517.png"></p><h4 id="TypeScript-类型-tuple-类型"><a href="#TypeScript-类型-tuple-类型" class="headerlink" title="TypeScript 类型 - tuple 类型"></a>TypeScript 类型 - tuple 类型</h4><p>tuple 是元组类型，很多语言中也有这种数据类型，比如 Python、Swift 等。</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191537957.png"></p><p>那么 tuple 和数组有什么区别呢？</p><p>首先，数组中通常建议存放相同类型的元素，不同类型的元素是不推荐放在数组中。（可以放在对象或者元组中）</p><p>其次，元组中每个元素都有自己特性的类型，根据索引值获取到的值可以确定对应的类型；</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191537209.png"></p><p>那么 tuple 在什么地方使用的是最多的呢？</p><p>tuple 通常可以作为返回的值，在使用的时候会非常的方便；</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191538304.png"></p><h3 id="函数的参数类型"><a href="#函数的参数类型" class="headerlink" title="函数的参数类型"></a>函数的参数类型</h3><p>函数是 JavaScript 非常重要的组成部分，TypeScript 允许我们指定函数的参数和返回值的类型。</p><p><strong>参数的类型注解</strong><br>声明函数时，可以在每个参数后添加类型注解，以声明函接受的参数类型：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191539483.png"></p><h3 id="函数的返回值类型"><a href="#函数的返回值类型" class="headerlink" title="函数的返回值类型"></a>函数的返回值类型</h3><p>我们也可以添加返回值的类型注解，这个注解出现在函数列表的后面：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191539064.png"></p><p>和变量的类型注解一样，我们通常情况下不需要返回类型注解，因为 TypeScript 会根据 return 返回值推断函数的返回类型：某些第三方库处于方便理解，会明确指定返回类型，但是这个看个人喜好；</p><h3 id="匿名函数的参数"><a href="#匿名函数的参数" class="headerlink" title="匿名函数的参数"></a>匿名函数的参数</h3><p>匿名函数与函数声明会有一些不同：</p><p>当一个函数出现在 TypeScript 可以确定该函数会被如何调用的地方时；</p><p>该函数的参数会自动指定类型；</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191539159.png"></p><p>我们并没有指定 item 的类型，但是 item 是一个 string 类型：</p><p>这是因为 TypeScript 会根据 forEach 函数的类型以及数组的类型推断出 item 的类型；</p><p>这个过程称之为<code>上下文类型（contextual typing）</code>，因为函数执行的上下文可以帮助确定参数和返回值的类型；</p><h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>如果我们希望限定一个函数接受的参数是一个对象，这个时候要如何限定呢？<br>我们可以使用对象类型；</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191541635.png"></p><p>在这里我们使用了一个对象来作为类型：</p><ul><li>在对象我们可以添加属性，并且告知 TypeScript 该属性需要是什么类型；</li><li>属性之间可以使用 , 或者 ; 来分割，最后一个分隔符是可选的；</li><li>每个属性的类型部分也是可选的，如果不指定，那么就是 any 类型；</li></ul><h3 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h3><p>对象类型也可以指定哪些属性是可选的，可以在属性的后面添加一个?：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191541189.png" alt="image-20211019154147307"></p><p><strong>可选类型补充</strong></p><p>事实上，可选类型可以看做是 类型 和 undefined 的联合类型：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191543860.png"></p><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>TypeScript 的类型系统允许我们使用多种运算符，从现有类型中构建新类型。</p><p>我们来使用第一种组合类型的方法：联合类型（Union Type）</p><ul><li>联合类型是由两个或者多个其他类型组成的类型；</li><li>表示可以是这些类型中的任何一个值；</li><li>联合类型中的每一个类型被称之为联合成员（union’s _members_）；</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191542853.png"></p><h3 id="使用联合类型"><a href="#使用联合类型" class="headerlink" title="使用联合类型"></a>使用联合类型</h3><p>传入给一个联合类型的值是非常简单的：只要保证是联合类型中的某一个类型的值即可</p><ul><li>但是我们拿到这个值之后，我们应该如何使用它呢？因为它可能是任何一种类型。</li><li>比如我们拿到的值可能是 string 或者 number，我们就不能对其调用 string 上的一些方法；</li></ul><p>那么我们怎么处理这样的问题呢？</p><ul><li>我们需要使用缩小（narrow）联合（后续我们还会专门讲解缩小相关的功能）；</li><li>TypeScript 可以根据我们缩小的代码结构，推断出更加具体的类型；</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191543661.png"></p><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>在前面，我们通过在类型注解中编写 对象类型 和 联合类型，但是当我们想要多次在其他地方使用时，就要编写多 次。</p><p>比如我们可以给对象类型起一个别名：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191544381.png"></p><h3 id="类型断言-as"><a href="#类型断言-as" class="headerlink" title="类型断言 as"></a>类型断言 as</h3><p>有时候 TypeScript 无法获取具体的类型信息，这个我们需要使用类型断言（Type Assertions）。</p><p>比如我们通过 document.getElementById，TypeScript 只知道该函数会返回 HTMLElement ，但并不知道它具体的类型：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191545406.png"></p><p>TypeScript 只允许类型断言转换为 更具体 或者 不太具体 的类型版本，此规则可防止不可能的强制转换：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191545254.png"></p><h3 id="非空类型断言"><a href="#非空类型断言" class="headerlink" title="非空类型断言!"></a>非空类型断言!</h3><p>当我们编写下面的代码时，在执行 ts 的编译阶段会报错：</p><p>这是因为传入的 message 有可能是为 undefined 的，这个时候是不能执行方法的；</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191545800.png"></p><p>但是，我们确定传入的参数是有值的，这个时候我们可以使用非空类型断言：</p><p>非空断言使用的是 ! ，表示可以确定某个标识符是有值的，跳过 ts 在编译阶段对它的检测；</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191546362.png"></p><h3 id="可选链的使用"><a href="#可选链的使用" class="headerlink" title="可选链的使用"></a>可选链的使用</h3><p>可选链事实上并不是 TypeScript 独有的特性，它是 ES11（ES2020）中增加的特性：</p><ul><li>可选链使用可选链操作符 ?.；</li><li>它的作用是当对象的属性不存在时，会短路，直接返回 undefined，如果存在，那么才会继续执行；</li><li>虽然可选链操作是 ECMAScript 提出的特性，但是和 TypeScript 一起使用更版本；</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191546300.png"></p><h3 id="和-的作用"><a href="#和-的作用" class="headerlink" title="??和!!的作用"></a>??和!!的作用</h3><p>有时候我们还会看到 !! 和 ?? 操作符，这些都是做什么的呢？</p><p>!!操作符：</p><ul><li>将一个其他类型转换成 boolean 类型；</li><li>类似于 Boolean(变量)的方式；</li></ul><p>??操作符：</p><ul><li>它是 ES11 增加的新特性；</li><li><strong>空值合并操作符</strong>（**??）是一个逻辑操作符，当操作符的左侧是 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数；**</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191547455.png"></p><h3 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h3><p>除了前面我们所讲过的类型之外，也可以使用字面量类型（literal types）：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191548719.png"></p><p>那么这样做有什么意义呢？</p><p>默认情况下这么做是没有太大的意义的，但是我们可以将多个类型联合在一起；</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191548666.png"></p><h3 id="字面量推理"><a href="#字面量推理" class="headerlink" title="字面量推理"></a>字面量推理</h3><p>我们来看下面的代码：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191548491.png"></p><p>这是因为我们的对象再进行字面量推理的时候，info 其实是一个 {url: string, method: string}，所以我们没办法将一个 string 赋值给一个 字面量 类型。</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191548769.png"></p><h3 id="类型缩小"><a href="#类型缩小" class="headerlink" title="类型缩小"></a>类型缩小</h3><blockquote><p>什么是类型缩小呢？</p></blockquote><ul><li>类型缩小的英文是 Type Narrowing；</li><li>我们可以通过类似于 typeof padding === “number” 的判断语句，来改变 TypeScript 的执行路径；</li><li>在给定的执行路径中，我们可以缩小比声明时更小的类型，这个过程称之为 缩小;</li><li>而我们编写的 typeof padding === “number 可以称之为 类型保护（type guards）；</li></ul><blockquote><p>常见的类型保护有如下几种：</p></blockquote><ul><li>typeof</li><li>平等缩小（比如===、!==）</li><li>instanceof</li><li>in</li><li>等等…</li></ul><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>在 TypeScript 中，检查返回的值 typeof 是一种类型保护：因为 TypeScript 对如何 typeof 操作不同的值进行编码。</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191550196.png"></p><h3 id="平等缩小"><a href="#平等缩小" class="headerlink" title="平等缩小"></a>平等缩小</h3><p>我们可以使用 Switch 或者相等的一些运算符来表达相等性（比如===, !==, ==, and != ）：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191551617.png" alt="image-20211019155100488"></p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>JavaScript 有一个运算符来检查一个值是否是另一个值的“实例”：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191551771.png"></p><h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><p>Javascript 有一个运算符，用于确定对象是否具有带名称的属性：in 运算符</p><p>如果指定的属性在指定的对象或其原型链中，则<strong>in 运算符</strong>返回 true；</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191552281.png"></p><h3 id="TypeScript-函数类型"><a href="#TypeScript-函数类型" class="headerlink" title="TypeScript 函数类型"></a>TypeScript 函数类型</h3><p>在 JavaScript 开发中，函数是重要的组成部分，并且函数可以作为一等公民（可以作为参数，也可以作为返回值进行传递）。</p><p>那么在使用函数的过程中，函数是否也可以有自己的类型呢？<br>我们可以编写函数类型的表达式（Function Type Expressions），来表示函数类型</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191552503.png"></p><h3 id="TypeScript-函数类型解析"><a href="#TypeScript-函数类型解析" class="headerlink" title="TypeScript 函数类型解析"></a>TypeScript 函数类型解析</h3><p>在上面的语法中 (num1: number, num2: number) =&gt; void，代表的就是一个函数类型：</p><ul><li>接收两个参数的函数：num1 和 num2，并且都是 number 类型；</li><li>并且这个函数是没有返回值的，所以是 void；</li></ul><p>在某些语言中，可能参数名称 num1 和 num2 是可以省略，但是 TypeScript 是不可以的：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191553536.png" alt="image-20211019155300993"></p><h3 id="参数的可选类型"><a href="#参数的可选类型" class="headerlink" title="参数的可选类型"></a>参数的可选类型</h3><p>我们可以指定某个参数是可选的：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191553012.png"></p><p>这个时候这个参数 x 依然是有类型的，它是什么类型呢？ number | undefined</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191554046.png"></p><p>另外可选类型需要在必传参数的后面：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191554715.png"></p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>从 ES6 开始，JavaScript 是支持默认参数的，TypeScript 也是支持默认参数的：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191554134.png"></p><p>这个时候 y 的类型其实是 undefined 和 number 类型的联合。</p><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>从 ES6 开始，JavaScript 也支持剩余参数，剩余参数语法允许我们将一个不定数量的参数放到一个数组中。</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191555389.png"></p><h3 id="可推导的-this-类型"><a href="#可推导的-this-类型" class="headerlink" title="可推导的 this 类型"></a>可推导的 this 类型</h3><p>this 是 JavaScript 中一个比较难以理解和把握的知识点：</p><p>因为 this 在不同的情况下会绑定不同的值，所以对于它的类型就更难把握了；</p><p>那么，TypeScript 是如何处理 this 呢？我们先来看一个例子</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191555386.png"></p><p>上面的代码是可以正常运行的，也就是 TypeScript 在编译时，认为我们的 this 是可以正确去使用的：</p><p>TypeScript 认为函数 sayHello 有一个对应的 this 的外部对象 info，所以在使用时，就会把 this 当做该对象。</p><p><strong>不确定的 this 类型</strong></p><p>但是对于某些情况来说，我们并不知道 this 到底是什么？</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191556893.png"></p><p>这段代码运行会报错的：</p><ul><li>这里我们再次强调一下，TypeScript 进行类型检测的目的是让我们的代码更加的安全；</li><li>所以这里对于 sayHello 的调用来说，我们虽然将其放到了 info 中，通过 info 去调用，this 依然是指向 info 对象的；</li><li>但是对于 TypeScript 编译器来说，这个代码是非常不安全的，因为我们也有可能直接调用函数，或者通过别的对象来调用函数；</li></ul><p><strong>指定 this 的类型</strong></p><p>这个时候，通常 TypeScript 会要求我们明确的指定 this 的类型：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191557271.png"></p><h3 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h3><p>在 TypeScript 中，如果我们编写了一个 add 函数，希望可以对字符串和数字类型进行相加，应该如何编写呢？</p><p>我们可能会这样来编写，但是其实是错误的：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191557068.png"></p><p>那么这个代码应该如何去编写呢？</p><p>在 TypeScript 中，我们可以去编写不同的重载签名（_overload signatures_）来表示函数可以以不同的方式进行调用；一般是编写两个或者以上的重载签名，再去编写一个通用的函数以及实现；</p><p><strong>sum 函数的重载</strong></p><p>比如我们对 sum 函数进行重构：</p><p>在我们调用 sum 的时候，它会根据我们传入的参数类型来决定执行函数体时，到底执行哪一个函数的重载签名；</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191559661.png"></p><p><strong>但是注意，有实现提的函数，是不能直接被调用的：</strong></p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191559804.png"></p><h3 id="联合类型和重载"><a href="#联合类型和重载" class="headerlink" title="联合类型和重载"></a>联合类型和重载</h3><p>我们现在有一个需求：定义一个函数，可以传入字符串或者数组，获取它们的长度。</p><p>这里有两种实现方案：</p><blockquote><p>方案一：使用联合类型来实现；</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191600475.png" alt="image-20211019160019404"></p><blockquote><p>方案二：实现函数重载来实现；</p></blockquote><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191600957.png"></p><p>在开发中我们选择使用哪一种呢？在可能的情况下，尽量选择使用<code>联合类型</code>来实现；</p><h3 id="认识类的使用"><a href="#认识类的使用" class="headerlink" title="认识类的使用"></a>认识类的使用</h3><p>在早期的 JavaScript 开发中（ES5）我们需要通过函数和原型链来实现类和继承，从 ES6 开始，引入了 class 关键字，可以更加方便的定义和使用类。</p><p>TypeScript 作为 JavaScript 的超集，也是支持使用 class 关键字的，并且还可以对类的属性和方法等进行静态类型检测。</p><p>实际上在 JavaScript 的开发过程中，我们更加习惯于函数式编程：</p><ul><li>比如 React 开发中，目前更多使用的函数组件以及结合 Hook 的开发模式；</li><li>比如在 Vue3 开发中，目前也更加推崇使用 Composition API；</li></ul><p>但是在封装某些业务的时候，类具有更强大封装性，所以我们也需要掌握它们。</p><p>类的定义我们通常会使用 class 关键字：</p><ul><li>在面向对象的世界里，任何事物都可以使用类的结构来描述；</li><li>类中包含特有的属性和方法；</li></ul><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><p><strong>我们来定义一个 Person 类：</strong></p><p>使用 class 关键字来定义一个类；</p><p>我们可以声明一些类的属性：在类的内部声明类的属性以及对应的类型</p><ul><li>如果类型没有声明，那么它们默认是 any 的；</li><li>我们也可以给属性设置初始化值；</li><li>在默认的 strictPropertyInitialization 模式下面我们的属性是必须初始化的，如果没有初始化，那么编译时就会报错；如果我们在 strictPropertyInitialization 模式下确实不希望给属性初始化，可以使用 name!: string 语法；</li></ul><p>类可以有自己的构造函数 constructor，当我们通过 new 关键字创建一个实例时，构造函数会被调用；构造函数不需要返回任何值，默认返回当前创建出来的实例；</p><p>类中可以有自己的函数，定义的函数称之为方法；</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191602418.png"></p><h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><p>面向对象的其中一大特性就是继承，继承不仅仅可以减少我们的代码量，也是多态的使用前提。</p><p>我们使用 extends 关键字来实现继承，子类中使用 super 来访问父类。</p><p>我们来看一下 Student 类继承自 Person：</p><p>Student 类可以有自己的属性和方法，并且会继承 Person 的属性和方法；</p><p>在构造函数中，我们可以通过 super 来调用父类的构造方法，对父类中的属性进行初始化；</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191603655.png"></p><h4 id="类的成员修饰符"><a href="#类的成员修饰符" class="headerlink" title="类的成员修饰符"></a>类的成员修饰符</h4><p>在 TypeScript 中，类的属性和方法支持三种修饰符： public、private、protected</p><ul><li>public 修饰的是在任何地方可见、公有的属性或方法，默认编写的属性就是 public 的；</li><li>private 修饰的是仅在同一类中可见、私有的属性或方法；</li><li>protected 修饰的是仅在类自身及子类中可见、受保护的属性或方法；</li></ul><p>public 是默认的修饰符，也是可以直接访问的，我们这里来演示一下 protected 和 private</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191604815.png"></p><h3 id="只读属性-readonly"><a href="#只读属性-readonly" class="headerlink" title="只读属性 readonly"></a>只读属性 readonly</h3><p>如果有一个属性我们不希望外界可以任意的修改，只希望确定值后直接使用，那么可以使用 readonly</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191604841.png"></p><h3 id="getters-setters"><a href="#getters-setters" class="headerlink" title="getters/setters"></a>getters/setters</h3><p>在前面一些私有属性我们是不能直接访问的，或者某些属性我们想要监听它的获取(getter)和设置(setter)的过程，这个时候我们可以使用存取器。</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191604818.png"></p><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>前面我们在类中定义的成员和方法都属于对象级别的, 在开发中, 我们有时候也需要定义类级别的成员和方法。</p><p>在 TypeScript 中通过关键字 static 来定义：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191605356.png"></p><h3 id="抽象类-abstract"><a href="#抽象类-abstract" class="headerlink" title="抽象类 abstract"></a>抽象类 abstract</h3><p>我们知道，继承是多态使用的前提。</p><ul><li>所以在定义很多通用的<strong>调用接口时, 我们通常会让调用者传入父类，通过多态来实现更加灵活的调用方式。</strong></li><li><strong>但是，父类本身可能并不需要对某些方法进行具体的实现，所以父类中定义的方法,，我们可以定义为抽象方法。</strong></li></ul><p><strong>什么是 抽象方法? 在 TypeScript 中没有具体实现的方法(没有方法体)，就是抽象方法。</strong></p><ul><li>抽象方法，必须存在于抽象类中；</li><li>抽象类是使用 abstract 声明的类；</li></ul><p>抽象类有如下的特点：</p><ul><li>抽象类是不能被实例的话（也就是不能通过 new 创建）</li><li>抽象方法必须被子类实现，否则该类必须是一个抽象类；</li></ul><p><strong>抽象类演练</strong></p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191606791.png"></p><h3 id="类的类型"><a href="#类的类型" class="headerlink" title="类的类型"></a>类的类型</h3><p>类本身也是可以作为一种数据类型的：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191606446.png"></p><h3 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a>接口的声明</h3><p>在前面我们通过 type 可以用来声明一个对象类型：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191607380.png"></p><p>对象的另外一种声明方式就是通过接口来声明：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191607499.png"></p><p>他们在使用上的区别，我们后续再来说明，接下来我们继续学习一下接口的其他特性</p><h4 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h4><p>接口中我们也可以定义可选属性：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191607948.png" alt="image-20211019160758390"></p><h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><p>接口中也可以定义只读属性，这样就意味着我们再初始化之后，这个值是不可以被修改的；</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191608632.png"></p><h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><p>前面我们使用 interface 来定义对象类型，这个时候其中的属性名、类型、方法都是确定的，但是有时候我们会遇到类似下面的对象：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191608303.png"></p><h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>前面我们都是通过 interface 来定义对象中普通的属性和方法的，实际上它也可以用来定义函数类型：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191609157.png" alt="image-20211019160907225"></p><p>当然，除非特别的情况，还是推荐大家使用类型别名来定义函数：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191609105.png"></p><h4 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h4><p>接口和类一样是可以进行继承的，也是使用 extends 关键字：并且我们会发现，接口是支持多继承的（类不支持多继承）</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191609207.png"></p><h4 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h4><p>接口定义后，也是可以被类实现的：</p><p>如果被一个类实现，那么在之后需要传入接口的地方，都可以将这个类传入；这就是面向接口开发；</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191610780.png"></p><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>前面我们学习了联合类型：联合类型表示多个类型中一个即可</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191611430.png"></p><p>还有另外一种类型合并，就是交叉类型（Intersection Types）：</p><ul><li>交叉类似表示需要满足多个类型的条件；</li><li>交叉类型使用 &amp; 符号；</li></ul><p>我们来看下面的交叉类型：</p><ul><li>表达的含义是 number 和 string 要同时满足；</li><li>但是有同时满足是一个 number 又是一个 string 的值吗？其实是没有的，所以 MyType 其实是一个 never 类型；</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191612811.png"></p><h4 id="交叉类型的应用"><a href="#交叉类型的应用" class="headerlink" title="交叉类型的应用"></a>交叉类型的应用</h4><p>所以，在开发中，我们进行交叉时，通常是对对象类型进行交叉的：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191612300.png" alt="image-20211019161237464"></p><h3 id="interface-和-type-区别"><a href="#interface-和-type-区别" class="headerlink" title="interface 和 type 区别"></a>interface 和 type 区别</h3><p>我们会发现 interface 和 type 都可以用来定义对象类型，那么在开发中定义对象类型时，到底选择哪一个呢？</p><p>如果是定义非对象类型，通常推荐使用 type，比如 Direction、Alignment、一些 Function；</p><p>如果是定义对象类型，那么他们是有区别的：</p><ul><li>interface 可以重复的对某个接口来定义属性和方法；</li><li>而 type 定义的是别名，别名是不能重复的；</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191613480.png"></p><h3 id="字面量赋值"><a href="#字面量赋值" class="headerlink" title="字面量赋值"></a>字面量赋值</h3><p>我们来看下面的代码：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191614517.png"></p><p>这是因为 TypeScript 在字面量直接赋值的过程中，为了进行类型推导会进行严格的类型限制。</p><p>但是之后如果我们是将一个 变量标识符 赋值给其他的变量时，会进行 freshness 擦除操作。</p><h3 id="TypeScript-枚举类型"><a href="#TypeScript-枚举类型" class="headerlink" title="TypeScript 枚举类型"></a>TypeScript 枚举类型</h3><p>枚举类型是为数不多的 TypeScript 特有的特性之一：</p><p>枚举其实就是将一组可能出现的值，一个个列举出来，定义在一个类型中，这个类型就是枚举类型；</p><p>枚举允许开发者定义一组命名常量，常量可以是数字、字符串类型；</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191615053.png"></p><h3 id="枚举类型的值"><a href="#枚举类型的值" class="headerlink" title="枚举类型的值"></a>枚举类型的值</h3><p>枚举类型默认是有值的，比如上面的枚举，默认值是这样的：</p><p>当然，我们也可以给枚举其他值：</p><ul><li>这个时候会从 100 进行递增；</li></ul><p>我们也可以给他们赋值其他的类型：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191616707.png" alt="image-20211019161624066"></p><h3 id="认识泛型"><a href="#认识泛型" class="headerlink" title="认识泛型"></a>认识泛型</h3><p>软件工程的主要目的是构建不仅仅明确和一致的 API，还要让你的代码具有很强的可重用性：</p><ul><li>比如我们可以通过函数来封装一些 API，通过传入不同的函数参数，让函数帮助我们完成不同的操作；</li><li>但是对于参数的类型是否也可以参数化呢？</li></ul><p>什么是类型的参数化？</p><ul><li>我们来提一个需求：封装一个函数，传入一个参数，并且返回这个参数；</li></ul><p>如果我们是 TypeScript 的思维方式，要考虑这个参数和返回值的类型需要一致：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191617815.png"></p><h3 id="泛型实现类型参数化"><a href="#泛型实现类型参数化" class="headerlink" title="泛型实现类型参数化"></a>泛型实现类型参数化</h3><p>虽然 any 是可以的，但是定义为 any 的时候，我们其实已经丢失了类型信息：</p><ul><li>比如我们传入的是一个 number，那么我们希望返回的可不是 any 类型，而是 number 类型；</li><li>所以，我们需要在函数中可以捕获到参数的类型是 number，并且同时使用它来作为返回值的类型；</li></ul><p>我们需要在这里使用一种特性的变量 - 类型变量（type variable），它作用于类型，而不是值：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191617174.png"></p><p><strong>这里我们可以使用两种方式来调用它：</strong></p><ul><li>方式一：通过 &lt;类型&gt; 的方式将类型传递给函数；</li><li>方式二：通过类型推到，自动推到出我们传入变量的类型：<br>在这里会推导出它们是 字面量类型的，因为字面量类型对于我们的函数也是适用的</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191618303.png" alt="image-20211019161823917"></p><h4 id="泛型的基本补充"><a href="#泛型的基本补充" class="headerlink" title="泛型的基本补充"></a>泛型的基本补充</h4><p>当然我们也可以传入多个类型：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191618740.png"></p><p>平时在开发中我们可能会看到一些常用的名称：</p><p>T：Type 的缩写，类型</p><p>K、V：key 和 value 的缩写，键值对</p><p>E：Element 的缩写，元素</p><p>O：Object 的缩写，对象</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>在定义接口的时候我们也可以使用泛型：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191619310.png"></p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>我们也可以编写一个泛型类：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191619057.png" alt="image-20211019161935567"></p><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>有时候我们希望传入的类型有某些共性，但是这些共性可能不是在同一种类型中：</p><ul><li>比如 string 和 array 都是有 length 的，或者某些对象也是会有 length 属性的；</li><li>那么只要是拥有 length 的属性都可以作为我们的参数类型，那么应该如何操作呢？</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191620096.png"></p><h3 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h3><p>TypeScript 支持两种方式来控制我们的作用域：</p><ul><li>模块化：每个文件可以是一个独立的模块，支持 ES Module，也支持 CommonJS；</li><li>命名空间：通过 namespace 来声明一个命名空间</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191620769.png"></p><h3 id="命名空间-namespace"><a href="#命名空间-namespace" class="headerlink" title="命名空间 namespace"></a>命名空间 namespace</h3><ul><li>命名空间在 TypeScript 早期时，称之为内部模块，主要目的是将一个模块内部再进行作用域的划分，防止一些命名冲突的问题</li></ul><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191620258.png" alt="image-20211019162045690"></p><h3 id="类型的查找"><a href="#类型的查找" class="headerlink" title="类型的查找"></a>类型的查找</h3><p>之前我们所有的 typescript 中的类型，几乎都是我们自己编写的，但是我们也有用到一些其他的类型：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191621549.png"></p><blockquote><p>大家是否会奇怪，我们的 HTMLImageElement 类型来自哪里呢？甚至是 document 为什么可以有 getElementById 的方法呢？</p></blockquote><p>其实这里就涉及到 typescript 对类型的管理和查找规则了。</p><p>我们这里先给大家介绍另外的一种 typescript 文件：</p><p><strong>.d.ts 文件</strong></p><ul><li>我们之前编写的 typescript 文件都是 .ts 文件，这些文件最终会输出 .js 文件，也是我们通常编写代码的地方；</li><li>还有另外一种文件 .d.ts 文件，它是用来做类型的声明(declare)。 它仅仅用来做类型检测，告知 typescript 我们有哪些类型；</li></ul><p>那么 typescript 会在哪里查找我们的类型声明呢？</p><ul><li>内置类型声明；</li><li>外部定义类型声明；</li><li>自己定义类型声明；</li></ul><h3 id="内置类型声明"><a href="#内置类型声明" class="headerlink" title="内置类型声明"></a>内置类型声明</h3><p>内置类型声明是 typescript 自带的、帮助我们内置了 JavaScript 运行时的一些标准化 API 的声明文件；</p><ul><li>包括比如 Math、Date 等内置类型，也包括 DOM API，比如 Window、Document 等；</li></ul><p>内置类型声明通常在我们安装 typescript 的环境中会带有的；</p><ul><li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/microsoft/TypeScript/tree/main/lib">https://github.com/microsoft/TypeScript/tree/main/lib</a></li></ul><h3 id="外部定义类型声明和自定义声明"><a href="#外部定义类型声明和自定义声明" class="headerlink" title="外部定义类型声明和自定义声明"></a>外部定义类型声明和自定义声明</h3><p>外部类型声明通常是我们使用一些库（比如第三方库）时，需要的一些类型声明。</p><p><strong>这些库通常有两种类型声明方式：</strong></p><p>方式一：在自己库中进行类型声明（编写.d.ts 文件），比如 axios</p><p>方式二：通过社区的一个公有库 DefinitelyTyped 存放类型声明文件</p><ul><li>该库的 GitHub 地址：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/DefinitelyTyped/DefinitelyTyped/">https://github.com/DefinitelyTyped/DefinitelyTyped/</a></li><li>该库查找声明安装方式的地址：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.typescriptlang.org/dt/search?search=">https://www.typescriptlang.org/dt/search?search=</a></li><li>比如我们安装 react 的类型声明： npm i @types/react –save-dev</li></ul><p>什么情况下需要自己来定义声明文件呢？</p><p>情况一：我们使用的第三方库是一个纯的 JavaScript 库，没有对应的声明文件；比如 lodash</p><p>情况二：我们给自己的代码中声明一些类型，方便在其他地方直接进行使用；</p><h3 id="声明变量-函数-类"><a href="#声明变量-函数-类" class="headerlink" title="声明变量-函数-类"></a>声明变量-函数-类</h3><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191623791.png"></p><h3 id="声明模块"><a href="#声明模块" class="headerlink" title="声明模块"></a>声明模块</h3><p>我们也可以声明模块，比如 loash 模块默认不能使用的情况，可以自己来声明这个模块：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191624569.png"></p><p>声明模块的语法: declare module ‘模块名’ {}。</p><p>在声明模块的内部，我们可以通过 export 导出对应库的类、函数等；</p><h3 id="declare-文件"><a href="#declare-文件" class="headerlink" title="declare 文件"></a>declare 文件</h3><p>在某些情况下，我们也可以声明文件：</p><p>比如在开发 vue 的过程中，默认是不识别我们的.vue 文件的，那么我们就需要对其进行文件的声明；</p><p>比如在开发中我们使用了 jpg 这类图片文件，默认 typescript 也是不支持的，也需要对其进行声明；</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191624103.png" alt="image-20211019162441584"></p><h3 id="declare-命名空间"><a href="#declare-命名空间" class="headerlink" title="declare 命名空间"></a>declare 命名空间</h3><p>比如我们在 index.html 中直接引入了 jQuery：</p><p>CDN 地址： <a target="_blank" rel="noopener external nofollow noreferrer" href="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js">https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js</a></p><p>我们可以进行命名空间的声明：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191625278.png"></p><p>在 main.ts 中就可以用了：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191625308.png"></p><h3 id="tsconfig-json-文件"><a href="#tsconfig-json-文件" class="headerlink" title="tsconfig.json 文件"></a>tsconfig.json 文件</h3><p>tsconfig.json 是用于配置 TypeScript 编译时的配置选项：</p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.typescriptlang.org/tsconfig">https://www.typescriptlang.org/tsconfig</a></p><p>我们这里讲解几个比较常见的：</p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191625988.png"></p><p><img src="/img/loading.gif" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191626567.png"></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:2268025923@qq.com" rel="external nofollow noreferrer">Violet</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://qwq3.top/posts/85fb.html">https://qwq3.top/posts/85fb.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://qwq3.top" target="_blank">Violet`Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/TypeScript/">TypeScript</a></div><div class="post_share"><div class="social-share" data-image="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191510330.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/posts/f748.html"><img class="prev-cover" data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110071038702.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Vuex 的状态管理</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div><div id="comment-switch"><span class="first-comment">Twikoo</span><span class="switch-btn"></span><span class="second-comment">Waline</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/waterchen520/cdn@5.0/qiqi/img/23.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"><div class="author-info__name">Violet</div><div class="author-info__description">生活明朗,万物可爱💖</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">54</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/WaterChen520"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/WaterChen520" rel="external nofollow noreferrer" target="_blank" title="Github"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-gitHub"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=2268025923@qq.com" rel="external nofollow noreferrer" target="_blank" title="Email"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang"></use></svg></a><a class="social-icon faa-parent animated-hover" href="/atom.xml" target="_blank" title="RSS"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-rss"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/372204786" rel="external nofollow noreferrer" target="_blank" title="BiliBili"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a><a class="social-icon faa-parent animated-hover" href="tencent://Message/?Uin=2268025923&amp;amp;websiteName=local.edu.com:8888=&amp;amp;Menu=yes" rel="external nofollow noreferrer" target="_blank" title="QQ"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-QQ1"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来看我的博客鸭~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-%E7%9A%84%E7%97%9B%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">JavaScript 的痛点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-%E6%AD%A3%E5%9C%A8%E6%85%A2%E6%85%A2%E5%8F%98%E5%A5%BD"><span class="toc-number">3.</span> <span class="toc-text">JavaScript 正在慢慢变好</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">类型带来的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E9%94%99%E8%AF%AF"><span class="toc-number">5.</span> <span class="toc-text">类型错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%80%9D%E7%BB%B4%E7%9A%84%E7%BC%BA%E5%A4%B1"><span class="toc-number">6.</span> <span class="toc-text">类型思维的缺失</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-%E6%B7%BB%E5%8A%A0%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">7.</span> <span class="toc-text">JavaScript 添加类型约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86-TypeScript"><span class="toc-number">8.</span> <span class="toc-text">认识 TypeScript</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeScript-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">8.1.</span> <span class="toc-text">TypeScript 的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%97%E5%A4%9A%E9%A1%B9%E7%9B%AE%E9%87%87%E7%94%A8-TypeScript"><span class="toc-number">8.2.</span> <span class="toc-text">众多项目采用 TypeScript</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypeScript-%E7%9A%84%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83"><span class="toc-number">9.</span> <span class="toc-text">TypeScript 的编译环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypeScript-%E7%9A%84%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">10.</span> <span class="toc-text">TypeScript 的运行环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">11.</span> <span class="toc-text">变量的声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">11.1.</span> <span class="toc-text">声明变量的关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%EF%BC%88%E6%8E%A8%E6%96%AD%EF%BC%89"><span class="toc-number">11.2.</span> <span class="toc-text">变量的类型推导（推断）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-%E5%92%8C-TypeScript-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.</span> <span class="toc-text">JavaScript 和 TypeScript 的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaScript-%E7%B1%BB%E5%9E%8B-%E2%80%93-number-%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.1.</span> <span class="toc-text">JavaScript 类型 – number 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaScript-%E7%B1%BB%E5%9E%8B-%E2%80%93-boolean-%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.2.</span> <span class="toc-text">JavaScript 类型 – boolean 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaScript-%E7%B1%BB%E5%9E%8B-%E2%80%93-string-%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.3.</span> <span class="toc-text">JavaScript 类型 – string 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaScript-%E7%B1%BB%E5%9E%8B-%E2%80%93-Array-%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.4.</span> <span class="toc-text">JavaScript 类型 – Array 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaScript-%E7%B1%BB%E5%9E%8B-%E2%80%93-Object-%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.5.</span> <span class="toc-text">JavaScript 类型 – Object 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaScript-%E7%B1%BB%E5%9E%8B-%E2%80%93-Symbol-%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.6.</span> <span class="toc-text">JavaScript 类型 – Symbol 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaScript-%E7%B1%BB%E5%9E%8B-%E2%80%93-null-%E5%92%8C-undefined-%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.7.</span> <span class="toc-text">JavaScript 类型 – null 和 undefined 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeScript-%E7%B1%BB%E5%9E%8B-any-%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.8.</span> <span class="toc-text">TypeScript 类型 - any 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeScript-%E7%B1%BB%E5%9E%8B-unknown-%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.9.</span> <span class="toc-text">TypeScript 类型 - unknown 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeScript-%E7%B1%BB%E5%9E%8B-void-%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.10.</span> <span class="toc-text">TypeScript 类型 - void 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeScript-%E7%B1%BB%E5%9E%8B-never-%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.11.</span> <span class="toc-text">TypeScript 类型 - never 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeScript-%E7%B1%BB%E5%9E%8B-tuple-%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.12.</span> <span class="toc-text">TypeScript 类型 - tuple 类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">13.</span> <span class="toc-text">函数的参数类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">14.</span> <span class="toc-text">函数的返回值类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">15.</span> <span class="toc-text">匿名函数的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">16.</span> <span class="toc-text">对象类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">17.</span> <span class="toc-text">可选类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">18.</span> <span class="toc-text">联合类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">19.</span> <span class="toc-text">使用联合类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">20.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80-as"><span class="toc-number">21.</span> <span class="toc-text">类型断言 as</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%A9%BA%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">22.</span> <span class="toc-text">非空类型断言!</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E9%93%BE%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">23.</span> <span class="toc-text">可选链的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">24.</span> <span class="toc-text">??和!!的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">25.</span> <span class="toc-text">字面量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E6%8E%A8%E7%90%86"><span class="toc-number">26.</span> <span class="toc-text">字面量推理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%BC%A9%E5%B0%8F"><span class="toc-number">27.</span> <span class="toc-text">类型缩小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof"><span class="toc-number">28.</span> <span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E7%AD%89%E7%BC%A9%E5%B0%8F"><span class="toc-number">29.</span> <span class="toc-text">平等缩小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof"><span class="toc-number">30.</span> <span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#in"><span class="toc-number">31.</span> <span class="toc-text">in</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypeScript-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">32.</span> <span class="toc-text">TypeScript 函数类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypeScript-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">33.</span> <span class="toc-text">TypeScript 函数类型解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%AF%E9%80%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">34.</span> <span class="toc-text">参数的可选类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">35.</span> <span class="toc-text">默认参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0"><span class="toc-number">36.</span> <span class="toc-text">剩余参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%8E%A8%E5%AF%BC%E7%9A%84-this-%E7%B1%BB%E5%9E%8B"><span class="toc-number">37.</span> <span class="toc-text">可推导的 this 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">38.</span> <span class="toc-text">函数的重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="toc-number">39.</span> <span class="toc-text">联合类型和重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">40.</span> <span class="toc-text">认识类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">40.1.</span> <span class="toc-text">类的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">40.2.</span> <span class="toc-text">类的继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">40.3.</span> <span class="toc-text">类的成员修饰符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7-readonly"><span class="toc-number">41.</span> <span class="toc-text">只读属性 readonly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getters-setters"><span class="toc-number">42.</span> <span class="toc-text">getters&#x2F;setters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">43.</span> <span class="toc-text">静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB-abstract"><span class="toc-number">44.</span> <span class="toc-text">抽象类 abstract</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">45.</span> <span class="toc-text">类的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">46.</span> <span class="toc-text">接口的声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="toc-number">46.1.</span> <span class="toc-text">可选属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">46.2.</span> <span class="toc-text">只读属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">46.3.</span> <span class="toc-text">索引类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">46.4.</span> <span class="toc-text">函数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF"><span class="toc-number">46.5.</span> <span class="toc-text">接口继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">46.6.</span> <span class="toc-text">接口的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">47.</span> <span class="toc-text">交叉类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">47.1.</span> <span class="toc-text">交叉类型的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interface-%E5%92%8C-type-%E5%8C%BA%E5%88%AB"><span class="toc-number">48.</span> <span class="toc-text">interface 和 type 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E8%B5%8B%E5%80%BC"><span class="toc-number">49.</span> <span class="toc-text">字面量赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypeScript-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">50.</span> <span class="toc-text">TypeScript 枚举类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC"><span class="toc-number">51.</span> <span class="toc-text">枚举类型的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E6%B3%9B%E5%9E%8B"><span class="toc-number">52.</span> <span class="toc-text">认识泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E5%8C%96"><span class="toc-number">53.</span> <span class="toc-text">泛型实现类型参数化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A1%A5%E5%85%85"><span class="toc-number">53.1.</span> <span class="toc-text">泛型的基本补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">54.</span> <span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">55.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">56.</span> <span class="toc-text">泛型约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91"><span class="toc-number">57.</span> <span class="toc-text">模块化开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-namespace"><span class="toc-number">58.</span> <span class="toc-text">命名空间 namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">59.</span> <span class="toc-text">类型的查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-number">60.</span> <span class="toc-text">内置类型声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A3%B0%E6%98%8E"><span class="toc-number">61.</span> <span class="toc-text">外部定义类型声明和自定义声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F-%E5%87%BD%E6%95%B0-%E7%B1%BB"><span class="toc-number">62.</span> <span class="toc-text">声明变量-函数-类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%A8%A1%E5%9D%97"><span class="toc-number">63.</span> <span class="toc-text">声明模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#declare-%E6%96%87%E4%BB%B6"><span class="toc-number">64.</span> <span class="toc-text">declare 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#declare-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">65.</span> <span class="toc-text">declare 命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tsconfig-json-%E6%96%87%E4%BB%B6"><span class="toc-number">66.</span> <span class="toc-text">tsconfig.json 文件</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/85fb.html" title="TypeScript的基本使用"><img data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110191510330.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="TypeScript的基本使用"></a><div class="content"><a class="title" href="/posts/85fb.html" title="TypeScript的基本使用">TypeScript的基本使用</a><time datetime="2021-11-07T12:48:59.000Z" title="发表于 2021-11-07 12:48:59">2021-11-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f748.html" title="Vuex 的状态管理"><img data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110071038702.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Vuex 的状态管理"></a><div class="content"><a class="title" href="/posts/f748.html" title="Vuex 的状态管理">Vuex 的状态管理</a><time datetime="2021-10-30T11:28:29.000Z" title="发表于 2021-10-30 11:28:29">2021-10-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/823a.html" title="VueRouter 路由使用"><img data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110060943730.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="VueRouter 路由使用"></a><div class="content"><a class="title" href="/posts/823a.html" title="VueRouter 路由使用">VueRouter 路由使用</a><time datetime="2021-10-21T16:20:14.000Z" title="发表于 2021-10-21 16:20:14">2021-10-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/24d6.html" title="Vue3 源码解析"><img data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110060943629.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Vue3 源码解析"></a><div class="content"><a class="title" href="/posts/24d6.html" title="Vue3 源码解析">Vue3 源码解析</a><time datetime="2021-10-15T18:10:12.000Z" title="发表于 2021-10-15 18:10:12">2021-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3d9.html" title="Vue3 Composition API"><img data-lazy-src="https://picgo-1302391568.cos.ap-chengdu.myqcloud.com/img/202110060943559.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Vue3 Composition API"></a><div class="content"><a class="title" href="/posts/3d9.html" title="Vue3 Composition API">Vue3 Composition API</a><time datetime="2021-10-09T11:10:12.000Z" title="发表于 2021-10-09 11:10:12">2021-10-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Violet</div><div class="footer_custom_text"><div style="font-size:12px"><span id="timeDate"></span><span id="times"></span><i class="fas fa-heartbeat" style="color:red"></i><br>生活明朗，万物可爱. <img src="https://cdn.jsdelivr.net/gh/waterchen520/cdn@5.0/qiqi/img/beian.jpg" style="margin-bottom:-3px"> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://beian.miit.gov.cn/#/Integrated/index" style="text-decoration:none">湘ICP备2021008511号-1</a><br><div class="github-badge"><a href="https://hexo.io/" rel="external nofollow noreferrer" target="_blank" title="由 Hexo 强力驱动" style="color:#fff"><span class="badge-subject">Powered</span><span class="badge-value bg-blue">Hexo</span></a> <a style="color:#fff" href="https://github.com/" rel="external nofollow noreferrer" target="_blank" title="静态网页托管于 Github"><span class="badge-subject">Hosted</span><span class="badge-value bg-brightgreen">Github</span></a> <a style="color:#fff" href="https://www.jsdelivr.com/" rel="external nofollow noreferrer" target="_blank" title="jsDelivr 提供 CDN 加速服务"><span class="badge-subject">CDN</span><span class="badge-value bg-orange">jsDelivr</span></a> <a style="color:#fff" href="https://github.com/jerryc127/hexo-theme-butterfly" rel="external nofollow noreferrer" target="_blank" title="站点使用 Butterfly 3.7.1版本 主题"><span class="badge-subject">Theme</span><span class="badge-value bg-blue">Butterfly 3.7.1</span></a><a style="color:#fff" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank" title="本站点采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可"><div class="badge-subject"><i class="fa fa-copyright"></i></div><div class="badge-value bg-lightgrey">BY-NC-SA 4.0</div></a></div></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="输入关键词进行查找" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script async>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",()=>{preloader.endLoading()}),setTimeout((function(){preloader.endLoading()}),5e3)</script></div><div class="js-pjax"><script>var gitcalendar=new Vue({el:"#gitcalendar",data:{simplemode:!1,user:"WaterChen520",fixed:"fixed",px:"px",x:"",y:"",span1:"",span2:"",month:["一月","二月","三月","四月","五月","六月","七月","八月","九月","十月","十一月","十二月"],monthchange:[],oneyearbeforeday:"",thisday:"",amonthago:"",aweekago:"",weekdatacore:0,datacore:0,total:0,datadate:"",data:[],positionplusdata:[],firstweek:[],lastweek:[],beforeweek:[],thisweekdatacore:0,mounthbeforeday:0,mounthfirstindex:0,crispedges:"crispedges",thisdayindex:0,amonthagoindex:0,amonthagoweek:[],firstdate:[],first2date:[],montharrbefore:[],monthindex:0,color:["#ebedf0","#fdcdec","#fc9bd9","#fa6ac5","#f838b2","#f5089f","#c4067e","#92055e","#540336","#48022f","#30021f"]},methods:{selectStyle(e,t){document.querySelector(".angle-wrapper").style.display="block",this.span1=e.date,this.span2=e.count,this.x=t.clientX-100,this.y=t.clientY-60},outStyle(){document.querySelector(".angle-wrapper").style.display="none"},thiscolor(e){if(0===e){parseInt(e/2);return this.color[0]}if(e<2)return this.color[1];if(e<20){let t=parseInt(e/2);return this.color[t]}return this.color[9]}}}),apiurl="https://python-github-calendar-api-bay.vercel.app/api?",githubapiurl=apiurl+gitcalendar.user;function responsiveChart(){let e=document.getElementById("gitcanvas");if(e){let t=document.getElementById("gitmessage"),a=e.getContext("2d");e.width=document.getElementById("gitcalendarcanvasbox").offsetWidth;let n=.96*e.width/gitcalendar.data.length;e.height=9*n;let i=.8*n,d={x:.02*e.width,y:.025*e.width};for(let t in gitcalendar.data){weekdata=gitcalendar.data[t];for(let e in weekdata){let t={date:"",count:"",x:0,y:0};gitcalendar.positionplusdata.push(t),a.fillStyle=gitcalendar.thiscolor(weekdata[e].count),d.y=Math.round(100*d.y)/100,t.date=weekdata[e].date,t.count=weekdata[e].count,t.x=d.x,t.y=d.y,a.fillRect(d.x,d.y,i,i),d.y=d.y+n}d.y=.025*e.width,d.x=d.x+n}a.font="600  Arial",a.fillStyle="#aaa",a.fillText("日",0,1.9*n),a.fillText("二",0,3.9*n),a.fillText("四",0,5.9*n),a.fillText("六",0,7.9*n);let r=e.width/24;for(let t in gitcalendar.monthchange)a.fillText(gitcalendar.monthchange[t],r,.7*n),r+=e.width/12;t.onmousemove=function(e){document.querySelector(".angle-wrapper").style.display="none"},e.onmousemove=function(t){document.querySelector(".angle-wrapper").style.display="none",function(e,t){var a=e.getBoundingClientRect(),n=t.clientX-a.left*(e.width/a.width),d=t.clientY-a.top*(e.height/a.height);for(let e of gitcalendar.positionplusdata){let a=n-e.x,r=d-e.y;0<a&&a<i&&0<r&&r<i&&(document.querySelector(".angle-wrapper").style.display="block",gitcalendar.span1=e.date,gitcalendar.span2=e.count,gitcalendar.x=t.clientX-100,gitcalendar.y=t.clientY-60)}}(e,t)}}}function addlastmonth(){0===gitcalendar.thisdayindex?(thisweekcore(52),thisweekcore(51),thisweekcore(50),thisweekcore(49),thisweekcore(48),gitcalendar.thisweekdatacore+=gitcalendar.firstdate[6].count,gitcalendar.amonthago=gitcalendar.firstdate[6].date):(thisweekcore(52),thisweekcore(51),thisweekcore(50),thisweekcore(49),thisweek2core(),gitcalendar.amonthago=gitcalendar.first2date[gitcalendar.thisdayindex-1].date)}function thisweek2core(){for(let e=gitcalendar.thisdayindex-1;e<gitcalendar.first2date.length;e++)gitcalendar.thisweekdatacore+=gitcalendar.first2date[e].count}function thisweekcore(e){for(let t of gitcalendar.data[e])gitcalendar.thisweekdatacore+=t.count}function addlastweek(){for(let e of gitcalendar.lastweek)gitcalendar.weekdatacore+=e.count}function addbeforeweek(){for(let e=gitcalendar.thisdayindex;e<gitcalendar.beforeweek.length;e++)gitcalendar.weekdatacore+=gitcalendar.beforeweek[e].count}function addweek(e){6===gitcalendar.thisdayindex?(gitcalendar.aweekago=gitcalendar.lastweek[0].date,addlastweek()):(lastweek=e.contributions[51],gitcalendar.aweekago=lastweek[gitcalendar.thisdayindex+1].date,addlastweek(),addbeforeweek())}fetch(githubapiurl).then(e=>e.json()).then(e=>{gitcalendar.data=e.contributions,gitcalendar.total=e.total,gitcalendar.first2date=gitcalendar.data[48],gitcalendar.firstdate=gitcalendar.data[47],gitcalendar.firstweek=e.contributions[0],gitcalendar.lastweek=e.contributions[52],gitcalendar.beforeweek=e.contributions[51],gitcalendar.thisdayindex=gitcalendar.lastweek.length-1,gitcalendar.thisday=gitcalendar.lastweek[gitcalendar.thisdayindex].date,gitcalendar.oneyearbeforeday=gitcalendar.firstweek[0].date,gitcalendar.monthindex=1*gitcalendar.thisday.substring(5,7),gitcalendar.montharrbefore=gitcalendar.month.splice(gitcalendar.monthindex,12-gitcalendar.monthindex),gitcalendar.monthchange=gitcalendar.montharrbefore.concat(gitcalendar.month),addweek(e),addlastmonth(),responsiveChart()}).catch((function(e){console.log(e)})),window.onresize=function(){gitcalendar.simplemode&&responsiveChart()},window.onscroll=function(){document.querySelector(".angle-wrapper")&&(document.querySelector(".angle-wrapper").style.display="none")}</script><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"blogcomment-9gwtd96d01685149",region:""},null))},n=()=>{twikoo.getCommentsCount({envId:"blogcomment-9gwtd96d01685149",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.innerText=o[0].count})).catch((function(t){console.error(t)}))},e=(e=!1)=>{"object"==typeof twikoo?(o(),e&&t&&setTimeout(n,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo@1.3.0/dist/twikoo.all.min.js").then(()=>{o(),e&&t&&setTimeout(n,0)})};e(!0)})()</script><script>function loadWaline(){function e(){new Waline(Object.assign({el:"#waline-wrap",serverURL:"https://waline-api-ebon.vercel.app/",avatar:"mp",path:location.pathname,emojiCDN:"//i0.hdslb.com/bfs/emote/",emojiMaps:"",visitor:!1},[{placeholder:"今天应该会收到少佐的信叭~<br>生活明朗，万物可爱"}]))}"function"==typeof Waline?e():getScript("https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js").then(e)}{function loadOtherComment(){loadWaline()}setTimeout(loadWaline,0)}</script></div><script data-pjax src="https://cdn.jsdelivr.net/gh/waterchen520/cdn@5.0/qiqi/js/qiqi.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/time.js"></script><script async src="//at.alicdn.com/t/font_2508400_xe8j12uijki.js"></script><script async data-pjax src="/js/floatpanel.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script async src="//at.alicdn.com/t/font_2264842_3izu8i5eoc2.js"></script><div class="aplayer no-destroy" data-id="7794756738" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="order" data-preload="metadata" data-autoplay="false" data-mutex="true" muted></div><script async src="/js/custom.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script src="//code.tidio.co/lpcfvqfq39w0zjxvzzrchgwldmpvavcc.js" async></script><script>function onTidioChatApiReady(){window.tidioChatApi.hide(),window.tidioChatApi.on("close",(function(){window.tidioChatApi.hide()}))}window.tidioChatApi?window.tidioChatApi.on("ready",onTidioChatApiReady):document.addEventListener("tidioChat-ready",onTidioChatApiReady);var chatBtnFn=()=>{document.getElementById("chat_btn").addEventListener("click",(function(){window.tidioChatApi.show(),window.tidioChatApi.open()}))};chatBtnFn()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/gh/waterchen520/cdn2@2.0/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/waterchen520/cdn2@2.0/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax], .pjax-reload script").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:send",(function(){if("object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="pjax-reload"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","1.5s"),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset","30"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("article-sort-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__slideInRight"),arr[i].setAttribute("data-wow-duration","1.5s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://cdn.jsdelivr.net/gh/graingert/wow@1.3.0/dist/wow.min.js"></script><script defer src="https://cdn.jsdelivr.net/gh/waterchen520/cdn2@master/wow_init.js"></script><div class="app-refresh" id="app-refresh" style="position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease"><div class="app-refresh-wrap" style="display:flex;color:#fff;height:100%;align-items:center;justify-content:center"><label>✨ 有新文章啦！ 👉</label><a href="javascript:void(0)" rel="external nofollow noreferrer" onclick="location.reload()"><span style="color:#fff;text-decoration:underline;cursor:pointer">🍗点击食用🍔</span></a></div></div><script>function showNotification(){if(GLOBAL_CONFIG.Snackbar){var t="light"===document.documentElement.getAttribute("data-theme")?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show({text:"✨ 有新文章啦！ 👉",backgroundColor:t,duration:5e5,pos:e,actionText:"🍗点击食用🍔",actionTextColor:"#fff",onActionClick:function(t){location.reload()}})}else{var o=`top: 0; background: ${"light"===document.documentElement.getAttribute("data-theme")?"#49b1f5":"#1f1f1f"};`;document.getElementById("app-refresh").style.cssText=o}}"serviceWorker"in navigator&&(navigator.serviceWorker.controller&&navigator.serviceWorker.addEventListener("controllerchange",(function(){showNotification()})),window.addEventListener("load",(function(){navigator.serviceWorker.register("/sw.js")})))</script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({model:{jsonPath:"/live2dw/assets/koharu.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!1},log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html>